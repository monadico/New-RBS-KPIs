"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_next_dist_client_components_router-reducer_p"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    abortTask: function() {\n        return abortTask;\n    },\n    listenForDynamicRequest: function() {\n        return listenForDynamicRequest;\n    },\n    startPPRNavigation: function() {\n        return startPPRNavigation;\n    },\n    updateCacheNodeOnPopstateRestoration: function() {\n        return updateCacheNodeOnPopstateRestoration;\n    }\n});\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ./is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst MPA_NAVIGATION_TASK = {\n    route: null,\n    node: null,\n    dynamicRequestTree: null,\n    children: null\n};\nfunction startPPRNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {\n    const segmentPath = [];\n    return updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, false, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);\n}\nfunction updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {\n    // Diff the old and new trees to reuse the shared layouts.\n    const oldRouterStateChildren = oldRouterState[1];\n    const newRouterStateChildren = newRouterState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    if (!didFindRootLayout) {\n        // We're currently traversing the part of the tree that was also part of\n        // the previous route. If we discover a root layout, then we don't need to\n        // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n        const isRootLayout = newRouterState[4] === true;\n        if (isRootLayout) {\n            // Found a matching root layout.\n            didFindRootLayout = true;\n        }\n    }\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    // Clone the current set of segment children, even if they aren't active in\n    // the new tree.\n    // TODO: We currently retain all the inactive segments indefinitely, until\n    // there's an explicit refresh, or a parent layout is lazily refreshed. We\n    // rely on this for popstate navigations, which update the Router State Tree\n    // but do not eagerly perform a data fetch, because they expect the segment\n    // data to already be in the Cache Node tree. For highly static sites that\n    // are mostly read-only, this may happen only rarely, causing memory to\n    // leak. We should figure out a better model for the lifetime of inactive\n    // segments, so we can maintain instant back/forward navigations without\n    // leaking memory indefinitely.\n    const prefetchParallelRoutes = new Map(oldParallelRoutes);\n    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n    // the Route Tree that was returned by the server — for example, in the case\n    // of default parallel routes, we preserve the currently active segment. To\n    // avoid mutating the original tree, we clone the router state children along\n    // the return path.\n    let patchedRouterStateChildren = {};\n    let taskChildren = null;\n    // Most navigations require a request to fetch additional data from the\n    // server, either because the data was not already prefetched, or because the\n    // target route contains dynamic data that cannot be prefetched.\n    //\n    // However, if the target route is fully static, and it's already completely\n    // loaded into the segment cache, then we can skip the server request.\n    //\n    // This starts off as `false`, and is set to `true` if any of the child\n    // routes requires a dynamic request.\n    let needsDynamicRequest = false;\n    // As we traverse the children, we'll construct a FlightRouterState that can\n    // be sent to the server to request the dynamic data. If it turns out that\n    // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n    // end), then this will be discarded.\n    // TODO: We can probably optimize the format of this data structure to only\n    // include paths that are dynamic. Instead of reusing the\n    // FlightRouterState type.\n    let dynamicRequestTreeChildren = {};\n    for(let parallelRouteKey in newRouterStateChildren){\n        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];\n        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const newSegmentChild = newRouterStateChild[0];\n        const newSegmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            newSegmentChild\n        ]);\n        const newSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(newSegmentChild);\n        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;\n        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;\n        let taskChild;\n        if (newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {\n            // This is another kind of leaf segment — a default route.\n            //\n            // Default routes have special behavior. When there's no matching segment\n            // for a parallel route, Next.js preserves the currently active segment\n            // during a client navigation — but not for initial render. The server\n            // leaves it to the client to account for this. So we need to handle\n            // it here.\n            if (oldRouterStateChild !== undefined) {\n                // Reuse the existing Router State for this segment. We spawn a \"task\"\n                // just to keep track of the updated router state; unlike most, it's\n                // already fulfilled and won't be affected by the dynamic response.\n                taskChild = spawnReusedTask(oldRouterStateChild);\n            } else {\n                // There's no currently active segment. Switch to the \"create\" path.\n                taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else if (isSamePageNavigation && // Check if this is a page segment.\n        // TODO: We're not consistent about how we do this check. Some places\n        // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n        // check if there any any children, which is why I'm doing it here. We\n        // should probably encode an empty children set as `null` though. Either\n        // way, we should update all the checks to be consistent.\n        Object.keys(newRouterStateChild[1]).length === 0) {\n            // We special case navigations to the exact same URL as the current\n            // location. It's a common UI pattern for apps to refresh when you click a\n            // link to the current page. So when this happens, we refresh the dynamic\n            // data in the page segments.\n            //\n            // Note that this does not apply if the any part of the hash or search\n            // query has changed. This might feel a bit weird but it makes more sense\n            // when you consider that the way to trigger this behavior is to click\n            // the same link multiple times.\n            //\n            // TODO: We should probably refresh the *entire* route when this case\n            // occurs, not just the page segments. Essentially treating it the same as\n            // a refresh() triggered by an action, which is the more explicit way of\n            // modeling the UI pattern described above.\n            //\n            // Also note that this only refreshes the dynamic data, not static/\n            // cached data. If the page segment is fully static and prefetched, the\n            // request is skipped. (This is also how refresh() works.)\n            taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        } else if (oldRouterStateChild !== undefined && oldSegmentChild !== undefined && (0, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {\n            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {\n                // This segment exists in both the old and new trees. Recursively update\n                // the children.\n                taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);\n            } else {\n                // There's no existing Cache Node for this segment. Switch to the\n                // \"create\" path.\n                taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n            }\n        } else {\n            // This is a new tree. Switch to the \"create\" path.\n            taskChild = beginRenderingNewRouteTree(oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);\n        }\n        if (taskChild !== null) {\n            // Recursively propagate up the child tasks.\n            if (taskChild.route === null) {\n                // One of the child tasks discovered a change to the root layout.\n                // Immediately unwind from this recursive traversal.\n                return MPA_NAVIGATION_TASK;\n            }\n            if (taskChildren === null) {\n                taskChildren = new Map();\n            }\n            taskChildren.set(parallelRouteKey, taskChild);\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);\n                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n            // The child tree's route state may be different from the prefetched\n            // route sent by the server. We need to clone it as we traverse back up\n            // the tree.\n            const taskChildRoute = taskChild.route;\n            patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;\n            }\n        } else {\n            // The child didn't change. We can use the prefetched router state.\n            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;\n            dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;\n        }\n    }\n    if (taskChildren === null) {\n        // No new tasks were spawned.\n        return null;\n    }\n    const newCacheNode = {\n        lazyData: null,\n        rsc: oldCacheNode.rsc,\n        // We intentionally aren't updating the prefetchRsc field, since this node\n        // is already part of the current tree, because it would be weird for\n        // prefetch data to be newer than the final data. It probably won't ever be\n        // observable anyway, but it could happen if the segment is unmounted then\n        // mounted again, because LayoutRouter will momentarily switch to rendering\n        // prefetchRsc, via useDeferredValue.\n        prefetchRsc: oldCacheNode.prefetchRsc,\n        head: oldCacheNode.head,\n        prefetchHead: oldCacheNode.prefetchHead,\n        loading: oldCacheNode.loading,\n        // Everything is cloned except for the children, which we computed above.\n        parallelRoutes: prefetchParallelRoutes\n    };\n    return {\n        // Return a cloned copy of the router state with updated children.\n        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),\n        node: newCacheNode,\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction beginRenderingNewRouteTree(oldRouterState, newRouterState, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    if (!didFindRootLayout) {\n        // The route tree changed before we reached a layout. (The highest-level\n        // layout in a route tree is referred to as the \"root\" layout.) This could\n        // mean that we're navigating between two different root layouts. When this\n        // happens, we perform a full-page (MPA-style) navigation.\n        //\n        // However, the algorithm for deciding where to start rendering a route\n        // (i.e. the one performed in order to reach this function) is stricter\n        // than the one used to detect a change in the root layout. So just because\n        // we're re-rendering a segment outside of the root layout does not mean we\n        // should trigger a full-page navigation.\n        //\n        // Specifically, we handle dynamic parameters differently: two segments are\n        // considered the same even if their parameter values are different.\n        //\n        // Refer to isNavigatingToNewRootLayout for details.\n        //\n        // Note that we only have to perform this extra traversal if we didn't\n        // already discover a root layout in the part of the tree that is unchanged.\n        // In the common case, this branch is skipped completely.\n        if (oldRouterState === undefined || (0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {\n            // The root layout changed. Perform a full-page navigation.\n            return MPA_NAVIGATION_TASK;\n        }\n    }\n    return createCacheNodeOnNavigation(newRouterState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n}\nfunction createCacheNodeOnNavigation(routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Same traversal as updateCacheNodeNavigation, but we switch to this path\n    // once we reach the part of the tree that was not in the previous route. We\n    // don't need to diff against the old tree, we just need to create a new one.\n    if (prefetchData === null) {\n        // There's no prefetch for this segment. Everything from this point will be\n        // requested from the server, even if there are static children below it.\n        // Create a terminal task node that will later be fulfilled by\n        // server response.\n        return spawnPendingTask(routerState, null, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    const routerStateChildren = routerState[1];\n    const isPrefetchRscPartial = prefetchData[4];\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = Object.keys(routerStateChildren).length === 0;\n    // If prefetch data is available for a segment, and it's fully static (i.e.\n    // does not contain any dynamic holes), we don't need to request it from\n    // the server.\n    if (isPrefetchRscPartial || // Check if the head is partial (only relevant if this is a leaf segment)\n    isPrefetchHeadPartial && isLeafSegment) {\n        // We only have partial data from this segment. Like missing segments, we\n        // must request the full data from the server.\n        return spawnPendingTask(routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);\n    }\n    // The prefetched segment is fully static, so we don't need to request a new\n    // one from the server. Keep traversing down the tree until we reach something\n    // that requires a dynamic request.\n    const prefetchDataChildren = prefetchData[2];\n    const taskChildren = new Map();\n    const cacheNodeChildren = new Map();\n    let dynamicRequestTreeChildren = {};\n    let needsDynamicRequest = false;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    } else {\n        for(let parallelRouteKey in routerStateChildren){\n            const routerStateChild = routerStateChildren[parallelRouteKey];\n            const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n            const segmentChild = routerStateChild[0];\n            const segmentPathChild = segmentPath.concat([\n                parallelRouteKey,\n                segmentChild\n            ]);\n            const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n            const taskChild = createCacheNodeOnNavigation(routerStateChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n            taskChildren.set(parallelRouteKey, taskChild);\n            const dynamicRequestTreeChild = taskChild.dynamicRequestTree;\n            if (dynamicRequestTreeChild !== null) {\n                // Something in the child tree is dynamic.\n                needsDynamicRequest = true;\n                dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;\n            } else {\n                dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;\n            }\n            const newCacheNodeChild = taskChild.node;\n            if (newCacheNodeChild !== null) {\n                const newSegmentMapChild = new Map();\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    const rsc = prefetchData[1];\n    const loading = prefetchData[3];\n    return {\n        // Since we're inside a new route tree, unlike the\n        // `updateCacheNodeOnNavigation` path, the router state on the children\n        // tasks is always the same as the router state we pass in. So we don't need\n        // to clone/modify it.\n        route: routerState,\n        node: {\n            lazyData: null,\n            // Since this is a fully static segment, we don't need to use the\n            // `prefetchRsc` field.\n            rsc,\n            prefetchRsc: null,\n            head: isLeafSegment ? possiblyPartialPrefetchHead : null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: cacheNodeChildren\n        },\n        dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : null,\n        children: taskChildren\n    };\n}\nfunction patchRouterStateWithNewChildren(baseRouterState, newChildren) {\n    const clone = [\n        baseRouterState[0],\n        newChildren\n    ];\n    // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n    // confirm whether we need to copy all of these fields. Not sure the server\n    // ever sends, e.g. the refetch marker.\n    if (2 in baseRouterState) {\n        clone[2] = baseRouterState[2];\n    }\n    if (3 in baseRouterState) {\n        clone[3] = baseRouterState[3];\n    }\n    if (4 in baseRouterState) {\n        clone[4] = baseRouterState[4];\n    }\n    return clone;\n}\nfunction spawnPendingTask(routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    // Create a task that will later be fulfilled by data from the server.\n    // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n    // this to the server so it knows where to start rendering.\n    const dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[1]);\n    dynamicRequestTree[3] = 'refetch';\n    const newTask = {\n        route: routerState,\n        // Corresponds to the part of the route that will be rendered on the server.\n        node: createPendingCacheNode(routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),\n        // Because this is non-null, and it gets propagated up through the parent\n        // tasks, the root task will know that it needs to perform a server request.\n        dynamicRequestTree,\n        children: null\n    };\n    return newTask;\n}\nfunction spawnReusedTask(reusedRouterState) {\n    // Create a task that reuses an existing segment, e.g. when reusing\n    // the current active segment in place of a default route.\n    return {\n        route: reusedRouterState,\n        node: null,\n        dynamicRequestTree: null,\n        children: null\n    };\n}\nfunction listenForDynamicRequest(task, responsePromise) {\n    responsePromise.then((param)=>{\n        let { flightData } = param;\n        if (typeof flightData === 'string') {\n            // Happens when navigating to page in `pages` from `app`. We shouldn't\n            // get here because should have already handled this during\n            // the prefetch.\n            return;\n        }\n        for (const normalizedFlightData of flightData){\n            const { segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;\n            if (!dynamicData) {\n                continue;\n            }\n            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);\n        }\n        // Now that we've exhausted all the data we received from the server, if\n        // there are any remaining pending tasks in the tree, abort them now.\n        // If there's any missing data, it will trigger a lazy fetch.\n        abortTask(task, null);\n    }, (error)=>{\n        // This will trigger an error during render\n        abortTask(task, error);\n    });\n}\nfunction writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {\n    // The data sent by the server represents only a subtree of the app. We need\n    // to find the part of the task tree that matches the server response, and\n    // fulfill it using the dynamic data.\n    //\n    // segmentPath represents the parent path of subtree. It's a repeating pattern\n    // of parallel route key and segment:\n    //\n    //   [string, Segment, string, Segment, string, Segment, ...]\n    //\n    // Iterate through the path and finish any tasks that match this payload.\n    let task = rootTask;\n    for(let i = 0; i < segmentPath.length; i += 2){\n        const parallelRouteKey = segmentPath[i];\n        const segment = segmentPath[i + 1];\n        const taskChildren = task.children;\n        if (taskChildren !== null) {\n            const taskChild = taskChildren.get(parallelRouteKey);\n            if (taskChild !== undefined) {\n                const taskSegment = taskChild.route[0];\n                if ((0, _matchsegments.matchSegment)(segment, taskSegment)) {\n                    // Found a match for this task. Keep traversing down the task tree.\n                    task = taskChild;\n                    continue;\n                }\n            }\n        }\n        // We didn't find a child task that matches the server data. Exit. We won't\n        // abort the task, though, because a different FlightDataPath may be able to\n        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n        // once we've run out of data.\n        return;\n    }\n    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);\n}\nfunction finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {\n    if (task.dynamicRequestTree === null) {\n        // Everything in this subtree is already complete. Bail out.\n        return;\n    }\n    // dynamicData may represent a larger subtree than the task. Before we can\n    // finish the task, we need to line them up.\n    const taskChildren = task.children;\n    const taskNode = task.node;\n    if (taskChildren === null) {\n        // We've reached the leaf node of the pending task. The server data tree\n        // lines up the pending Cache Node tree. We can now switch to the\n        // normal algorithm.\n        if (taskNode !== null) {\n            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);\n            // Set this to null to indicate that this task is now complete.\n            task.dynamicRequestTree = null;\n        }\n        return;\n    }\n    // The server returned more data than we need to finish the task. Skip over\n    // the extra segments until we reach the leaf task node.\n    const serverChildren = serverRouterState[1];\n    const dynamicDataChildren = dynamicData[2];\n    for(const parallelRouteKey in serverRouterState){\n        const serverRouterStateChild = serverChildren[parallelRouteKey];\n        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];\n        const taskChild = taskChildren.get(parallelRouteKey);\n        if (taskChild !== undefined) {\n            const taskSegment = taskChild.route[0];\n            if ((0, _matchsegments.matchSegment)(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {\n                // Found a match for this task. Keep traversing down the task tree.\n                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);\n            }\n        }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    }\n}\nfunction createPendingCacheNode(routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {\n    const routerStateChildren = routerState[1];\n    const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null;\n    const parallelRoutes = new Map();\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;\n        const segmentChild = routerStateChild[0];\n        const segmentPathChild = segmentPath.concat([\n            parallelRouteKey,\n            segmentChild\n        ]);\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);\n        const newSegmentMapChild = new Map();\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n    }\n    // The head is assigned to every leaf segment delivered by the server. Based\n    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n    const isLeafSegment = parallelRoutes.size === 0;\n    if (isLeafSegment) {\n        // The segment path of every leaf segment (i.e. page) is collected into\n        // a result array. This is used by the LayoutRouter to scroll to ensure that\n        // new pages are visible after a navigation.\n        // TODO: We should use a string to represent the segment path instead of\n        // an array. We already use a string representation for the path when\n        // accessing the Segment Cache, so we can use the same one.\n        scrollableSegmentsResult.push(segmentPath);\n    }\n    const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null;\n    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;\n    return {\n        lazyData: null,\n        parallelRoutes: parallelRoutes,\n        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n        prefetchHead: isLeafSegment ? prefetchHead : [\n            null,\n            null\n        ],\n        // TODO: Technically, a loading boundary could contain dynamic data. We must\n        // have separate `loading` and `prefetchLoading` fields to handle this, like\n        // we do for the segment data and head.\n        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n        // Create a deferred promise. This will be fulfilled once the dynamic\n        // response is received from the server.\n        rsc: createDeferredRsc(),\n        head: isLeafSegment ? createDeferredRsc() : null\n    };\n}\nfunction finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {\n    // Writes a dynamic response into an existing Cache Node tree. This does _not_\n    // create a new tree, it updates the existing tree in-place. So it must follow\n    // the Suspense rules of cache safety — it can resolve pending promises, but\n    // it cannot overwrite existing data. It can add segments to the tree (because\n    // a missing segment will cause the layout router to suspend).\n    // but it cannot delete them.\n    //\n    // We must resolve every promise in the tree, or else it will suspend\n    // indefinitely. If we did not receive data for a segment, we will resolve its\n    // data promise to `null` to trigger a lazy fetch during render.\n    const taskStateChildren = taskState[1];\n    const serverStateChildren = serverState[1];\n    const dataChildren = dynamicData[2];\n    // The router state that we traverse the tree with (taskState) is the same one\n    // that we used to construct the pending Cache Node tree. That way we're sure\n    // to resolve all the pending promises.\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in taskStateChildren){\n        const taskStateChild = taskStateChildren[parallelRouteKey];\n        const serverStateChild = serverStateChildren[parallelRouteKey];\n        const dataChild = dataChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        const taskSegmentChild = taskStateChild[0];\n        const taskSegmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);\n        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;\n        if (cacheNodeChild !== undefined) {\n            if (serverStateChild !== undefined && (0, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[0])) {\n                if (dataChild !== undefined && dataChild !== null) {\n                    // This is the happy path. Recursively update all the children.\n                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);\n                } else {\n                    // The server never returned data for this segment. Trigger a lazy\n                    // fetch during render. This shouldn't happen because the Route Tree\n                    // and the Seed Data tree sent by the server should always be the same\n                    // shape when part of the same server response.\n                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n                }\n            } else {\n                // The server never returned data for this segment. Trigger a lazy\n                // fetch during render.\n                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);\n            }\n        } else {\n        // The server response matches what was expected to receive, but there's\n        // no matching Cache Node in the task tree. This is a bug in the\n        // implementation because we should have created a node for every\n        // segment in the tree that's associated with this task.\n        }\n    }\n    // Use the dynamic data from the server to fulfill the deferred RSC promise\n    // on the Cache Node.\n    const rsc = cacheNode.rsc;\n    const dynamicSegmentData = dynamicData[1];\n    if (rsc === null) {\n        // This is a lazy cache node. We can overwrite it. This is only safe\n        // because we know that the LayoutRouter suspends if `rsc` is `null`.\n        cacheNode.rsc = dynamicSegmentData;\n    } else if (isDeferredRsc(rsc)) {\n        // This is a deferred RSC promise. We can fulfill it with the data we just\n        // received from the server. If it was already resolved by a different\n        // navigation, then this does nothing because we can't overwrite data.\n        rsc.resolve(dynamicSegmentData);\n    } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved with the dynamic head from\n    // the server.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(dynamicHead);\n    }\n}\nfunction abortTask(task, error) {\n    const cacheNode = task.node;\n    if (cacheNode === null) {\n        // This indicates the task is already complete.\n        return;\n    }\n    const taskChildren = task.children;\n    if (taskChildren === null) {\n        // Reached the leaf task node. This is the root of a pending cache\n        // node tree.\n        abortPendingCacheNode(task.route, cacheNode, error);\n    } else {\n        // This is an intermediate task node. Keep traversing until we reach a\n        // task node with no children. That will be the root of the cache node tree\n        // that needs to be resolved.\n        for (const taskChild of taskChildren.values()){\n            abortTask(taskChild, error);\n        }\n    }\n    // Set this to null to indicate that this task is now complete.\n    task.dynamicRequestTree = null;\n}\nfunction abortPendingCacheNode(routerState, cacheNode, error) {\n    // For every pending segment in the tree, resolve its `rsc` promise to `null`\n    // to trigger a lazy fetch during render.\n    //\n    // Or, if an error object is provided, it will error instead.\n    const routerStateChildren = routerState[1];\n    const parallelRoutes = cacheNode.parallelRoutes;\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentMapChild = parallelRoutes.get(parallelRouteKey);\n        if (segmentMapChild === undefined) {\n            continue;\n        }\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);\n        if (cacheNodeChild !== undefined) {\n            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);\n        } else {\n        // This shouldn't happen because we're traversing the same tree that was\n        // used to construct the cache nodes in the first place.\n        }\n    }\n    const rsc = cacheNode.rsc;\n    if (isDeferredRsc(rsc)) {\n        if (error === null) {\n            // This will trigger a lazy fetch during render.\n            rsc.resolve(null);\n        } else {\n            // This will trigger an error during rendering.\n            rsc.reject(error);\n        }\n    }\n    // Check if this is a leaf segment. If so, it will have a `head` property with\n    // a pending promise that needs to be resolved. If an error was provided, we\n    // will not resolve it with an error, since this is rendered at the root of\n    // the app. We want the segment to error, not the entire app.\n    const head = cacheNode.head;\n    if (isDeferredRsc(head)) {\n        head.resolve(null);\n    }\n}\nfunction updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {\n    // A popstate navigation reads data from the local cache. It does not issue\n    // new network requests (unless the cache entries have been evicted). So, we\n    // update the cache to drop the prefetch data for any segment whose dynamic\n    // data was already received. This prevents an unnecessary flash back to PPR\n    // state during a back/forward navigation.\n    //\n    // This function clones the entire cache node tree and sets the `prefetchRsc`\n    // field to `null` to prevent it from being rendered. We can't mutate the node\n    // in place because this is a concurrent data structure.\n    const routerStateChildren = routerState[1];\n    const oldParallelRoutes = oldCacheNode.parallelRoutes;\n    const newParallelRoutes = new Map(oldParallelRoutes);\n    for(let parallelRouteKey in routerStateChildren){\n        const routerStateChild = routerStateChildren[parallelRouteKey];\n        const segmentChild = routerStateChild[0];\n        const segmentKeyChild = (0, _createroutercachekey.createRouterCacheKey)(segmentChild);\n        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);\n        if (oldSegmentMapChild !== undefined) {\n            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);\n            if (oldCacheNodeChild !== undefined) {\n                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);\n                const newSegmentMapChild = new Map(oldSegmentMapChild);\n                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);\n                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);\n            }\n        }\n    }\n    // Only show prefetched data if the dynamic data is still pending.\n    //\n    // Tehnically, what we're actually checking is whether the dynamic network\n    // response was received. But since it's a streaming response, this does not\n    // mean that all the dynamic data has fully streamed in. It just means that\n    // _some_ of the dynamic data was received. But as a heuristic, we assume that\n    // the rest dynamic data will stream in quickly, so it's still better to skip\n    // the prefetch state.\n    const rsc = oldCacheNode.rsc;\n    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending';\n    return {\n        lazyData: null,\n        rsc,\n        head: oldCacheNode.head,\n        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [\n            null,\n            null\n        ],\n        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n        loading: oldCacheNode.loading,\n        // These are the cloned children we computed above\n        parallelRoutes: newParallelRoutes\n    };\n}\nconst DEFERRED = Symbol();\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value) {\n    return value && value.tag === DEFERRED;\n}\nfunction createDeferredRsc() {\n    let resolve;\n    let reject;\n    const pendingRsc = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    pendingRsc.status = 'pending';\n    pendingRsc.resolve = (value)=>{\n        if (pendingRsc.status === 'pending') {\n            const fulfilledRsc = pendingRsc;\n            fulfilledRsc.status = 'fulfilled';\n            fulfilledRsc.value = value;\n            resolve(value);\n        }\n    };\n    pendingRsc.reject = (error)=>{\n        if (pendingRsc.status === 'pending') {\n            const rejectedRsc = pendingRsc;\n            rejectedRsc.status = 'rejected';\n            rejectedRsc.reason = error;\n            reject(error);\n        }\n    };\n    pendingRsc.tag = DEFERRED;\n    return pendingRsc;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=ppr-navigations.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHByLW5hdmlnYXRpb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTYvQmdCQSxTQUFTO2VBQVRBOztJQXRWQUMsdUJBQXVCO2VBQXZCQTs7SUFobEJBQyxrQkFBa0I7ZUFBbEJBOztJQWsvQkFDLG9DQUFvQztlQUFwQ0E7OztxQ0E3akNvQjsyQ0FDUDtrREFDUTt5REFFTztBQWlDNUMsTUFBTUMsc0JBQXlDO0lBQzdDQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsb0JBQW9CO0lBQ3BCQyxVQUFVO0FBQ1o7QUFpQ08sU0FBU04sbUJBQ2RPLFlBQXVCLEVBQ3ZCQyxjQUFpQyxFQUNqQ0MsY0FBaUMsRUFDakNDLFlBQXNDLEVBQ3RDQyxZQUE2QixFQUM3QkMscUJBQThCLEVBQzlCQyxvQkFBNkIsRUFDN0JDLHdCQUFrRDtJQUVsRCxNQUFNQyxjQUF3QyxFQUFFO0lBQ2hELE9BQU9DLDRCQUNMVCxjQUNBQyxnQkFDQUMsZ0JBQ0EsT0FDQUMsY0FDQUMsY0FDQUMsdUJBQ0FDLHNCQUNBRSxhQUNBRDtBQUVKO0FBRUEsU0FBU0UsNEJBQ1BULFlBQXVCLEVBQ3ZCQyxjQUFpQyxFQUNqQ0MsY0FBaUMsRUFDakNRLGlCQUEwQixFQUMxQlAsWUFBc0MsRUFDdENDLFlBQTZCLEVBQzdCQyxxQkFBOEIsRUFDOUJDLG9CQUE2QixFQUM3QkUsV0FBOEIsRUFDOUJELHdCQUFrRDtJQUVsRCwwREFBMEQ7SUFDMUQsTUFBTUkseUJBQXlCVixjQUFjLENBQUMsRUFBRTtJQUNoRCxNQUFNVyx5QkFBeUJWLGNBQWMsQ0FBQyxFQUFFO0lBQ2hELE1BQU1XLHVCQUF1QlYsaUJBQWlCLE9BQU9BLFlBQVksQ0FBQyxFQUFFLEdBQUc7SUFFdkUsSUFBSSxDQUFDTyxtQkFBbUI7UUFDdEIsd0VBQXdFO1FBQ3hFLDBFQUEwRTtRQUMxRSx5RUFBeUU7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QkFBb0I1SCxhQUFhcUQsV0FBVyxHQUFHO1FBQzVERSxTQUFTdkQsYUFBYXVELE9BQU87UUFFN0Isa0RBQWtEO1FBQ2xEdkMsZ0JBQWdCMkc7SUFDbEI7QUFDRjtBQUVBLE1BQU1HLFdBQVdDO0FBOEJqQiw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDhFQUE4RTtBQUM5RSxtRUFBbUU7QUFDbkUsU0FBU1IsY0FBY1MsS0FBVTtJQUMvQixPQUFPQSxTQUFTQSxNQUFNQyxHQUFHLEtBQUtIO0FBQ2hDO0FBRUEsU0FBU3ZCO0lBQ1AsSUFBSWlCO0lBQ0osSUFBSUU7SUFDSixNQUFNUSxhQUFhLElBQUlDLFFBQXlCLENBQUNDLEtBQUtDO1FBQ3BEYixVQUFVWTtRQUNWVixTQUFTVztJQUNYO0lBQ0FILFdBQVdMLE1BQU0sR0FBRztJQUNwQkssV0FBV1YsT0FBTyxHQUFHLENBQUNRO1FBQ3BCLElBQUlFLFdBQVdMLE1BQU0sS0FBSyxXQUFXO1lBQ25DLE1BQU1TLGVBQXFDSjtZQUMzQ0ksYUFBYVQsTUFBTSxHQUFHO1lBQ3RCUyxhQUFhTixLQUFLLEdBQUdBO1lBQ3JCUixRQUFRUTtRQUNWO0lBQ0Y7SUFDQUUsV0FBV1IsTUFBTSxHQUFHLENBQUNsQztRQUNuQixJQUFJMEMsV0FBV0wsTUFBTSxLQUFLLFdBQVc7WUFDbkMsTUFBTVUsY0FBbUNMO1lBQ3pDSyxZQUFZVixNQUFNLEdBQUc7WUFDckJVLFlBQVlDLE1BQU0sR0FBR2hEO1lBQ3JCa0MsT0FBT2xDO1FBQ1Q7SUFDRjtJQUNBMEMsV0FBV0QsR0FBRyxHQUFHSDtJQUNqQixPQUFPSTtBQUNUIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3Bwci1uYXZpZ2F0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIENhY2hlTm9kZVNlZWREYXRhLFxuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0U2VnbWVudFBhdGgsXG4gIFNlZ21lbnQsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUge1xuICBDYWNoZU5vZGUsXG4gIENoaWxkU2VnbWVudE1hcCxcbiAgSGVhZERhdGEsXG4gIFJlYWR5Q2FjaGVOb2RlLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IERFRkFVTFRfU0VHTUVOVF9LRVkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbGliL3NlZ21lbnQnXG5pbXBvcnQgeyBtYXRjaFNlZ21lbnQgfSBmcm9tICcuLi9tYXRjaC1zZWdtZW50cydcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi9jcmVhdGUtcm91dGVyLWNhY2hlLWtleSdcbmltcG9ydCB0eXBlIHsgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB9IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcblxuLy8gVGhpcyBpcyB5ZXQgYW5vdGhlciB0cmVlIHR5cGUgdGhhdCBpcyB1c2VkIHRvIHRyYWNrIHBlbmRpbmcgcHJvbWlzZXMgdGhhdFxuLy8gbmVlZCB0byBiZSBmdWxmaWxsZWQgb25jZSB0aGUgZHluYW1pYyBkYXRhIGlzIHJlY2VpdmVkLiBUaGUgdGVybWluYWwgbm9kZXMgb2Zcbi8vIHRoaXMgdHJlZSByZXByZXNlbnQgdGhlIG5ldyBDYWNoZSBOb2RlIHRyZWVzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyB0aGlzXG4vLyByZXF1ZXN0LiBXZSBjYW4ndCB1c2UgdGhlIENhY2hlIE5vZGUgdHJlZSBvciBSb3V0ZSBTdGF0ZSB0cmVlIGRpcmVjdGx5XG4vLyBiZWNhdXNlIHRob3NlIGluY2x1ZGUgcmV1c2VkIG5vZGVzLCB0b28uIFRoaXMgdHJlZSBpcyBkaXNjYXJkZWQgYXMgc29vbiBhc1xuLy8gdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UgaXMgcmVjZWl2ZWQuXG50eXBlIFNQQU5hdmlnYXRpb25UYXNrID0ge1xuICAvLyBUaGUgcm91dGVyIHN0YXRlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRyZWUgdGhhdCB0aGlzIFRhc2sgcmVwcmVzZW50cy5cbiAgcm91dGU6IEZsaWdodFJvdXRlclN0YXRlXG4gIC8vIFRoZSBDYWNoZU5vZGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgdHJlZSB0aGF0IHRoaXMgVGFzayByZXByZXNlbnRzLiBJZlxuICAvLyBgY2hpbGRyZW5gIGlzIG51bGwgKGkuZS4gaWYgdGhpcyBpcyBhIHRlcm1pbmFsIHRhc2sgbm9kZSksIHRoZW4gYG5vZGVgXG4gIC8vIHJlcHJlc2VudHMgYSBicmFuZCBuZXcgQ2FjaGUgTm9kZSB0cmVlLCB3aGljaCB3YXkgb3IgbWF5IG5vdCBuZWVkIHRvIGJlXG4gIC8vIGZpbGxlZCB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gIG5vZGU6IENhY2hlTm9kZSB8IG51bGxcbiAgLy8gVGhlIHRyZWUgc2VudCB0byB0aGUgc2VydmVyIGR1cmluZyB0aGUgZHluYW1pYyByZXF1ZXN0LiBUaGlzIGlzIHRoZVxuICAvLyBzYW1lIGFzIGByb3V0ZWAsIGV4Y2VwdCB3aXRoIHRoZSBgcmVmZXRjaGAgbWFya2VyIHNldCBvbiBkeW5hbWljIHNlZ21lbnRzLlxuICAvLyBJZiBhbGwgdGhlIHNlZ21lbnRzIGFyZSBzdGF0aWMsIHRoZW4gdGhpcyB3aWxsIGJlIG51bGwsIGFuZCBubyBzZXJ2ZXJcbiAgLy8gcmVxdWVzdCBpcyByZXF1aXJlZC5cbiAgZHluYW1pY1JlcXVlc3RUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IG51bGxcbiAgY2hpbGRyZW46IE1hcDxzdHJpbmcsIFNQQU5hdmlnYXRpb25UYXNrPiB8IG51bGxcbn1cblxuLy8gQSBzcGVjaWFsIHR5cGUgdXNlZCB0byBiYWlsIG91dCBhbmQgdHJpZ2dlciBhIGZ1bGwtcGFnZSBuYXZpZ2F0aW9uLlxudHlwZSBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgLy8gTVBBIHRhc2tzIGFyZSBkaXN0aW5ndWlzZWQgZnJvbSBTUEEgdGFza3MgYnkgaGF2aW5nIGEgbnVsbCBgcm91dGVgLlxuICByb3V0ZTogbnVsbFxuICBub2RlOiBudWxsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbFxuICBjaGlsZHJlbjogbnVsbFxufVxuXG5jb25zdCBNUEFfTkFWSUdBVElPTl9UQVNLOiBNUEFOYXZpZ2F0aW9uVGFzayA9IHtcbiAgcm91dGU6IG51bGwsXG4gIG5vZGU6IG51bGwsXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgY2hpbGRyZW46IG51bGwsXG59XG5cbmV4cG9ydCB0eXBlIFRhc2sgPSBTUEFOYXZpZ2F0aW9uVGFzayB8IE1QQU5hdmlnYXRpb25UYXNrXG5cbi8vIENyZWF0ZXMgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIChpLmUuIGNvcHktb24td3JpdGUpIHRoYXQgcmVwcmVzZW50cyB0aGVcbi8vIG9wdGltaXN0aWMgcmVzdWx0IG9mIGEgbmF2aWdhdGlvbiwgdXNpbmcgYm90aCB0aGUgY3VycmVudCBDYWNoZSBOb2RlIHRyZWUgYW5kXG4vLyBkYXRhIHRoYXQgd2FzIHByZWZldGNoZWQgcHJpb3IgdG8gbmF2aWdhdGlvbi5cbi8vXG4vLyBBdCB0aGUgbW9tZW50IHdlIGNhbGwgdGhpcyBmdW5jdGlvbiwgd2UgaGF2ZW4ndCB5ZXQgcmVjZWl2ZWQgdGhlIG5hdmlnYXRpb25cbi8vIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci4gSXQgY291bGQgc2VuZCBiYWNrIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudFxuLy8gZnJvbSB0aGUgdHJlZSB0aGF0IHdhcyBwcmVmZXRjaGVkIOKAlCBkdWUgdG8gcmV3cml0ZXMsIGRlZmF1bHQgcm91dGVzLCBwYXJhbGxlbFxuLy8gcm91dGVzLCBldGMuXG4vL1xuLy8gQnV0IGluIG1vc3QgY2FzZXMsIGl0IHdpbGwgcmV0dXJuIHRoZSBzYW1lIHRyZWUgdGhhdCB3ZSBwcmVmZXRjaGVkLCBqdXN0IHdpdGhcbi8vIHRoZSBkeW5hbWljIGhvbGVzIGZpbGxlZCBpbi4gU28gd2Ugb3B0aW1pc3RpY2FsbHkgYXNzdW1lIHRoaXMgd2lsbCBoYXBwZW4sXG4vLyBhbmQgYWNjZXB0IHRoYXQgdGhlIHJlYWwgcmVzdWx0IGNvdWxkIGJlIGFyYml0cmFyaWx5IGRpZmZlcmVudC5cbi8vXG4vLyBXZSdsbCByZXVzZSBhbnl0aGluZyB0aGF0IHdhcyBhbHJlYWR5IGluIHRoZSBwcmV2aW91cyB0cmVlLCBzaW5jZSB0aGF0J3Mgd2hhdFxuLy8gdGhlIHNlcnZlciBkb2VzLlxuLy9cbi8vIE5ldyBzZWdtZW50cyAob25lcyB0aGF0IGRvbid0IGFwcGVhciBpbiB0aGUgb2xkIHRyZWUpIGFyZSBhc3NpZ25lZCBhblxuLy8gdW5yZXNvbHZlZCBwcm9taXNlLiBUaGUgZGF0YSBmb3IgdGhlc2UgcHJvbWlzZXMgd2lsbCBiZSBmdWxmaWxsZWQgbGF0ZXIsIHdoZW5cbi8vIHRoZSBuYXZpZ2F0aW9uIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuLy9cbi8vIFRoZSB0cmVlIGNhbiBiZSByZW5kZXJlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyBjcmVhdGVkICh0aGF0J3Mgd2h5IHRoaXMgaXNcbi8vIGEgc3luY2hyb25vdXMgZnVuY3Rpb24pLiBBbnkgbmV3IHRyZWVzIHRoYXQgZG8gbm90IGhhdmUgcHJlZmV0Y2ggZGF0YSB3aWxsXG4vLyBzdXNwZW5kIGR1cmluZyByZW5kZXJpbmcsIHVudGlsIHRoZSBkeW5hbWljIGRhdGEgc3RyZWFtcyBpbi5cbi8vXG4vLyBSZXR1cm5zIGEgVGFzayBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGJvdGggdGhlIHVwZGF0ZWQgQ2FjaGUgTm9kZSBhbmQgYSBwYXRoXG4vLyB0byB0aGUgcGVuZGluZyBzdWJ0cmVlcyB0aGF0IG5lZWQgdG8gYmUgcmVzb2x2ZWQgYnkgdGhlIG5hdmlnYXRpb24gcmVzcG9uc2UuXG4vL1xuLy8gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRoZXJlIHdlcmUgbm8gY2hhbmdlcywgYW5kIHRoZSBwcmV2aW91cyB0cmVlXG4vLyBjYW4gYmUgcmV1c2VkIHdpdGhvdXQgaW5pdGlhdGluZyBhIHNlcnZlciByZXF1ZXN0LlxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0UFBSTmF2aWdhdGlvbihcbiAgb2xkQ2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgbmV3Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgaXNTYW1lUGFnZU5hdmlnYXRpb246IGJvb2xlYW4sXG4gIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+XG4pOiBUYXNrIHwgbnVsbCB7XG4gIGNvbnN0IHNlZ21lbnRQYXRoOiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD4gPSBbXVxuICByZXR1cm4gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgIG9sZENhY2hlTm9kZSxcbiAgICBvbGRSb3V0ZXJTdGF0ZSxcbiAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICBmYWxzZSxcbiAgICBwcmVmZXRjaERhdGEsXG4gICAgcHJlZmV0Y2hIZWFkLFxuICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICBpc1NhbWVQYWdlTmF2aWdhdGlvbixcbiAgICBzZWdtZW50UGF0aCxcbiAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gIG9sZENhY2hlTm9kZTogQ2FjaGVOb2RlLFxuICBvbGRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZGlkRmluZFJvb3RMYXlvdXQ6IGJvb2xlYW4sXG4gIHByZWZldGNoRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBwcmVmZXRjaEhlYWQ6IEhlYWREYXRhIHwgbnVsbCxcbiAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsOiBib29sZWFuLFxuICBpc1NhbWVQYWdlTmF2aWdhdGlvbjogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogVGFzayB8IG51bGwge1xuICAvLyBEaWZmIHRoZSBvbGQgYW5kIG5ldyB0cmVlcyB0byByZXVzZSB0aGUgc2hhcmVkIGxheW91dHMuXG4gIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGRyZW4gPSBvbGRSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuID0gbmV3Um91dGVyU3RhdGVbMV1cbiAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMl0gOiBudWxsXG5cbiAgaWYgKCFkaWRGaW5kUm9vdExheW91dCkge1xuICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB0cmF2ZXJzaW5nIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgd2FzIGFsc28gcGFydCBvZlxuICAgIC8vIHRoZSBwcmV2aW91cyByb3V0ZS4gSWYgd2UgZGlzY292ZXIgYSByb290IGxheW91dCwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gdHJpZ2dlciBhbiBNUEEgbmF2aWdhdGlvbi4gU2VlIGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlIGZvciBjb250ZXh0LlxuICAgIGNvbnN0IGlzUm9vdExheW91dCA9IG5ld1JvdXRlclN0YXRlWzRdID09PSB0cnVlXG4gICAgaWYgKGlzUm9vdExheW91dCkge1xuICAgICAgLy8gRm91bmQgYSBtYXRjaGluZyByb290IGxheW91dC5cbiAgICAgIGRpZEZpbmRSb290TGF5b3V0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9sZFBhcmFsbGVsUm91dGVzID0gb2xkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG5cbiAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgc2V0IG9mIHNlZ21lbnQgY2hpbGRyZW4sIGV2ZW4gaWYgdGhleSBhcmVuJ3QgYWN0aXZlIGluXG4gIC8vIHRoZSBuZXcgdHJlZS5cbiAgLy8gVE9ETzogV2UgY3VycmVudGx5IHJldGFpbiBhbGwgdGhlIGluYWN0aXZlIHNlZ21lbnRzIGluZGVmaW5pdGVseSwgdW50aWxcbiAgLy8gdGhlcmUncyBhbiBleHBsaWNpdCByZWZyZXNoLCBvciBhIHBhcmVudCBsYXlvdXQgaXMgbGF6aWx5IHJlZnJlc2hlZC4gV2VcbiAgLy8gcmVseSBvbiB0aGlzIGZvciBwb3BzdGF0ZSBuYXZpZ2F0aW9ucywgd2hpY2ggdXBkYXRlIHRoZSBSb3V0ZXIgU3RhdGUgVHJlZVxuICAvLyBidXQgZG8gbm90IGVhZ2VybHkgcGVyZm9ybSBhIGRhdGEgZmV0Y2gsIGJlY2F1c2UgdGhleSBleHBlY3QgdGhlIHNlZ21lbnRcbiAgLy8gZGF0YSB0byBhbHJlYWR5IGJlIGluIHRoZSBDYWNoZSBOb2RlIHRyZWUuIEZvciBoaWdobHkgc3RhdGljIHNpdGVzIHRoYXRcbiAgLy8gYXJlIG1vc3RseSByZWFkLW9ubHksIHRoaXMgbWF5IGhhcHBlbiBvbmx5IHJhcmVseSwgY2F1c2luZyBtZW1vcnkgdG9cbiAgLy8gbGVhay4gV2Ugc2hvdWxkIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgbW9kZWwgZm9yIHRoZSBsaWZldGltZSBvZiBpbmFjdGl2ZVxuICAvLyBzZWdtZW50cywgc28gd2UgY2FuIG1haW50YWluIGluc3RhbnQgYmFjay9mb3J3YXJkIG5hdmlnYXRpb25zIHdpdGhvdXRcbiAgLy8gbGVha2luZyBtZW1vcnkgaW5kZWZpbml0ZWx5LlxuICBjb25zdCBwcmVmZXRjaFBhcmFsbGVsUm91dGVzID0gbmV3IE1hcChvbGRQYXJhbGxlbFJvdXRlcylcblxuICAvLyBBcyB3ZSBkaWZmIHRoZSB0cmVlcywgd2UgbWF5IHNvbWV0aW1lcyBtb2RpZnkgKGNvcHktb24td3JpdGUsIG5vdCBtdXRhdGUpXG4gIC8vIHRoZSBSb3V0ZSBUcmVlIHRoYXQgd2FzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIg4oCUIGZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAvLyBvZiBkZWZhdWx0IHBhcmFsbGVsIHJvdXRlcywgd2UgcHJlc2VydmUgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2VnbWVudC4gVG9cbiAgLy8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIHRyZWUsIHdlIGNsb25lIHRoZSByb3V0ZXIgc3RhdGUgY2hpbGRyZW4gYWxvbmdcbiAgLy8gdGhlIHJldHVybiBwYXRoLlxuICBsZXQgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG4gIGxldCB0YXNrQ2hpbGRyZW4gPSBudWxsXG5cbiAgLy8gTW9zdCBuYXZpZ2F0aW9ucyByZXF1aXJlIGEgcmVxdWVzdCB0byBmZXRjaCBhZGRpdGlvbmFsIGRhdGEgZnJvbSB0aGVcbiAgLy8gc2VydmVyLCBlaXRoZXIgYmVjYXVzZSB0aGUgZGF0YSB3YXMgbm90IGFscmVhZHkgcHJlZmV0Y2hlZCwgb3IgYmVjYXVzZSB0aGVcbiAgLy8gdGFyZ2V0IHJvdXRlIGNvbnRhaW5zIGR5bmFtaWMgZGF0YSB0aGF0IGNhbm5vdCBiZSBwcmVmZXRjaGVkLlxuICAvL1xuICAvLyBIb3dldmVyLCBpZiB0aGUgdGFyZ2V0IHJvdXRlIGlzIGZ1bGx5IHN0YXRpYywgYW5kIGl0J3MgYWxyZWFkeSBjb21wbGV0ZWx5XG4gIC8vIGxvYWRlZCBpbnRvIHRoZSBzZWdtZW50IGNhY2hlLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBzZXJ2ZXIgcmVxdWVzdC5cbiAgLy9cbiAgLy8gVGhpcyBzdGFydHMgb2ZmIGFzIGBmYWxzZWAsIGFuZCBpcyBzZXQgdG8gYHRydWVgIGlmIGFueSBvZiB0aGUgY2hpbGRcbiAgLy8gcm91dGVzIHJlcXVpcmVzIGEgZHluYW1pYyByZXF1ZXN0LlxuICBsZXQgbmVlZHNEeW5hbWljUmVxdWVzdCA9IGZhbHNlXG4gIC8vIEFzIHdlIHRyYXZlcnNlIHRoZSBjaGlsZHJlbiwgd2UnbGwgY29uc3RydWN0IGEgRmxpZ2h0Um91dGVyU3RhdGUgdGhhdCBjYW5cbiAgLy8gYmUgc2VudCB0byB0aGUgc2VydmVyIHRvIHJlcXVlc3QgdGhlIGR5bmFtaWMgZGF0YS4gSWYgaXQgdHVybnMgb3V0IHRoYXRcbiAgLy8gbm90aGluZyBpbiB0aGUgc3VidHJlZSBpcyBkeW5hbWljIChpLmUuIG5lZWRzRHluYW1pY1JlcXVlc3QgaXMgZmFsc2UgYXQgdGhlXG4gIC8vIGVuZCksIHRoZW4gdGhpcyB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IG9wdGltaXplIHRoZSBmb3JtYXQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSB0byBvbmx5XG4gIC8vIGluY2x1ZGUgcGF0aHMgdGhhdCBhcmUgZHluYW1pYy4gSW5zdGVhZCBvZiByZXVzaW5nIHRoZVxuICAvLyBGbGlnaHRSb3V0ZXJTdGF0ZSB0eXBlLlxuICBsZXQgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW46IHtcbiAgICBbcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nXTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgfSA9IHt9XG5cbiAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiBuZXdSb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgbmV3Um91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IG9sZFJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlIHwgdm9pZCA9XG4gICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3Qgb2xkU2VnbWVudE1hcENoaWxkID0gb2xkUGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgY29uc3QgcHJlZmV0Y2hEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgdm9pZCB8IG51bGwgPVxuICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGRyZW4gIT09IG51bGxcbiAgICAgICAgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICA6IG51bGxcblxuICAgIGNvbnN0IG5ld1NlZ21lbnRDaGlsZCA9IG5ld1JvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCBuZXdTZWdtZW50UGF0aENoaWxkID0gc2VnbWVudFBhdGguY29uY2F0KFtcbiAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICBuZXdTZWdtZW50Q2hpbGQsXG4gICAgXSlcbiAgICBjb25zdCBuZXdTZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShuZXdTZWdtZW50Q2hpbGQpXG5cbiAgICBjb25zdCBvbGRTZWdtZW50Q2hpbGQgPVxuICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkID8gb2xkUm91dGVyU3RhdGVDaGlsZFswXSA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3Qgb2xkQ2FjaGVOb2RlQ2hpbGQgPVxuICAgICAgb2xkU2VnbWVudE1hcENoaWxkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBvbGRTZWdtZW50TWFwQ2hpbGQuZ2V0KG5ld1NlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIGxldCB0YXNrQ2hpbGQ6IFRhc2sgfCBudWxsXG4gICAgaWYgKG5ld1NlZ21lbnRDaGlsZCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSkge1xuICAgICAgLy8gVGhpcyBpcyBhbm90aGVyIGtpbmQgb2YgbGVhZiBzZWdtZW50IOKAlCBhIGRlZmF1bHQgcm91dGUuXG4gICAgICAvL1xuICAgICAgLy8gRGVmYXVsdCByb3V0ZXMgaGF2ZSBzcGVjaWFsIGJlaGF2aW9yLiBXaGVuIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgc2VnbWVudFxuICAgICAgLy8gZm9yIGEgcGFyYWxsZWwgcm91dGUsIE5leHQuanMgcHJlc2VydmVzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnRcbiAgICAgIC8vIGR1cmluZyBhIGNsaWVudCBuYXZpZ2F0aW9uIOKAlCBidXQgbm90IGZvciBpbml0aWFsIHJlbmRlci4gVGhlIHNlcnZlclxuICAgICAgLy8gbGVhdmVzIGl0IHRvIHRoZSBjbGllbnQgdG8gYWNjb3VudCBmb3IgdGhpcy4gU28gd2UgbmVlZCB0byBoYW5kbGVcbiAgICAgIC8vIGl0IGhlcmUuXG4gICAgICBpZiAob2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFJldXNlIHRoZSBleGlzdGluZyBSb3V0ZXIgU3RhdGUgZm9yIHRoaXMgc2VnbWVudC4gV2Ugc3Bhd24gYSBcInRhc2tcIlxuICAgICAgICAvLyBqdXN0IHRvIGtlZXAgdHJhY2sgb2YgdGhlIHVwZGF0ZWQgcm91dGVyIHN0YXRlOyB1bmxpa2UgbW9zdCwgaXQnc1xuICAgICAgICAvLyBhbHJlYWR5IGZ1bGZpbGxlZCBhbmQgd29uJ3QgYmUgYWZmZWN0ZWQgYnkgdGhlIGR5bmFtaWMgcmVzcG9uc2UuXG4gICAgICAgIHRhc2tDaGlsZCA9IHNwYXduUmV1c2VkVGFzayhvbGRSb3V0ZXJTdGF0ZUNoaWxkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBjdXJyZW50bHkgYWN0aXZlIHNlZ21lbnQuIFN3aXRjaCB0byB0aGUgXCJjcmVhdGVcIiBwYXRoLlxuICAgICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIG5ld1JvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaXNTYW1lUGFnZU5hdmlnYXRpb24gJiZcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwYWdlIHNlZ21lbnQuXG4gICAgICAvLyBUT0RPOiBXZSdyZSBub3QgY29uc2lzdGVudCBhYm91dCBob3cgd2UgZG8gdGhpcyBjaGVjay4gU29tZSBwbGFjZXNcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWdtZW50IHN0YXJ0cyB3aXRoIFBBR0VfU0VHTUVOVF9LRVksIGJ1dCBtb3N0IHNlZW0gdG9cbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFueSBhbnkgY2hpbGRyZW4sIHdoaWNoIGlzIHdoeSBJJ20gZG9pbmcgaXQgaGVyZS4gV2VcbiAgICAgIC8vIHNob3VsZCBwcm9iYWJseSBlbmNvZGUgYW4gZW1wdHkgY2hpbGRyZW4gc2V0IGFzIGBudWxsYCB0aG91Z2guIEVpdGhlclxuICAgICAgLy8gd2F5LCB3ZSBzaG91bGQgdXBkYXRlIGFsbCB0aGUgY2hlY2tzIHRvIGJlIGNvbnNpc3RlbnQuXG4gICAgICBPYmplY3Qua2V5cyhuZXdSb3V0ZXJTdGF0ZUNoaWxkWzFdKS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBuYXZpZ2F0aW9ucyB0byB0aGUgZXhhY3Qgc2FtZSBVUkwgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGxvY2F0aW9uLiBJdCdzIGEgY29tbW9uIFVJIHBhdHRlcm4gZm9yIGFwcHMgdG8gcmVmcmVzaCB3aGVuIHlvdSBjbGljayBhXG4gICAgICAvLyBsaW5rIHRvIHRoZSBjdXJyZW50IHBhZ2UuIFNvIHdoZW4gdGhpcyBoYXBwZW5zLCB3ZSByZWZyZXNoIHRoZSBkeW5hbWljXG4gICAgICAvLyBkYXRhIGluIHRoZSBwYWdlIHNlZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFwcGx5IGlmIHRoZSBhbnkgcGFydCBvZiB0aGUgaGFzaCBvciBzZWFyY2hcbiAgICAgIC8vIHF1ZXJ5IGhhcyBjaGFuZ2VkLiBUaGlzIG1pZ2h0IGZlZWwgYSBiaXQgd2VpcmQgYnV0IGl0IG1ha2VzIG1vcmUgc2Vuc2VcbiAgICAgIC8vIHdoZW4geW91IGNvbnNpZGVyIHRoYXQgdGhlIHdheSB0byB0cmlnZ2VyIHRoaXMgYmVoYXZpb3IgaXMgdG8gY2xpY2tcbiAgICAgIC8vIHRoZSBzYW1lIGxpbmsgbXVsdGlwbGUgdGltZXMuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IHJlZnJlc2ggdGhlICplbnRpcmUqIHJvdXRlIHdoZW4gdGhpcyBjYXNlXG4gICAgICAvLyBvY2N1cnMsIG5vdCBqdXN0IHRoZSBwYWdlIHNlZ21lbnRzLiBFc3NlbnRpYWxseSB0cmVhdGluZyBpdCB0aGUgc2FtZSBhc1xuICAgICAgLy8gYSByZWZyZXNoKCkgdHJpZ2dlcmVkIGJ5IGFuIGFjdGlvbiwgd2hpY2ggaXMgdGhlIG1vcmUgZXhwbGljaXQgd2F5IG9mXG4gICAgICAvLyBtb2RlbGluZyB0aGUgVUkgcGF0dGVybiBkZXNjcmliZWQgYWJvdmUuXG4gICAgICAvL1xuICAgICAgLy8gQWxzbyBub3RlIHRoYXQgdGhpcyBvbmx5IHJlZnJlc2hlcyB0aGUgZHluYW1pYyBkYXRhLCBub3Qgc3RhdGljL1xuICAgICAgLy8gY2FjaGVkIGRhdGEuIElmIHRoZSBwYWdlIHNlZ21lbnQgaXMgZnVsbHkgc3RhdGljIGFuZCBwcmVmZXRjaGVkLCB0aGVcbiAgICAgIC8vIHJlcXVlc3QgaXMgc2tpcHBlZC4gKFRoaXMgaXMgYWxzbyBob3cgcmVmcmVzaCgpIHdvcmtzLilcbiAgICAgIHRhc2tDaGlsZCA9IGJlZ2luUmVuZGVyaW5nTmV3Um91dGVUcmVlKFxuICAgICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICBuZXdSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICBkaWRGaW5kUm9vdExheW91dCxcbiAgICAgICAgcHJlZmV0Y2hEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZCA/IHByZWZldGNoRGF0YUNoaWxkIDogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgICBpc1ByZWZldGNoSGVhZFBhcnRpYWwsXG4gICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBvbGRSb3V0ZXJTdGF0ZUNoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG9sZFNlZ21lbnRDaGlsZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBtYXRjaFNlZ21lbnQobmV3U2VnbWVudENoaWxkLCBvbGRTZWdtZW50Q2hpbGQpXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG9sZENhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhpcyBzZWdtZW50IGV4aXN0cyBpbiBib3RoIHRoZSBvbGQgYW5kIG5ldyB0cmVlcy4gUmVjdXJzaXZlbHkgdXBkYXRlXG4gICAgICAgIC8vIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgdGFza0NoaWxkID0gdXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uKFxuICAgICAgICAgIG9sZENhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgIG9sZFJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBkaWRGaW5kUm9vdExheW91dCxcbiAgICAgICAgICBwcmVmZXRjaERhdGFDaGlsZCxcbiAgICAgICAgICBwcmVmZXRjaEhlYWQsXG4gICAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICAgIGlzU2FtZVBhZ2VOYXZpZ2F0aW9uLFxuICAgICAgICAgIG5ld1NlZ21lbnRQYXRoQ2hpbGQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gZXhpc3RpbmcgQ2FjaGUgTm9kZSBmb3IgdGhpcyBzZWdtZW50LiBTd2l0Y2ggdG8gdGhlXG4gICAgICAgIC8vIFwiY3JlYXRlXCIgcGF0aC5cbiAgICAgICAgdGFza0NoaWxkID0gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUoXG4gICAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBuZXdSb3V0ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgIGRpZEZpbmRSb290TGF5b3V0LFxuICAgICAgICAgIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsXG4gICAgICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgICBuZXdTZWdtZW50UGF0aENoaWxkLFxuICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBuZXcgdHJlZS4gU3dpdGNoIHRvIHRoZSBcImNyZWF0ZVwiIHBhdGguXG4gICAgICB0YXNrQ2hpbGQgPSBiZWdpblJlbmRlcmluZ05ld1JvdXRlVHJlZShcbiAgICAgICAgb2xkUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgbmV3Um91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgZGlkRmluZFJvb3RMYXlvdXQsXG4gICAgICAgIHByZWZldGNoRGF0YUNoaWxkICE9PSB1bmRlZmluZWQgPyBwcmVmZXRjaERhdGFDaGlsZCA6IG51bGwsXG4gICAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgICBuZXdTZWdtZW50UGF0aENoaWxkLFxuICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGFza0NoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBSZWN1cnNpdmVseSBwcm9wYWdhdGUgdXAgdGhlIGNoaWxkIHRhc2tzLlxuXG4gICAgICBpZiAodGFza0NoaWxkLnJvdXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIE9uZSBvZiB0aGUgY2hpbGQgdGFza3MgZGlzY292ZXJlZCBhIGNoYW5nZSB0byB0aGUgcm9vdCBsYXlvdXQuXG4gICAgICAgIC8vIEltbWVkaWF0ZWx5IHVud2luZCBmcm9tIHRoaXMgcmVjdXJzaXZlIHRyYXZlcnNhbC5cbiAgICAgICAgcmV0dXJuIE1QQV9OQVZJR0FUSU9OX1RBU0tcbiAgICAgIH1cblxuICAgICAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICB0YXNrQ2hpbGRyZW4gPSBuZXcgTWFwKClcbiAgICAgIH1cbiAgICAgIHRhc2tDaGlsZHJlbi5zZXQocGFyYWxsZWxSb3V0ZUtleSwgdGFza0NoaWxkKVxuICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB0YXNrQ2hpbGQubm9kZVxuICAgICAgaWYgKG5ld0NhY2hlTm9kZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZDogQ2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChvbGRTZWdtZW50TWFwQ2hpbGQpXG4gICAgICAgIG5ld1NlZ21lbnRNYXBDaGlsZC5zZXQobmV3U2VnbWVudEtleUNoaWxkLCBuZXdDYWNoZU5vZGVDaGlsZClcbiAgICAgICAgcHJlZmV0Y2hQYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgbmV3U2VnbWVudE1hcENoaWxkKVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY2hpbGQgdHJlZSdzIHJvdXRlIHN0YXRlIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcHJlZmV0Y2hlZFxuICAgICAgLy8gcm91dGUgc2VudCBieSB0aGUgc2VydmVyLiBXZSBuZWVkIHRvIGNsb25lIGl0IGFzIHdlIHRyYXZlcnNlIGJhY2sgdXBcbiAgICAgIC8vIHRoZSB0cmVlLlxuICAgICAgY29uc3QgdGFza0NoaWxkUm91dGUgPSB0YXNrQ2hpbGQucm91dGVcbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gdGFza0NoaWxkUm91dGVcblxuICAgICAgY29uc3QgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQgPSB0YXNrQ2hpbGQuZHluYW1pY1JlcXVlc3RUcmVlXG4gICAgICBpZiAoZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSBjaGlsZCB0cmVlIGlzIGR5bmFtaWMuXG4gICAgICAgIG5lZWRzRHluYW1pY1JlcXVlc3QgPSB0cnVlXG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldID0gdGFza0NoaWxkUm91dGVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGNoaWxkIGRpZG4ndCBjaGFuZ2UuIFdlIGNhbiB1c2UgdGhlIHByZWZldGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgcGF0Y2hlZFJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV0gPSBuZXdSb3V0ZXJTdGF0ZUNoaWxkXG4gICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IG5ld1JvdXRlclN0YXRlQ2hpbGRcbiAgICB9XG4gIH1cblxuICBpZiAodGFza0NoaWxkcmVuID09PSBudWxsKSB7XG4gICAgLy8gTm8gbmV3IHRhc2tzIHdlcmUgc3Bhd25lZC5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgbmV3Q2FjaGVOb2RlOiBSZWFkeUNhY2hlTm9kZSA9IHtcbiAgICBsYXp5RGF0YTogbnVsbCxcbiAgICByc2M6IG9sZENhY2hlTm9kZS5yc2MsXG4gICAgLy8gV2UgaW50ZW50aW9uYWxseSBhcmVuJ3QgdXBkYXRpbmcgdGhlIHByZWZldGNoUnNjIGZpZWxkLCBzaW5jZSB0aGlzIG5vZGVcbiAgICAvLyBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIGN1cnJlbnQgdHJlZSwgYmVjYXVzZSBpdCB3b3VsZCBiZSB3ZWlyZCBmb3JcbiAgICAvLyBwcmVmZXRjaCBkYXRhIHRvIGJlIG5ld2VyIHRoYW4gdGhlIGZpbmFsIGRhdGEuIEl0IHByb2JhYmx5IHdvbid0IGV2ZXIgYmVcbiAgICAvLyBvYnNlcnZhYmxlIGFueXdheSwgYnV0IGl0IGNvdWxkIGhhcHBlbiBpZiB0aGUgc2VnbWVudCBpcyB1bm1vdW50ZWQgdGhlblxuICAgIC8vIG1vdW50ZWQgYWdhaW4sIGJlY2F1c2UgTGF5b3V0Um91dGVyIHdpbGwgbW9tZW50YXJpbHkgc3dpdGNoIHRvIHJlbmRlcmluZ1xuICAgIC8vIHByZWZldGNoUnNjLCB2aWEgdXNlRGVmZXJyZWRWYWx1ZS5cbiAgICBwcmVmZXRjaFJzYzogb2xkQ2FjaGVOb2RlLnByZWZldGNoUnNjLFxuICAgIGhlYWQ6IG9sZENhY2hlTm9kZS5oZWFkLFxuICAgIHByZWZldGNoSGVhZDogb2xkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCxcbiAgICBsb2FkaW5nOiBvbGRDYWNoZU5vZGUubG9hZGluZyxcblxuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgY2xvbmVkIGV4Y2VwdCBmb3IgdGhlIGNoaWxkcmVuLCB3aGljaCB3ZSBjb21wdXRlZCBhYm92ZS5cbiAgICBwYXJhbGxlbFJvdXRlczogcHJlZmV0Y2hQYXJhbGxlbFJvdXRlcyxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gUmV0dXJuIGEgY2xvbmVkIGNvcHkgb2YgdGhlIHJvdXRlciBzdGF0ZSB3aXRoIHVwZGF0ZWQgY2hpbGRyZW4uXG4gICAgcm91dGU6IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICAgIHBhdGNoZWRSb3V0ZXJTdGF0ZUNoaWxkcmVuXG4gICAgKSxcbiAgICBub2RlOiBuZXdDYWNoZU5vZGUsXG4gICAgZHluYW1pY1JlcXVlc3RUcmVlOiBuZWVkc0R5bmFtaWNSZXF1ZXN0XG4gICAgICA/IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4oXG4gICAgICAgICAgbmV3Um91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY1JlcXVlc3RUcmVlQ2hpbGRyZW5cbiAgICAgICAgKVxuICAgICAgOiBudWxsLFxuICAgIGNoaWxkcmVuOiB0YXNrQ2hpbGRyZW4sXG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUoXG4gIG9sZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSB8IHZvaWQsXG4gIG5ld1JvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZGlkRmluZFJvb3RMYXlvdXQ6IGJvb2xlYW4sXG4gIHByZWZldGNoRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsLFxuICBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQ6IEhlYWREYXRhIHwgbnVsbCxcbiAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsOiBib29sZWFuLFxuICBzZWdtZW50UGF0aDogRmxpZ2h0U2VnbWVudFBhdGgsXG4gIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdDogQXJyYXk8RmxpZ2h0U2VnbWVudFBhdGg+XG4pOiBUYXNrIHtcbiAgaWYgKCFkaWRGaW5kUm9vdExheW91dCkge1xuICAgIC8vIFRoZSByb3V0ZSB0cmVlIGNoYW5nZWQgYmVmb3JlIHdlIHJlYWNoZWQgYSBsYXlvdXQuIChUaGUgaGlnaGVzdC1sZXZlbFxuICAgIC8vIGxheW91dCBpbiBhIHJvdXRlIHRyZWUgaXMgcmVmZXJyZWQgdG8gYXMgdGhlIFwicm9vdFwiIGxheW91dC4pIFRoaXMgY291bGRcbiAgICAvLyBtZWFuIHRoYXQgd2UncmUgbmF2aWdhdGluZyBiZXR3ZWVuIHR3byBkaWZmZXJlbnQgcm9vdCBsYXlvdXRzLiBXaGVuIHRoaXNcbiAgICAvLyBoYXBwZW5zLCB3ZSBwZXJmb3JtIGEgZnVsbC1wYWdlIChNUEEtc3R5bGUpIG5hdmlnYXRpb24uXG4gICAgLy9cbiAgICAvLyBIb3dldmVyLCB0aGUgYWxnb3JpdGhtIGZvciBkZWNpZGluZyB3aGVyZSB0byBzdGFydCByZW5kZXJpbmcgYSByb3V0ZVxuICAgIC8vIChpLmUuIHRoZSBvbmUgcGVyZm9ybWVkIGluIG9yZGVyIHRvIHJlYWNoIHRoaXMgZnVuY3Rpb24pIGlzIHN0cmljdGVyXG4gICAgLy8gdGhhbiB0aGUgb25lIHVzZWQgdG8gZGV0ZWN0IGEgY2hhbmdlIGluIHRoZSByb290IGxheW91dC4gU28ganVzdCBiZWNhdXNlXG4gICAgLy8gd2UncmUgcmUtcmVuZGVyaW5nIGEgc2VnbWVudCBvdXRzaWRlIG9mIHRoZSByb290IGxheW91dCBkb2VzIG5vdCBtZWFuIHdlXG4gICAgLy8gc2hvdWxkIHRyaWdnZXIgYSBmdWxsLXBhZ2UgbmF2aWdhdGlvbi5cbiAgICAvL1xuICAgIC8vIFNwZWNpZmljYWxseSwgd2UgaGFuZGxlIGR5bmFtaWMgcGFyYW1ldGVycyBkaWZmZXJlbnRseTogdHdvIHNlZ21lbnRzIGFyZVxuICAgIC8vIGNvbnNpZGVyZWQgdGhlIHNhbWUgZXZlbiBpZiB0aGVpciBwYXJhbWV0ZXIgdmFsdWVzIGFyZSBkaWZmZXJlbnQuXG4gICAgLy9cbiAgICAvLyBSZWZlciB0byBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgZm9yIGRldGFpbHMuXG4gICAgLy9cbiAgICAvLyBOb3RlIHRoYXQgd2Ugb25seSBoYXZlIHRvIHBlcmZvcm0gdGhpcyBleHRyYSB0cmF2ZXJzYWwgaWYgd2UgZGlkbid0XG4gICAgLy8gYWxyZWFkeSBkaXNjb3ZlciBhIHJvb3QgbGF5b3V0IGluIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIHRoYXQgaXMgdW5jaGFuZ2VkLlxuICAgIC8vIEluIHRoZSBjb21tb24gY2FzZSwgdGhpcyBicmFuY2ggaXMgc2tpcHBlZCBjb21wbGV0ZWx5LlxuICAgIGlmIChcbiAgICAgIG9sZFJvdXRlclN0YXRlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChvbGRSb3V0ZXJTdGF0ZSwgbmV3Um91dGVyU3RhdGUpXG4gICAgKSB7XG4gICAgICAvLyBUaGUgcm9vdCBsYXlvdXQgY2hhbmdlZC4gUGVyZm9ybSBhIGZ1bGwtcGFnZSBuYXZpZ2F0aW9uLlxuICAgICAgcmV0dXJuIE1QQV9OQVZJR0FUSU9OX1RBU0tcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbihcbiAgICBuZXdSb3V0ZXJTdGF0ZSxcbiAgICBwcmVmZXRjaERhdGEsXG4gICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICBzZWdtZW50UGF0aCxcbiAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFNQQU5hdmlnYXRpb25UYXNrIHtcbiAgLy8gU2FtZSB0cmF2ZXJzYWwgYXMgdXBkYXRlQ2FjaGVOb2RlTmF2aWdhdGlvbiwgYnV0IHdlIHN3aXRjaCB0byB0aGlzIHBhdGhcbiAgLy8gb25jZSB3ZSByZWFjaCB0aGUgcGFydCBvZiB0aGUgdHJlZSB0aGF0IHdhcyBub3QgaW4gdGhlIHByZXZpb3VzIHJvdXRlLiBXZVxuICAvLyBkb24ndCBuZWVkIHRvIGRpZmYgYWdhaW5zdCB0aGUgb2xkIHRyZWUsIHdlIGp1c3QgbmVlZCB0byBjcmVhdGUgYSBuZXcgb25lLlxuICBpZiAocHJlZmV0Y2hEYXRhID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyBwcmVmZXRjaCBmb3IgdGhpcyBzZWdtZW50LiBFdmVyeXRoaW5nIGZyb20gdGhpcyBwb2ludCB3aWxsIGJlXG4gICAgLy8gcmVxdWVzdGVkIGZyb20gdGhlIHNlcnZlciwgZXZlbiBpZiB0aGVyZSBhcmUgc3RhdGljIGNoaWxkcmVuIGJlbG93IGl0LlxuICAgIC8vIENyZWF0ZSBhIHRlcm1pbmFsIHRhc2sgbm9kZSB0aGF0IHdpbGwgbGF0ZXIgYmUgZnVsZmlsbGVkIGJ5XG4gICAgLy8gc2VydmVyIHJlc3BvbnNlLlxuICAgIHJldHVybiBzcGF3blBlbmRpbmdUYXNrKFxuICAgICAgcm91dGVyU3RhdGUsXG4gICAgICBudWxsLFxuICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgc2VnbWVudFBhdGgsXG4gICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICApXG4gIH1cblxuICBjb25zdCByb3V0ZXJTdGF0ZUNoaWxkcmVuID0gcm91dGVyU3RhdGVbMV1cbiAgY29uc3QgaXNQcmVmZXRjaFJzY1BhcnRpYWwgPSBwcmVmZXRjaERhdGFbNF1cblxuICAvLyBUaGUgaGVhZCBpcyBhc3NpZ25lZCB0byBldmVyeSBsZWFmIHNlZ21lbnQgZGVsaXZlcmVkIGJ5IHRoZSBzZXJ2ZXIuIEJhc2VkXG4gIC8vIG9uIGNvcnJlc3BvbmRpbmcgbG9naWMgaW4gZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQudHNcbiAgY29uc3QgaXNMZWFmU2VnbWVudCA9IE9iamVjdC5rZXlzKHJvdXRlclN0YXRlQ2hpbGRyZW4pLmxlbmd0aCA9PT0gMFxuXG4gIC8vIElmIHByZWZldGNoIGRhdGEgaXMgYXZhaWxhYmxlIGZvciBhIHNlZ21lbnQsIGFuZCBpdCdzIGZ1bGx5IHN0YXRpYyAoaS5lLlxuICAvLyBkb2VzIG5vdCBjb250YWluIGFueSBkeW5hbWljIGhvbGVzKSwgd2UgZG9uJ3QgbmVlZCB0byByZXF1ZXN0IGl0IGZyb21cbiAgLy8gdGhlIHNlcnZlci5cbiAgaWYgKFxuICAgIC8vIENoZWNrIGlmIHRoZSBzZWdtZW50IGRhdGEgaXMgcGFydGlhbFxuICAgIGlzUHJlZmV0Y2hSc2NQYXJ0aWFsIHx8XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGhlYWQgaXMgcGFydGlhbCAob25seSByZWxldmFudCBpZiB0aGlzIGlzIGEgbGVhZiBzZWdtZW50KVxuICAgIChpc1ByZWZldGNoSGVhZFBhcnRpYWwgJiYgaXNMZWFmU2VnbWVudClcbiAgKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHBhcnRpYWwgZGF0YSBmcm9tIHRoaXMgc2VnbWVudC4gTGlrZSBtaXNzaW5nIHNlZ21lbnRzLCB3ZVxuICAgIC8vIG11c3QgcmVxdWVzdCB0aGUgZnVsbCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICByZXR1cm4gc3Bhd25QZW5kaW5nVGFzayhcbiAgICAgIHJvdXRlclN0YXRlLFxuICAgICAgcHJlZmV0Y2hEYXRhLFxuICAgICAgcG9zc2libHlQYXJ0aWFsUHJlZmV0Y2hIZWFkLFxuICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgc2VnbWVudFBhdGgsXG4gICAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHRcbiAgICApXG4gIH1cblxuICAvLyBUaGUgcHJlZmV0Y2hlZCBzZWdtZW50IGlzIGZ1bGx5IHN0YXRpYywgc28gd2UgZG9uJ3QgbmVlZCB0byByZXF1ZXN0IGEgbmV3XG4gIC8vIG9uZSBmcm9tIHRoZSBzZXJ2ZXIuIEtlZXAgdHJhdmVyc2luZyBkb3duIHRoZSB0cmVlIHVudGlsIHdlIHJlYWNoIHNvbWV0aGluZ1xuICAvLyB0aGF0IHJlcXVpcmVzIGEgZHluYW1pYyByZXF1ZXN0LlxuICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZHJlbiA9IHByZWZldGNoRGF0YVsyXVxuICBjb25zdCB0YXNrQ2hpbGRyZW4gPSBuZXcgTWFwKClcbiAgY29uc3QgY2FjaGVOb2RlQ2hpbGRyZW4gPSBuZXcgTWFwKClcbiAgbGV0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuOiB7XG4gICAgW3BhcmFsbGVsUm91dGVLZXk6IHN0cmluZ106IEZsaWdodFJvdXRlclN0YXRlXG4gIH0gPSB7fVxuICBsZXQgbmVlZHNEeW5hbWljUmVxdWVzdCA9IGZhbHNlXG4gIGlmIChpc0xlYWZTZWdtZW50KSB7XG4gICAgLy8gVGhlIHNlZ21lbnQgcGF0aCBvZiBldmVyeSBsZWFmIHNlZ21lbnQgKGkuZS4gcGFnZSkgaXMgY29sbGVjdGVkIGludG9cbiAgICAvLyBhIHJlc3VsdCBhcnJheS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBMYXlvdXRSb3V0ZXIgdG8gc2Nyb2xsIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gbmV3IHBhZ2VzIGFyZSB2aXNpYmxlIGFmdGVyIGEgbmF2aWdhdGlvbi5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgdXNlIGEgc3RyaW5nIHRvIHJlcHJlc2VudCB0aGUgc2VnbWVudCBwYXRoIGluc3RlYWQgb2ZcbiAgICAvLyBhbiBhcnJheS4gV2UgYWxyZWFkeSB1c2UgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwYXRoIHdoZW5cbiAgICAvLyBhY2Nlc3NpbmcgdGhlIFNlZ21lbnQgQ2FjaGUsIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgb25lLlxuICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdC5wdXNoKHNlZ21lbnRQYXRoKVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgICByb3V0ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCB2b2lkIHwgbnVsbCA9XG4gICAgICAgIHByZWZldGNoRGF0YUNoaWxkcmVuICE9PSBudWxsXG4gICAgICAgICAgPyBwcmVmZXRjaERhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgICAgICAgIDogbnVsbFxuICAgICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXVxuICAgICAgY29uc3Qgc2VnbWVudFBhdGhDaGlsZCA9IHNlZ21lbnRQYXRoLmNvbmNhdChbXG4gICAgICAgIHBhcmFsbGVsUm91dGVLZXksXG4gICAgICAgIHNlZ21lbnRDaGlsZCxcbiAgICAgIF0pXG4gICAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Q2hpbGQpXG4gICAgICBjb25zdCB0YXNrQ2hpbGQgPSBjcmVhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb24oXG4gICAgICAgIHJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICAgIHByZWZldGNoRGF0YUNoaWxkLFxuICAgICAgICBwb3NzaWJseVBhcnRpYWxQcmVmZXRjaEhlYWQsXG4gICAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgICAgc2VnbWVudFBhdGhDaGlsZCxcbiAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgICApXG4gICAgICB0YXNrQ2hpbGRyZW4uc2V0KHBhcmFsbGVsUm91dGVLZXksIHRhc2tDaGlsZClcbiAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkID0gdGFza0NoaWxkLmR5bmFtaWNSZXF1ZXN0VHJlZVxuICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgY2hpbGQgdHJlZSBpcyBkeW5hbWljLlxuICAgICAgICBuZWVkc0R5bmFtaWNSZXF1ZXN0ID0gdHJ1ZVxuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XSA9IHJvdXRlclN0YXRlQ2hpbGRcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gdGFza0NoaWxkLm5vZGVcbiAgICAgIGlmIChuZXdDYWNoZU5vZGVDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBuZXdTZWdtZW50TWFwQ2hpbGQ6IENoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoKVxuICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KHNlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgICAgIGNhY2hlTm9kZUNoaWxkcmVuLnNldChwYXJhbGxlbFJvdXRlS2V5LCBuZXdTZWdtZW50TWFwQ2hpbGQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcnNjID0gcHJlZmV0Y2hEYXRhWzFdXG4gIGNvbnN0IGxvYWRpbmcgPSBwcmVmZXRjaERhdGFbM11cbiAgcmV0dXJuIHtcbiAgICAvLyBTaW5jZSB3ZSdyZSBpbnNpZGUgYSBuZXcgcm91dGUgdHJlZSwgdW5saWtlIHRoZVxuICAgIC8vIGB1cGRhdGVDYWNoZU5vZGVPbk5hdmlnYXRpb25gIHBhdGgsIHRoZSByb3V0ZXIgc3RhdGUgb24gdGhlIGNoaWxkcmVuXG4gICAgLy8gdGFza3MgaXMgYWx3YXlzIHRoZSBzYW1lIGFzIHRoZSByb3V0ZXIgc3RhdGUgd2UgcGFzcyBpbi4gU28gd2UgZG9uJ3QgbmVlZFxuICAgIC8vIHRvIGNsb25lL21vZGlmeSBpdC5cbiAgICByb3V0ZTogcm91dGVyU3RhdGUsXG4gICAgbm9kZToge1xuICAgICAgbGF6eURhdGE6IG51bGwsXG4gICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgZnVsbHkgc3RhdGljIHNlZ21lbnQsIHdlIGRvbid0IG5lZWQgdG8gdXNlIHRoZVxuICAgICAgLy8gYHByZWZldGNoUnNjYCBmaWVsZC5cbiAgICAgIHJzYyxcbiAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgaGVhZDogaXNMZWFmU2VnbWVudCA/IHBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCA6IG51bGwsXG4gICAgICBwcmVmZXRjaEhlYWQ6IG51bGwsXG4gICAgICBsb2FkaW5nLFxuICAgICAgcGFyYWxsZWxSb3V0ZXM6IGNhY2hlTm9kZUNoaWxkcmVuLFxuICAgIH0sXG4gICAgZHluYW1pY1JlcXVlc3RUcmVlOiBuZWVkc0R5bmFtaWNSZXF1ZXN0XG4gICAgICA/IHBhdGNoUm91dGVyU3RhdGVXaXRoTmV3Q2hpbGRyZW4ocm91dGVyU3RhdGUsIGR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkcmVuKVxuICAgICAgOiBudWxsLFxuICAgIGNoaWxkcmVuOiB0YXNrQ2hpbGRyZW4sXG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbihcbiAgYmFzZVJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgbmV3Q2hpbGRyZW46IHsgW3BhcmFsbGVsUm91dGVLZXk6IHN0cmluZ106IEZsaWdodFJvdXRlclN0YXRlIH1cbik6IEZsaWdodFJvdXRlclN0YXRlIHtcbiAgY29uc3QgY2xvbmU6IEZsaWdodFJvdXRlclN0YXRlID0gW2Jhc2VSb3V0ZXJTdGF0ZVswXSwgbmV3Q2hpbGRyZW5dXG4gIC8vIEJhc2VkIG9uIGVxdWl2YWxlbnQgbG9naWMgaW4gYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUsIGJ1dCBzaG91bGRcbiAgLy8gY29uZmlybSB3aGV0aGVyIHdlIG5lZWQgdG8gY29weSBhbGwgb2YgdGhlc2UgZmllbGRzLiBOb3Qgc3VyZSB0aGUgc2VydmVyXG4gIC8vIGV2ZXIgc2VuZHMsIGUuZy4gdGhlIHJlZmV0Y2ggbWFya2VyLlxuICBpZiAoMiBpbiBiYXNlUm91dGVyU3RhdGUpIHtcbiAgICBjbG9uZVsyXSA9IGJhc2VSb3V0ZXJTdGF0ZVsyXVxuICB9XG4gIGlmICgzIGluIGJhc2VSb3V0ZXJTdGF0ZSkge1xuICAgIGNsb25lWzNdID0gYmFzZVJvdXRlclN0YXRlWzNdXG4gIH1cbiAgaWYgKDQgaW4gYmFzZVJvdXRlclN0YXRlKSB7XG4gICAgY2xvbmVbNF0gPSBiYXNlUm91dGVyU3RhdGVbNF1cbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gc3Bhd25QZW5kaW5nVGFzayhcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBwcmVmZXRjaERhdGE6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCxcbiAgcHJlZmV0Y2hIZWFkOiBIZWFkRGF0YSB8IG51bGwsXG4gIGlzUHJlZmV0Y2hIZWFkUGFydGlhbDogYm9vbGVhbixcbiAgc2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQ6IEFycmF5PEZsaWdodFNlZ21lbnRQYXRoPlxuKTogU1BBTmF2aWdhdGlvblRhc2sge1xuICAvLyBDcmVhdGUgYSB0YXNrIHRoYXQgd2lsbCBsYXRlciBiZSBmdWxmaWxsZWQgYnkgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG5cbiAgLy8gQ2xvbmUgdGhlIHByZWZldGNoZWQgcm91dGUgdHJlZSBhbmQgdGhlIGByZWZldGNoYCBtYXJrZXIgdG8gaXQuIFdlJ2xsIHNlbmRcbiAgLy8gdGhpcyB0byB0aGUgc2VydmVyIHNvIGl0IGtub3dzIHdoZXJlIHRvIHN0YXJ0IHJlbmRlcmluZy5cbiAgY29uc3QgZHluYW1pY1JlcXVlc3RUcmVlID0gcGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbihcbiAgICByb3V0ZXJTdGF0ZSxcbiAgICByb3V0ZXJTdGF0ZVsxXVxuICApXG4gIGR5bmFtaWNSZXF1ZXN0VHJlZVszXSA9ICdyZWZldGNoJ1xuXG4gIGNvbnN0IG5ld1Rhc2s6IFRhc2sgPSB7XG4gICAgcm91dGU6IHJvdXRlclN0YXRlLFxuXG4gICAgLy8gQ29ycmVzcG9uZHMgdG8gdGhlIHBhcnQgb2YgdGhlIHJvdXRlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyLlxuICAgIG5vZGU6IGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICByb3V0ZXJTdGF0ZSxcbiAgICAgIHByZWZldGNoRGF0YSxcbiAgICAgIHByZWZldGNoSGVhZCxcbiAgICAgIGlzUHJlZmV0Y2hIZWFkUGFydGlhbCxcbiAgICAgIHNlZ21lbnRQYXRoLFxuICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0XG4gICAgKSxcbiAgICAvLyBCZWNhdXNlIHRoaXMgaXMgbm9uLW51bGwsIGFuZCBpdCBnZXRzIHByb3BhZ2F0ZWQgdXAgdGhyb3VnaCB0aGUgcGFyZW50XG4gICAgLy8gdGFza3MsIHRoZSByb290IHRhc2sgd2lsbCBrbm93IHRoYXQgaXQgbmVlZHMgdG8gcGVyZm9ybSBhIHNlcnZlciByZXF1ZXN0LlxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZSxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxuICByZXR1cm4gbmV3VGFza1xufVxuXG5mdW5jdGlvbiBzcGF3blJldXNlZFRhc2socmV1c2VkUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlKTogVGFzayB7XG4gIC8vIENyZWF0ZSBhIHRhc2sgdGhhdCByZXVzZXMgYW4gZXhpc3Rpbmcgc2VnbWVudCwgZS5nLiB3aGVuIHJldXNpbmdcbiAgLy8gdGhlIGN1cnJlbnQgYWN0aXZlIHNlZ21lbnQgaW4gcGxhY2Ugb2YgYSBkZWZhdWx0IHJvdXRlLlxuICByZXR1cm4ge1xuICAgIHJvdXRlOiByZXVzZWRSb3V0ZXJTdGF0ZSxcbiAgICBub2RlOiBudWxsLFxuICAgIGR5bmFtaWNSZXF1ZXN0VHJlZTogbnVsbCxcbiAgICBjaGlsZHJlbjogbnVsbCxcbiAgfVxufVxuXG4vLyBXcml0ZXMgYSBkeW5hbWljIHNlcnZlciByZXNwb25zZSBpbnRvIHRoZSB0cmVlIGNyZWF0ZWQgYnlcbi8vIHVwZGF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbi4gQWxsIHBlbmRpbmcgcHJvbWlzZXMgdGhhdCB3ZXJlIHNwYXduZWQgYnkgdGhlXG4vLyBuYXZpZ2F0aW9uIHdpbGwgYmUgcmVzb2x2ZWQsIGVpdGhlciB3aXRoIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIG9yXG4vLyBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZGF0YSBpcyBtaXNzaW5nLlxuLy9cbi8vIEEgYG51bGxgIHZhbHVlIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZHVyaW5nIHJlbmRlciwgd2hpY2ggd2lsbCB0aGVuIHBhdGNoXG4vLyB1cCB0aGUgdHJlZSB1c2luZyB0aGUgc2FtZSBtZWNoYW5pc20gYXMgdGhlIG5vbi1QUFIgaW1wbGVtZW50YXRpb25cbi8vIChzZXJ2ZXJQYXRjaFJlZHVjZXIpLlxuLy9cbi8vIFVzdWFsbHksIHRoZSBzZXJ2ZXIgd2lsbCByZXNwb25kIHdpdGggZXhhY3RseSB0aGUgc3Vic2V0IG9mIGRhdGEgdGhhdCB3ZSdyZVxuLy8gd2FpdGluZyBmb3Ig4oCUIGV2ZXJ5dGhpbmcgYmVsb3cgdGhlIG5lYXJlc3Qgc2hhcmVkIGxheW91dC4gQnV0IHRlY2huaWNhbGx5LFxuLy8gdGhlIHNlcnZlciBjYW4gcmV0dXJuIGFueXRoaW5nIGl0IHdhbnRzLlxuLy9cbi8vIFRoaXMgZG9lcyBfbm90XyBjcmVhdGUgYSBuZXcgdHJlZTsgaXQgbW9kaWZpZXMgdGhlIGV4aXN0aW5nIG9uZSBpbiBwbGFjZS5cbi8vIFdoaWNoIG1lYW5zIGl0IG11c3QgZm9sbG93IHRoZSBTdXNwZW5zZSBydWxlcyBvZiBjYWNoZSBzYWZldHkuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QoXG4gIHRhc2s6IFNQQU5hdmlnYXRpb25UYXNrLFxuICByZXNwb25zZVByb21pc2U6IFByb21pc2U8RmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdD5cbikge1xuICByZXNwb25zZVByb21pc2UudGhlbihcbiAgICAoeyBmbGlnaHREYXRhIH06IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSGFwcGVucyB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGAuIFdlIHNob3VsZG4ndFxuICAgICAgICAvLyBnZXQgaGVyZSBiZWNhdXNlIHNob3VsZCBoYXZlIGFscmVhZHkgaGFuZGxlZCB0aGlzIGR1cmluZ1xuICAgICAgICAvLyB0aGUgcHJlZmV0Y2guXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWdtZW50UGF0aCxcbiAgICAgICAgICB0cmVlOiBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgICBzZWVkRGF0YTogZHluYW1pY0RhdGEsXG4gICAgICAgICAgaGVhZDogZHluYW1pY0hlYWQsXG4gICAgICAgIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgICAgIGlmICghZHluYW1pY0RhdGEpIHtcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4uIFBQUiBzaG91bGQgYWx3YXlzIHNlbmQgYmFjayBhIHJlc3BvbnNlLlxuICAgICAgICAgIC8vIEhvd2V2ZXIsIGBGbGlnaHREYXRhUGF0aGAgaXMgYSBzaGFyZWQgdHlwZSBhbmQgdGhlIHByZS1QUFIgaGFuZGxpbmcgb2ZcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IHJldHVybiBudWxsLlxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgc2VnbWVudFBhdGgsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGUsXG4gICAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgICAgZHluYW1pY0hlYWRcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgdGhhdCB3ZSd2ZSBleGhhdXN0ZWQgYWxsIHRoZSBkYXRhIHdlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciwgaWZcbiAgICAgIC8vIHRoZXJlIGFyZSBhbnkgcmVtYWluaW5nIHBlbmRpbmcgdGFza3MgaW4gdGhlIHRyZWUsIGFib3J0IHRoZW0gbm93LlxuICAgICAgLy8gSWYgdGhlcmUncyBhbnkgbWlzc2luZyBkYXRhLCBpdCB3aWxsIHRyaWdnZXIgYSBsYXp5IGZldGNoLlxuICAgICAgYWJvcnRUYXNrKHRhc2ssIG51bGwpXG4gICAgfSxcbiAgICAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgZHVyaW5nIHJlbmRlclxuICAgICAgYWJvcnRUYXNrKHRhc2ssIGVycm9yKVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiB3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrKFxuICByb290VGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2VydmVyUm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBkeW5hbWljRGF0YTogQ2FjaGVOb2RlU2VlZERhdGEsXG4gIGR5bmFtaWNIZWFkOiBIZWFkRGF0YVxuKSB7XG4gIC8vIFRoZSBkYXRhIHNlbnQgYnkgdGhlIHNlcnZlciByZXByZXNlbnRzIG9ubHkgYSBzdWJ0cmVlIG9mIHRoZSBhcHAuIFdlIG5lZWRcbiAgLy8gdG8gZmluZCB0aGUgcGFydCBvZiB0aGUgdGFzayB0cmVlIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIHJlc3BvbnNlLCBhbmRcbiAgLy8gZnVsZmlsbCBpdCB1c2luZyB0aGUgZHluYW1pYyBkYXRhLlxuICAvL1xuICAvLyBzZWdtZW50UGF0aCByZXByZXNlbnRzIHRoZSBwYXJlbnQgcGF0aCBvZiBzdWJ0cmVlLiBJdCdzIGEgcmVwZWF0aW5nIHBhdHRlcm5cbiAgLy8gb2YgcGFyYWxsZWwgcm91dGUga2V5IGFuZCBzZWdtZW50OlxuICAvL1xuICAvLyAgIFtzdHJpbmcsIFNlZ21lbnQsIHN0cmluZywgU2VnbWVudCwgc3RyaW5nLCBTZWdtZW50LCAuLi5dXG4gIC8vXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGF0aCBhbmQgZmluaXNoIGFueSB0YXNrcyB0aGF0IG1hdGNoIHRoaXMgcGF5bG9hZC5cbiAgbGV0IHRhc2sgPSByb290VGFza1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRQYXRoLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleTogc3RyaW5nID0gc2VnbWVudFBhdGhbaV1cbiAgICBjb25zdCBzZWdtZW50OiBTZWdtZW50ID0gc2VnbWVudFBhdGhbaSArIDFdXG4gICAgY29uc3QgdGFza0NoaWxkcmVuID0gdGFzay5jaGlsZHJlblxuICAgIGlmICh0YXNrQ2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRhc2tDaGlsZCA9IHRhc2tDaGlsZHJlbi5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YXNrU2VnbWVudCA9IHRhc2tDaGlsZC5yb3V0ZVswXVxuICAgICAgICBpZiAobWF0Y2hTZWdtZW50KHNlZ21lbnQsIHRhc2tTZWdtZW50KSkge1xuICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgICB0YXNrID0gdGFza0NoaWxkXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSBkaWRuJ3QgZmluZCBhIGNoaWxkIHRhc2sgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2ZXIgZGF0YS4gRXhpdC4gV2Ugd29uJ3RcbiAgICAvLyBhYm9ydCB0aGUgdGFzaywgdGhvdWdoLCBiZWNhdXNlIGEgZGlmZmVyZW50IEZsaWdodERhdGFQYXRoIG1heSBiZSBhYmxlIHRvXG4gICAgLy8gZnVsZmlsbCBpdCAoc2VlIGxvb3AgaW4gbGlzdGVuRm9yRHluYW1pY1JlcXVlc3QpLiBXZSBvbmx5IGFib3J0IHRhc2tzXG4gICAgLy8gb25jZSB3ZSd2ZSBydW4gb3V0IG9mIGRhdGEuXG4gICAgcmV0dXJuXG4gIH1cblxuICBmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQoXG4gICAgdGFzayxcbiAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICBkeW5hbWljRGF0YSxcbiAgICBkeW5hbWljSGVhZFxuICApXG59XG5cbmZ1bmN0aW9uIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgdGFzazogU1BBTmF2aWdhdGlvblRhc2ssXG4gIHNlcnZlclJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZHluYW1pY0RhdGE6IENhY2hlTm9kZVNlZWREYXRhLFxuICBkeW5hbWljSGVhZDogSGVhZERhdGFcbikge1xuICBpZiAodGFzay5keW5hbWljUmVxdWVzdFRyZWUgPT09IG51bGwpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGluIHRoaXMgc3VidHJlZSBpcyBhbHJlYWR5IGNvbXBsZXRlLiBCYWlsIG91dC5cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGR5bmFtaWNEYXRhIG1heSByZXByZXNlbnQgYSBsYXJnZXIgc3VidHJlZSB0aGFuIHRoZSB0YXNrLiBCZWZvcmUgd2UgY2FuXG4gIC8vIGZpbmlzaCB0aGUgdGFzaywgd2UgbmVlZCB0byBsaW5lIHRoZW0gdXAuXG4gIGNvbnN0IHRhc2tDaGlsZHJlbiA9IHRhc2suY2hpbGRyZW5cbiAgY29uc3QgdGFza05vZGUgPSB0YXNrLm5vZGVcbiAgaWYgKHRhc2tDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGxlYWYgbm9kZSBvZiB0aGUgcGVuZGluZyB0YXNrLiBUaGUgc2VydmVyIGRhdGEgdHJlZVxuICAgIC8vIGxpbmVzIHVwIHRoZSBwZW5kaW5nIENhY2hlIE5vZGUgdHJlZS4gV2UgY2FuIG5vdyBzd2l0Y2ggdG8gdGhlXG4gICAgLy8gbm9ybWFsIGFsZ29yaXRobS5cbiAgICBpZiAodGFza05vZGUgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaFBlbmRpbmdDYWNoZU5vZGUoXG4gICAgICAgIHRhc2tOb2RlLFxuICAgICAgICB0YXNrLnJvdXRlLFxuICAgICAgICBzZXJ2ZXJSb3V0ZXJTdGF0ZSxcbiAgICAgICAgZHluYW1pY0RhdGEsXG4gICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICApXG4gICAgICAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoYXQgdGhpcyB0YXNrIGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIHRhc2suZHluYW1pY1JlcXVlc3RUcmVlID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICAvLyBUaGUgc2VydmVyIHJldHVybmVkIG1vcmUgZGF0YSB0aGFuIHdlIG5lZWQgdG8gZmluaXNoIHRoZSB0YXNrLiBTa2lwIG92ZXJcbiAgLy8gdGhlIGV4dHJhIHNlZ21lbnRzIHVudGlsIHdlIHJlYWNoIHRoZSBsZWFmIHRhc2sgbm9kZS5cbiAgY29uc3Qgc2VydmVyQ2hpbGRyZW4gPSBzZXJ2ZXJSb3V0ZXJTdGF0ZVsxXVxuICBjb25zdCBkeW5hbWljRGF0YUNoaWxkcmVuID0gZHluYW1pY0RhdGFbMl1cblxuICBmb3IgKGNvbnN0IHBhcmFsbGVsUm91dGVLZXkgaW4gc2VydmVyUm91dGVyU3RhdGUpIHtcbiAgICBjb25zdCBzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICBzZXJ2ZXJDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IGR5bmFtaWNEYXRhQ2hpbGQ6IENhY2hlTm9kZVNlZWREYXRhIHwgbnVsbCB8IHZvaWQgPVxuICAgICAgZHluYW1pY0RhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuXG4gICAgY29uc3QgdGFza0NoaWxkID0gdGFza0NoaWxkcmVuLmdldChwYXJhbGxlbFJvdXRlS2V5KVxuICAgIGlmICh0YXNrQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGFza1NlZ21lbnQgPSB0YXNrQ2hpbGQucm91dGVbMF1cbiAgICAgIGlmIChcbiAgICAgICAgbWF0Y2hTZWdtZW50KHNlcnZlclJvdXRlclN0YXRlQ2hpbGRbMF0sIHRhc2tTZWdtZW50KSAmJlxuICAgICAgICBkeW5hbWljRGF0YUNoaWxkICE9PSBudWxsICYmXG4gICAgICAgIGR5bmFtaWNEYXRhQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIC8vIEZvdW5kIGEgbWF0Y2ggZm9yIHRoaXMgdGFzay4gS2VlcCB0cmF2ZXJzaW5nIGRvd24gdGhlIHRhc2sgdHJlZS5cbiAgICAgICAgcmV0dXJuIGZpbmlzaFRhc2tVc2luZ0R5bmFtaWNEYXRhUGF5bG9hZChcbiAgICAgICAgICB0YXNrQ2hpbGQsXG4gICAgICAgICAgc2VydmVyUm91dGVyU3RhdGVDaGlsZCxcbiAgICAgICAgICBkeW5hbWljRGF0YUNoaWxkLFxuICAgICAgICAgIGR5bmFtaWNIZWFkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZGlkbid0IGZpbmQgYSBjaGlsZCB0YXNrIHRoYXQgbWF0Y2hlcyB0aGUgc2VydmVyIGRhdGEuIFdlIHdvbid0IGFib3J0XG4gICAgLy8gdGhlIHRhc2ssIHRob3VnaCwgYmVjYXVzZSBhIGRpZmZlcmVudCBGbGlnaHREYXRhUGF0aCBtYXkgYmUgYWJsZSB0b1xuICAgIC8vIGZ1bGZpbGwgaXQgKHNlZSBsb29wIGluIGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0KS4gV2Ugb25seSBhYm9ydCB0YXNrc1xuICAgIC8vIG9uY2Ugd2UndmUgcnVuIG91dCBvZiBkYXRhLlxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdDYWNoZU5vZGUoXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcHJlZmV0Y2hEYXRhOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwsXG4gIHByZWZldGNoSGVhZDogSGVhZERhdGEgfCBudWxsLFxuICBpc1ByZWZldGNoSGVhZFBhcnRpYWw6IGJvb2xlYW4sXG4gIHNlZ21lbnRQYXRoOiBGbGlnaHRTZWdtZW50UGF0aCxcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzUmVzdWx0OiBBcnJheTxGbGlnaHRTZWdtZW50UGF0aD5cbik6IFJlYWR5Q2FjaGVOb2RlIHtcbiAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdXG4gIGNvbnN0IHByZWZldGNoRGF0YUNoaWxkcmVuID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzJdIDogbnVsbFxuXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gbmV3IE1hcCgpXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBwcmVmZXRjaERhdGFDaGlsZDogQ2FjaGVOb2RlU2VlZERhdGEgfCBudWxsIHwgdm9pZCA9XG4gICAgICBwcmVmZXRjaERhdGFDaGlsZHJlbiAhPT0gbnVsbFxuICAgICAgICA/IHByZWZldGNoRGF0YUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgICAgIDogbnVsbFxuXG4gICAgY29uc3Qgc2VnbWVudENoaWxkID0gcm91dGVyU3RhdGVDaGlsZFswXVxuICAgIGNvbnN0IHNlZ21lbnRQYXRoQ2hpbGQgPSBzZWdtZW50UGF0aC5jb25jYXQoW1xuICAgICAgcGFyYWxsZWxSb3V0ZUtleSxcbiAgICAgIHNlZ21lbnRDaGlsZCxcbiAgICBdKVxuICAgIGNvbnN0IHNlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHNlZ21lbnRDaGlsZClcblxuICAgIGNvbnN0IG5ld0NhY2hlTm9kZUNoaWxkID0gY3JlYXRlUGVuZGluZ0NhY2hlTm9kZShcbiAgICAgIHJvdXRlclN0YXRlQ2hpbGQsXG4gICAgICBwcmVmZXRjaERhdGFDaGlsZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHByZWZldGNoRGF0YUNoaWxkLFxuICAgICAgcHJlZmV0Y2hIZWFkLFxuICAgICAgaXNQcmVmZXRjaEhlYWRQYXJ0aWFsLFxuICAgICAgc2VnbWVudFBhdGhDaGlsZCxcbiAgICAgIHNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdFxuICAgIClcblxuICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZDogQ2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcCgpXG4gICAgbmV3U2VnbWVudE1hcENoaWxkLnNldChzZWdtZW50S2V5Q2hpbGQsIG5ld0NhY2hlTm9kZUNoaWxkKVxuICAgIHBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBuZXdTZWdtZW50TWFwQ2hpbGQpXG4gIH1cblxuICAvLyBUaGUgaGVhZCBpcyBhc3NpZ25lZCB0byBldmVyeSBsZWFmIHNlZ21lbnQgZGVsaXZlcmVkIGJ5IHRoZSBzZXJ2ZXIuIEJhc2VkXG4gIC8vIG9uIGNvcnJlc3BvbmRpbmcgbG9naWMgaW4gZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQudHNcbiAgY29uc3QgaXNMZWFmU2VnbWVudCA9IHBhcmFsbGVsUm91dGVzLnNpemUgPT09IDBcblxuICBpZiAoaXNMZWFmU2VnbWVudCkge1xuICAgIC8vIFRoZSBzZWdtZW50IHBhdGggb2YgZXZlcnkgbGVhZiBzZWdtZW50IChpLmUuIHBhZ2UpIGlzIGNvbGxlY3RlZCBpbnRvXG4gICAgLy8gYSByZXN1bHQgYXJyYXkuIFRoaXMgaXMgdXNlZCBieSB0aGUgTGF5b3V0Um91dGVyIHRvIHNjcm9sbCB0byBlbnN1cmUgdGhhdFxuICAgIC8vIG5ldyBwYWdlcyBhcmUgdmlzaWJsZSBhZnRlciBhIG5hdmlnYXRpb24uXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIHVzZSBhIHN0cmluZyB0byByZXByZXNlbnQgdGhlIHNlZ21lbnQgcGF0aCBpbnN0ZWFkIG9mXG4gICAgLy8gYW4gYXJyYXkuIFdlIGFscmVhZHkgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGUgcGF0aCB3aGVuXG4gICAgLy8gYWNjZXNzaW5nIHRoZSBTZWdtZW50IENhY2hlLCBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIG9uZS5cbiAgICBzY3JvbGxhYmxlU2VnbWVudHNSZXN1bHQucHVzaChzZWdtZW50UGF0aClcbiAgfVxuXG4gIGNvbnN0IG1heWJlUHJlZmV0Y2hSc2MgPSBwcmVmZXRjaERhdGEgIT09IG51bGwgPyBwcmVmZXRjaERhdGFbMV0gOiBudWxsXG4gIGNvbnN0IG1heWJlUHJlZmV0Y2hMb2FkaW5nID0gcHJlZmV0Y2hEYXRhICE9PSBudWxsID8gcHJlZmV0Y2hEYXRhWzNdIDogbnVsbFxuICByZXR1cm4ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHBhcmFsbGVsUm91dGVzOiBwYXJhbGxlbFJvdXRlcyxcblxuICAgIHByZWZldGNoUnNjOiBtYXliZVByZWZldGNoUnNjICE9PSB1bmRlZmluZWQgPyBtYXliZVByZWZldGNoUnNjIDogbnVsbCxcbiAgICBwcmVmZXRjaEhlYWQ6IGlzTGVhZlNlZ21lbnQgPyBwcmVmZXRjaEhlYWQgOiBbbnVsbCwgbnVsbF0sXG5cbiAgICAvLyBUT0RPOiBUZWNobmljYWxseSwgYSBsb2FkaW5nIGJvdW5kYXJ5IGNvdWxkIGNvbnRhaW4gZHluYW1pYyBkYXRhLiBXZSBtdXN0XG4gICAgLy8gaGF2ZSBzZXBhcmF0ZSBgbG9hZGluZ2AgYW5kIGBwcmVmZXRjaExvYWRpbmdgIGZpZWxkcyB0byBoYW5kbGUgdGhpcywgbGlrZVxuICAgIC8vIHdlIGRvIGZvciB0aGUgc2VnbWVudCBkYXRhIGFuZCBoZWFkLlxuICAgIGxvYWRpbmc6IG1heWJlUHJlZmV0Y2hMb2FkaW5nICE9PSB1bmRlZmluZWQgPyBtYXliZVByZWZldGNoTG9hZGluZyA6IG51bGwsXG5cbiAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBwcm9taXNlLiBUaGlzIHdpbGwgYmUgZnVsZmlsbGVkIG9uY2UgdGhlIGR5bmFtaWNcbiAgICAvLyByZXNwb25zZSBpcyByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgcnNjOiBjcmVhdGVEZWZlcnJlZFJzYygpIGFzIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICBoZWFkOiBpc0xlYWZTZWdtZW50ID8gKGNyZWF0ZURlZmVycmVkUnNjKCkgYXMgUmVhY3QuUmVhY3ROb2RlKSA6IG51bGwsXG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoUGVuZGluZ0NhY2hlTm9kZShcbiAgY2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIHRhc2tTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGUsXG4gIHNlcnZlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgZHluYW1pY0RhdGE6IENhY2hlTm9kZVNlZWREYXRhLFxuICBkeW5hbWljSGVhZDogSGVhZERhdGFcbik6IHZvaWQge1xuICAvLyBXcml0ZXMgYSBkeW5hbWljIHJlc3BvbnNlIGludG8gYW4gZXhpc3RpbmcgQ2FjaGUgTm9kZSB0cmVlLiBUaGlzIGRvZXMgX25vdF9cbiAgLy8gY3JlYXRlIGEgbmV3IHRyZWUsIGl0IHVwZGF0ZXMgdGhlIGV4aXN0aW5nIHRyZWUgaW4tcGxhY2UuIFNvIGl0IG11c3QgZm9sbG93XG4gIC8vIHRoZSBTdXNwZW5zZSBydWxlcyBvZiBjYWNoZSBzYWZldHkg4oCUIGl0IGNhbiByZXNvbHZlIHBlbmRpbmcgcHJvbWlzZXMsIGJ1dFxuICAvLyBpdCBjYW5ub3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGRhdGEuIEl0IGNhbiBhZGQgc2VnbWVudHMgdG8gdGhlIHRyZWUgKGJlY2F1c2VcbiAgLy8gYSBtaXNzaW5nIHNlZ21lbnQgd2lsbCBjYXVzZSB0aGUgbGF5b3V0IHJvdXRlciB0byBzdXNwZW5kKS5cbiAgLy8gYnV0IGl0IGNhbm5vdCBkZWxldGUgdGhlbS5cbiAgLy9cbiAgLy8gV2UgbXVzdCByZXNvbHZlIGV2ZXJ5IHByb21pc2UgaW4gdGhlIHRyZWUsIG9yIGVsc2UgaXQgd2lsbCBzdXNwZW5kXG4gIC8vIGluZGVmaW5pdGVseS4gSWYgd2UgZGlkIG5vdCByZWNlaXZlIGRhdGEgZm9yIGEgc2VnbWVudCwgd2Ugd2lsbCByZXNvbHZlIGl0c1xuICAvLyBkYXRhIHByb21pc2UgdG8gYG51bGxgIHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIuXG4gIGNvbnN0IHRhc2tTdGF0ZUNoaWxkcmVuID0gdGFza1N0YXRlWzFdXG4gIGNvbnN0IHNlcnZlclN0YXRlQ2hpbGRyZW4gPSBzZXJ2ZXJTdGF0ZVsxXVxuICBjb25zdCBkYXRhQ2hpbGRyZW4gPSBkeW5hbWljRGF0YVsyXVxuXG4gIC8vIFRoZSByb3V0ZXIgc3RhdGUgdGhhdCB3ZSB0cmF2ZXJzZSB0aGUgdHJlZSB3aXRoICh0YXNrU3RhdGUpIGlzIHRoZSBzYW1lIG9uZVxuICAvLyB0aGF0IHdlIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwZW5kaW5nIENhY2hlIE5vZGUgdHJlZS4gVGhhdCB3YXkgd2UncmUgc3VyZVxuICAvLyB0byByZXNvbHZlIGFsbCB0aGUgcGVuZGluZyBwcm9taXNlcy5cbiAgY29uc3QgcGFyYWxsZWxSb3V0ZXMgPSBjYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXNcbiAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiB0YXNrU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHRhc2tTdGF0ZUNoaWxkOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9XG4gICAgICB0YXNrU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IHNlcnZlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlIHwgdm9pZCA9XG4gICAgICBzZXJ2ZXJTdGF0ZUNoaWxkcmVuW3BhcmFsbGVsUm91dGVLZXldXG4gICAgY29uc3QgZGF0YUNoaWxkOiBDYWNoZU5vZGVTZWVkRGF0YSB8IG51bGwgfCB2b2lkID1cbiAgICAgIGRhdGFDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuXG4gICAgY29uc3Qgc2VnbWVudE1hcENoaWxkID0gcGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgY29uc3QgdGFza1NlZ21lbnRDaGlsZCA9IHRhc2tTdGF0ZUNoaWxkWzBdXG4gICAgY29uc3QgdGFza1NlZ21lbnRLZXlDaGlsZCA9IGNyZWF0ZVJvdXRlckNhY2hlS2V5KHRhc2tTZWdtZW50Q2hpbGQpXG5cbiAgICBjb25zdCBjYWNoZU5vZGVDaGlsZCA9XG4gICAgICBzZWdtZW50TWFwQ2hpbGQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNlZ21lbnRNYXBDaGlsZC5nZXQodGFza1NlZ21lbnRLZXlDaGlsZClcbiAgICAgICAgOiB1bmRlZmluZWRcblxuICAgIGlmIChjYWNoZU5vZGVDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHNlcnZlclN0YXRlQ2hpbGQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBtYXRjaFNlZ21lbnQodGFza1NlZ21lbnRDaGlsZCwgc2VydmVyU3RhdGVDaGlsZFswXSlcbiAgICAgICkge1xuICAgICAgICBpZiAoZGF0YUNoaWxkICE9PSB1bmRlZmluZWQgJiYgZGF0YUNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgaGFwcHkgcGF0aC4gUmVjdXJzaXZlbHkgdXBkYXRlIGFsbCB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgZmluaXNoUGVuZGluZ0NhY2hlTm9kZShcbiAgICAgICAgICAgIGNhY2hlTm9kZUNoaWxkLFxuICAgICAgICAgICAgdGFza1N0YXRlQ2hpbGQsXG4gICAgICAgICAgICBzZXJ2ZXJTdGF0ZUNoaWxkLFxuICAgICAgICAgICAgZGF0YUNoaWxkLFxuICAgICAgICAgICAgZHluYW1pY0hlYWRcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIHNlcnZlciBuZXZlciByZXR1cm5lZCBkYXRhIGZvciB0aGlzIHNlZ21lbnQuIFRyaWdnZXIgYSBsYXp5XG4gICAgICAgICAgLy8gZmV0Y2ggZHVyaW5nIHJlbmRlci4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhlIFJvdXRlIFRyZWVcbiAgICAgICAgICAvLyBhbmQgdGhlIFNlZWQgRGF0YSB0cmVlIHNlbnQgYnkgdGhlIHNlcnZlciBzaG91bGQgYWx3YXlzIGJlIHRoZSBzYW1lXG4gICAgICAgICAgLy8gc2hhcGUgd2hlbiBwYXJ0IG9mIHRoZSBzYW1lIHNlcnZlciByZXNwb25zZS5cbiAgICAgICAgICBhYm9ydFBlbmRpbmdDYWNoZU5vZGUodGFza1N0YXRlQ2hpbGQsIGNhY2hlTm9kZUNoaWxkLCBudWxsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgc2VydmVyIG5ldmVyIHJldHVybmVkIGRhdGEgZm9yIHRoaXMgc2VnbWVudC4gVHJpZ2dlciBhIGxhenlcbiAgICAgICAgLy8gZmV0Y2ggZHVyaW5nIHJlbmRlci5cbiAgICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2tTdGF0ZUNoaWxkLCBjYWNoZU5vZGVDaGlsZCwgbnVsbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHNlcnZlciByZXNwb25zZSBtYXRjaGVzIHdoYXQgd2FzIGV4cGVjdGVkIHRvIHJlY2VpdmUsIGJ1dCB0aGVyZSdzXG4gICAgICAvLyBubyBtYXRjaGluZyBDYWNoZSBOb2RlIGluIHRoZSB0YXNrIHRyZWUuIFRoaXMgaXMgYSBidWcgaW4gdGhlXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGNyZWF0ZWQgYSBub2RlIGZvciBldmVyeVxuICAgICAgLy8gc2VnbWVudCBpbiB0aGUgdHJlZSB0aGF0J3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGFzay5cbiAgICB9XG4gIH1cblxuICAvLyBVc2UgdGhlIGR5bmFtaWMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdG8gZnVsZmlsbCB0aGUgZGVmZXJyZWQgUlNDIHByb21pc2VcbiAgLy8gb24gdGhlIENhY2hlIE5vZGUuXG4gIGNvbnN0IHJzYyA9IGNhY2hlTm9kZS5yc2NcbiAgY29uc3QgZHluYW1pY1NlZ21lbnREYXRhID0gZHluYW1pY0RhdGFbMV1cbiAgaWYgKHJzYyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSBsYXp5IGNhY2hlIG5vZGUuIFdlIGNhbiBvdmVyd3JpdGUgaXQuIFRoaXMgaXMgb25seSBzYWZlXG4gICAgLy8gYmVjYXVzZSB3ZSBrbm93IHRoYXQgdGhlIExheW91dFJvdXRlciBzdXNwZW5kcyBpZiBgcnNjYCBpcyBgbnVsbGAuXG4gICAgY2FjaGVOb2RlLnJzYyA9IGR5bmFtaWNTZWdtZW50RGF0YVxuICB9IGVsc2UgaWYgKGlzRGVmZXJyZWRSc2MocnNjKSkge1xuICAgIC8vIFRoaXMgaXMgYSBkZWZlcnJlZCBSU0MgcHJvbWlzZS4gV2UgY2FuIGZ1bGZpbGwgaXQgd2l0aCB0aGUgZGF0YSB3ZSBqdXN0XG4gICAgLy8gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLiBJZiBpdCB3YXMgYWxyZWFkeSByZXNvbHZlZCBieSBhIGRpZmZlcmVudFxuICAgIC8vIG5hdmlnYXRpb24sIHRoZW4gdGhpcyBkb2VzIG5vdGhpbmcgYmVjYXVzZSB3ZSBjYW4ndCBvdmVyd3JpdGUgZGF0YS5cbiAgICByc2MucmVzb2x2ZShkeW5hbWljU2VnbWVudERhdGEpXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYSBkZWZlcnJlZCBSU0MgcHJvbWlzZSwgbm9yIGlzIGl0IGVtcHR5LCBzbyBpdCBtdXN0IGhhdmVcbiAgICAvLyBiZWVuIHBvcHVsYXRlZCBieSBhIGRpZmZlcmVudCBuYXZpZ2F0aW9uLiBXZSBtdXN0IG5vdCBvdmVyd3JpdGUgaXQuXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgbGVhZiBzZWdtZW50LiBJZiBzbywgaXQgd2lsbCBoYXZlIGEgYGhlYWRgIHByb3BlcnR5IHdpdGhcbiAgLy8gYSBwZW5kaW5nIHByb21pc2UgdGhhdCBuZWVkcyB0byBiZSByZXNvbHZlZCB3aXRoIHRoZSBkeW5hbWljIGhlYWQgZnJvbVxuICAvLyB0aGUgc2VydmVyLlxuICBjb25zdCBoZWFkID0gY2FjaGVOb2RlLmhlYWRcbiAgaWYgKGlzRGVmZXJyZWRSc2MoaGVhZCkpIHtcbiAgICBoZWFkLnJlc29sdmUoZHluYW1pY0hlYWQpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0VGFzayh0YXNrOiBTUEFOYXZpZ2F0aW9uVGFzaywgZXJyb3I6IGFueSk6IHZvaWQge1xuICBjb25zdCBjYWNoZU5vZGUgPSB0YXNrLm5vZGVcbiAgaWYgKGNhY2hlTm9kZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaW5kaWNhdGVzIHRoZSB0YXNrIGlzIGFscmVhZHkgY29tcGxldGUuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB0YXNrQ2hpbGRyZW4gPSB0YXNrLmNoaWxkcmVuXG4gIGlmICh0YXNrQ2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAvLyBSZWFjaGVkIHRoZSBsZWFmIHRhc2sgbm9kZS4gVGhpcyBpcyB0aGUgcm9vdCBvZiBhIHBlbmRpbmcgY2FjaGVcbiAgICAvLyBub2RlIHRyZWUuXG4gICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHRhc2sucm91dGUsIGNhY2hlTm9kZSwgZXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiBpbnRlcm1lZGlhdGUgdGFzayBub2RlLiBLZWVwIHRyYXZlcnNpbmcgdW50aWwgd2UgcmVhY2ggYVxuICAgIC8vIHRhc2sgbm9kZSB3aXRoIG5vIGNoaWxkcmVuLiBUaGF0IHdpbGwgYmUgdGhlIHJvb3Qgb2YgdGhlIGNhY2hlIG5vZGUgdHJlZVxuICAgIC8vIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQuXG4gICAgZm9yIChjb25zdCB0YXNrQ2hpbGQgb2YgdGFza0NoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICBhYm9ydFRhc2sodGFza0NoaWxkLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoYXQgdGhpcyB0YXNrIGlzIG5vdyBjb21wbGV0ZS5cbiAgdGFzay5keW5hbWljUmVxdWVzdFRyZWUgPSBudWxsXG59XG5cbmZ1bmN0aW9uIGFib3J0UGVuZGluZ0NhY2hlTm9kZShcbiAgcm91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlLFxuICBjYWNoZU5vZGU6IENhY2hlTm9kZSxcbiAgZXJyb3I6IGFueVxuKTogdm9pZCB7XG4gIC8vIEZvciBldmVyeSBwZW5kaW5nIHNlZ21lbnQgaW4gdGhlIHRyZWUsIHJlc29sdmUgaXRzIGByc2NgIHByb21pc2UgdG8gYG51bGxgXG4gIC8vIHRvIHRyaWdnZXIgYSBsYXp5IGZldGNoIGR1cmluZyByZW5kZXIuXG4gIC8vXG4gIC8vIE9yLCBpZiBhbiBlcnJvciBvYmplY3QgaXMgcHJvdmlkZWQsIGl0IHdpbGwgZXJyb3IgaW5zdGVhZC5cbiAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdXG4gIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gY2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG4gIGZvciAobGV0IHBhcmFsbGVsUm91dGVLZXkgaW4gcm91dGVyU3RhdGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHJvdXRlclN0YXRlQ2hpbGQ6IEZsaWdodFJvdXRlclN0YXRlID1cbiAgICAgIHJvdXRlclN0YXRlQ2hpbGRyZW5bcGFyYWxsZWxSb3V0ZUtleV1cbiAgICBjb25zdCBzZWdtZW50TWFwQ2hpbGQgPSBwYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSlcbiAgICBpZiAoc2VnbWVudE1hcENoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHdlJ3JlIHRyYXZlcnNpbmcgdGhlIHNhbWUgdHJlZSB0aGF0IHdhc1xuICAgICAgLy8gdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNhY2hlIG5vZGVzIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Q2hpbGQpXG4gICAgY29uc3QgY2FjaGVOb2RlQ2hpbGQgPSBzZWdtZW50TWFwQ2hpbGQuZ2V0KHNlZ21lbnRLZXlDaGlsZClcbiAgICBpZiAoY2FjaGVOb2RlQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWJvcnRQZW5kaW5nQ2FjaGVOb2RlKHJvdXRlclN0YXRlQ2hpbGQsIGNhY2hlTm9kZUNoaWxkLCBlcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2Ugd2UncmUgdHJhdmVyc2luZyB0aGUgc2FtZSB0cmVlIHRoYXQgd2FzXG4gICAgICAvLyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgY2FjaGUgbm9kZXMgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIH1cbiAgfVxuICBjb25zdCByc2MgPSBjYWNoZU5vZGUucnNjXG4gIGlmIChpc0RlZmVycmVkUnNjKHJzYykpIHtcbiAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgbGF6eSBmZXRjaCBkdXJpbmcgcmVuZGVyLlxuICAgICAgcnNjLnJlc29sdmUobnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gZXJyb3IgZHVyaW5nIHJlbmRlcmluZy5cbiAgICAgIHJzYy5yZWplY3QoZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGxlYWYgc2VnbWVudC4gSWYgc28sIGl0IHdpbGwgaGF2ZSBhIGBoZWFkYCBwcm9wZXJ0eSB3aXRoXG4gIC8vIGEgcGVuZGluZyBwcm9taXNlIHRoYXQgbmVlZHMgdG8gYmUgcmVzb2x2ZWQuIElmIGFuIGVycm9yIHdhcyBwcm92aWRlZCwgd2VcbiAgLy8gd2lsbCBub3QgcmVzb2x2ZSBpdCB3aXRoIGFuIGVycm9yLCBzaW5jZSB0aGlzIGlzIHJlbmRlcmVkIGF0IHRoZSByb290IG9mXG4gIC8vIHRoZSBhcHAuIFdlIHdhbnQgdGhlIHNlZ21lbnQgdG8gZXJyb3IsIG5vdCB0aGUgZW50aXJlIGFwcC5cbiAgY29uc3QgaGVhZCA9IGNhY2hlTm9kZS5oZWFkXG4gIGlmIChpc0RlZmVycmVkUnNjKGhlYWQpKSB7XG4gICAgaGVhZC5yZXNvbHZlKG51bGwpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbihcbiAgb2xkQ2FjaGVOb2RlOiBDYWNoZU5vZGUsXG4gIHJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuKTogUmVhZHlDYWNoZU5vZGUge1xuICAvLyBBIHBvcHN0YXRlIG5hdmlnYXRpb24gcmVhZHMgZGF0YSBmcm9tIHRoZSBsb2NhbCBjYWNoZS4gSXQgZG9lcyBub3QgaXNzdWVcbiAgLy8gbmV3IG5ldHdvcmsgcmVxdWVzdHMgKHVubGVzcyB0aGUgY2FjaGUgZW50cmllcyBoYXZlIGJlZW4gZXZpY3RlZCkuIFNvLCB3ZVxuICAvLyB1cGRhdGUgdGhlIGNhY2hlIHRvIGRyb3AgdGhlIHByZWZldGNoIGRhdGEgZm9yIGFueSBzZWdtZW50IHdob3NlIGR5bmFtaWNcbiAgLy8gZGF0YSB3YXMgYWxyZWFkeSByZWNlaXZlZC4gVGhpcyBwcmV2ZW50cyBhbiB1bm5lY2Vzc2FyeSBmbGFzaCBiYWNrIHRvIFBQUlxuICAvLyBzdGF0ZSBkdXJpbmcgYSBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbi5cbiAgLy9cbiAgLy8gVGhpcyBmdW5jdGlvbiBjbG9uZXMgdGhlIGVudGlyZSBjYWNoZSBub2RlIHRyZWUgYW5kIHNldHMgdGhlIGBwcmVmZXRjaFJzY2BcbiAgLy8gZmllbGQgdG8gYG51bGxgIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZC4gV2UgY2FuJ3QgbXV0YXRlIHRoZSBub2RlXG4gIC8vIGluIHBsYWNlIGJlY2F1c2UgdGhpcyBpcyBhIGNvbmN1cnJlbnQgZGF0YSBzdHJ1Y3R1cmUuXG5cbiAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZHJlbiA9IHJvdXRlclN0YXRlWzFdXG4gIGNvbnN0IG9sZFBhcmFsbGVsUm91dGVzID0gb2xkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzXG4gIGNvbnN0IG5ld1BhcmFsbGVsUm91dGVzID0gbmV3IE1hcChvbGRQYXJhbGxlbFJvdXRlcylcbiAgZm9yIChsZXQgcGFyYWxsZWxSb3V0ZUtleSBpbiByb3V0ZXJTdGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3Qgcm91dGVyU3RhdGVDaGlsZDogRmxpZ2h0Um91dGVyU3RhdGUgPVxuICAgICAgcm91dGVyU3RhdGVDaGlsZHJlbltwYXJhbGxlbFJvdXRlS2V5XVxuICAgIGNvbnN0IHNlZ21lbnRDaGlsZCA9IHJvdXRlclN0YXRlQ2hpbGRbMF1cbiAgICBjb25zdCBzZWdtZW50S2V5Q2hpbGQgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50Q2hpbGQpXG4gICAgY29uc3Qgb2xkU2VnbWVudE1hcENoaWxkID0gb2xkUGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpXG4gICAgaWYgKG9sZFNlZ21lbnRNYXBDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBvbGRDYWNoZU5vZGVDaGlsZCA9IG9sZFNlZ21lbnRNYXBDaGlsZC5nZXQoc2VnbWVudEtleUNoaWxkKVxuICAgICAgaWYgKG9sZENhY2hlTm9kZUNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlQ2hpbGQgPSB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24oXG4gICAgICAgICAgb2xkQ2FjaGVOb2RlQ2hpbGQsXG4gICAgICAgICAgcm91dGVyU3RhdGVDaGlsZFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IG5ld1NlZ21lbnRNYXBDaGlsZCA9IG5ldyBNYXAob2xkU2VnbWVudE1hcENoaWxkKVxuICAgICAgICBuZXdTZWdtZW50TWFwQ2hpbGQuc2V0KHNlZ21lbnRLZXlDaGlsZCwgbmV3Q2FjaGVOb2RlQ2hpbGQpXG4gICAgICAgIG5ld1BhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBuZXdTZWdtZW50TWFwQ2hpbGQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBzaG93IHByZWZldGNoZWQgZGF0YSBpZiB0aGUgZHluYW1pYyBkYXRhIGlzIHN0aWxsIHBlbmRpbmcuXG4gIC8vXG4gIC8vIFRlaG5pY2FsbHksIHdoYXQgd2UncmUgYWN0dWFsbHkgY2hlY2tpbmcgaXMgd2hldGhlciB0aGUgZHluYW1pYyBuZXR3b3JrXG4gIC8vIHJlc3BvbnNlIHdhcyByZWNlaXZlZC4gQnV0IHNpbmNlIGl0J3MgYSBzdHJlYW1pbmcgcmVzcG9uc2UsIHRoaXMgZG9lcyBub3RcbiAgLy8gbWVhbiB0aGF0IGFsbCB0aGUgZHluYW1pYyBkYXRhIGhhcyBmdWxseSBzdHJlYW1lZCBpbi4gSXQganVzdCBtZWFucyB0aGF0XG4gIC8vIF9zb21lXyBvZiB0aGUgZHluYW1pYyBkYXRhIHdhcyByZWNlaXZlZC4gQnV0IGFzIGEgaGV1cmlzdGljLCB3ZSBhc3N1bWUgdGhhdFxuICAvLyB0aGUgcmVzdCBkeW5hbWljIGRhdGEgd2lsbCBzdHJlYW0gaW4gcXVpY2tseSwgc28gaXQncyBzdGlsbCBiZXR0ZXIgdG8gc2tpcFxuICAvLyB0aGUgcHJlZmV0Y2ggc3RhdGUuXG4gIGNvbnN0IHJzYyA9IG9sZENhY2hlTm9kZS5yc2NcbiAgY29uc3Qgc2hvdWxkVXNlUHJlZmV0Y2ggPSBpc0RlZmVycmVkUnNjKHJzYykgJiYgcnNjLnN0YXR1cyA9PT0gJ3BlbmRpbmcnXG5cbiAgcmV0dXJuIHtcbiAgICBsYXp5RGF0YTogbnVsbCxcbiAgICByc2MsXG4gICAgaGVhZDogb2xkQ2FjaGVOb2RlLmhlYWQsXG5cbiAgICBwcmVmZXRjaEhlYWQ6IHNob3VsZFVzZVByZWZldGNoID8gb2xkQ2FjaGVOb2RlLnByZWZldGNoSGVhZCA6IFtudWxsLCBudWxsXSxcbiAgICBwcmVmZXRjaFJzYzogc2hvdWxkVXNlUHJlZmV0Y2ggPyBvbGRDYWNoZU5vZGUucHJlZmV0Y2hSc2MgOiBudWxsLFxuICAgIGxvYWRpbmc6IG9sZENhY2hlTm9kZS5sb2FkaW5nLFxuXG4gICAgLy8gVGhlc2UgYXJlIHRoZSBjbG9uZWQgY2hpbGRyZW4gd2UgY29tcHV0ZWQgYWJvdmVcbiAgICBwYXJhbGxlbFJvdXRlczogbmV3UGFyYWxsZWxSb3V0ZXMsXG4gIH1cbn1cblxuY29uc3QgREVGRVJSRUQgPSBTeW1ib2woKVxuXG50eXBlIFBlbmRpbmdEZWZlcnJlZFJzYyA9IFByb21pc2U8UmVhY3QuUmVhY3ROb2RlPiAmIHtcbiAgc3RhdHVzOiAncGVuZGluZydcbiAgcmVzb2x2ZTogKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpID0+IHZvaWRcbiAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZFxuICB0YWc6IFN5bWJvbFxufVxuXG50eXBlIEZ1bGZpbGxlZERlZmVycmVkUnNjID0gUHJvbWlzZTxSZWFjdC5SZWFjdE5vZGU+ICYge1xuICBzdGF0dXM6ICdmdWxmaWxsZWQnXG4gIHZhbHVlOiBSZWFjdC5SZWFjdE5vZGVcbiAgcmVzb2x2ZTogKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpID0+IHZvaWRcbiAgcmVqZWN0OiAoZXJyb3I6IGFueSkgPT4gdm9pZFxuICB0YWc6IFN5bWJvbFxufVxuXG50eXBlIFJlamVjdGVkRGVmZXJyZWRSc2MgPSBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4gJiB7XG4gIHN0YXR1czogJ3JlamVjdGVkJ1xuICByZWFzb246IGFueVxuICByZXNvbHZlOiAodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkgPT4gdm9pZFxuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkXG4gIHRhZzogU3ltYm9sXG59XG5cbnR5cGUgRGVmZXJyZWRSc2MgPVxuICB8IFBlbmRpbmdEZWZlcnJlZFJzY1xuICB8IEZ1bGZpbGxlZERlZmVycmVkUnNjXG4gIHwgUmVqZWN0ZWREZWZlcnJlZFJzY1xuXG4vLyBUaGlzIHR5cGUgZXhpc3RzIHRvIGRpc3Rpbmd1aXNoIGEgRGVmZXJyZWRSc2MgZnJvbSBhIEZsaWdodCBwcm9taXNlLiBJdCdzIGFcbi8vIGNvbXByb21pc2UgdG8gYXZvaWQgYWRkaW5nIGFuIGV4dHJhIGZpZWxkIG9uIGV2ZXJ5IENhY2hlIE5vZGUsIHdoaWNoIHdvdWxkIGJlXG4vLyBhd2t3YXJkIGJlY2F1c2UgdGhlIHByZS1QUFIgcGFydHMgb2YgY29kZWJhc2Ugd291bGQgbmVlZCB0byBhY2NvdW50IGZvciBpdCxcbi8vIHRvby4gV2UgY2FuIHJlbW92ZSBpdCBvbmNlIHR5cGUgQ2FjaGUgTm9kZSB0eXBlIGlzIG1vcmUgc2V0dGxlZC5cbmZ1bmN0aW9uIGlzRGVmZXJyZWRSc2ModmFsdWU6IGFueSk6IHZhbHVlIGlzIERlZmVycmVkUnNjIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRhZyA9PT0gREVGRVJSRURcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRSc2MoKTogUGVuZGluZ0RlZmVycmVkUnNjIHtcbiAgbGV0IHJlc29sdmU6IGFueVxuICBsZXQgcmVqZWN0OiBhbnlcbiAgY29uc3QgcGVuZGluZ1JzYyA9IG5ldyBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlc1xuICAgIHJlamVjdCA9IHJlalxuICB9KSBhcyBQZW5kaW5nRGVmZXJyZWRSc2NcbiAgcGVuZGluZ1JzYy5zdGF0dXMgPSAncGVuZGluZydcbiAgcGVuZGluZ1JzYy5yZXNvbHZlID0gKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpID0+IHtcbiAgICBpZiAocGVuZGluZ1JzYy5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgY29uc3QgZnVsZmlsbGVkUnNjOiBGdWxmaWxsZWREZWZlcnJlZFJzYyA9IHBlbmRpbmdSc2MgYXMgYW55XG4gICAgICBmdWxmaWxsZWRSc2Muc3RhdHVzID0gJ2Z1bGZpbGxlZCdcbiAgICAgIGZ1bGZpbGxlZFJzYy52YWx1ZSA9IHZhbHVlXG4gICAgICByZXNvbHZlKHZhbHVlKVxuICAgIH1cbiAgfVxuICBwZW5kaW5nUnNjLnJlamVjdCA9IChlcnJvcjogYW55KSA9PiB7XG4gICAgaWYgKHBlbmRpbmdSc2Muc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgIGNvbnN0IHJlamVjdGVkUnNjOiBSZWplY3RlZERlZmVycmVkUnNjID0gcGVuZGluZ1JzYyBhcyBhbnlcbiAgICAgIHJlamVjdGVkUnNjLnN0YXR1cyA9ICdyZWplY3RlZCdcbiAgICAgIHJlamVjdGVkUnNjLnJlYXNvbiA9IGVycm9yXG4gICAgICByZWplY3QoZXJyb3IpXG4gICAgfVxuICB9XG4gIHBlbmRpbmdSc2MudGFnID0gREVGRVJSRURcbiAgcmV0dXJuIHBlbmRpbmdSc2Ncbn1cbiJdLCJuYW1lcyI6WyJhYm9ydFRhc2siLCJsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCIsInN0YXJ0UFBSTmF2aWdhdGlvbiIsInVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiIsIk1QQV9OQVZJR0FUSU9OX1RBU0siLCJyb3V0ZSIsIm5vZGUiLCJkeW5hbWljUmVxdWVzdFRyZWUiLCJjaGlsZHJlbiIsIm9sZENhY2hlTm9kZSIsIm9sZFJvdXRlclN0YXRlIiwibmV3Um91dGVyU3RhdGUiLCJwcmVmZXRjaERhdGEiLCJwcmVmZXRjaEhlYWQiLCJpc1ByZWZldGNoSGVhZFBhcnRpYWwiLCJpc1NhbWVQYWdlTmF2aWdhdGlvbiIsInNjcm9sbGFibGVTZWdtZW50c1Jlc3VsdCIsInNlZ21lbnRQYXRoIiwidXBkYXRlQ2FjaGVOb2RlT25OYXZpZ2F0aW9uIiwiZGlkRmluZFJvb3RMYXlvdXQiLCJvbGRSb3V0ZXJTdGF0ZUNoaWxkcmVuIiwibmV3Um91dGVyU3RhdGVDaGlsZHJlbiIsInByZWZldGNoRGF0YUNoaWxkcmVuIiwiaXNSb290TGF5b3V0Iiwib2xkUGFyYWxsZWxSb3V0ZXMiLCJwYXJhbGxlbFJvdXRlcyIsInByZWZldGNoUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJwYXRjaGVkUm91dGVyU3RhdGVDaGlsZHJlbiIsInRhc2tDaGlsZHJlbiIsIm5lZWRzRHluYW1pY1JlcXVlc3QiLCJkeW5hbWljUmVxdWVzdFRyZWVDaGlsZHJlbiIsInBhcmFsbGVsUm91dGVLZXkiLCJuZXdSb3V0ZXJTdGF0ZUNoaWxkIiwib2xkUm91dGVyU3RhdGVDaGlsZCIsIm9sZFNlZ21lbnRNYXBDaGlsZCIsImdldCIsInByZWZldGNoRGF0YUNoaWxkIiwibmV3U2VnbWVudENoaWxkIiwibmV3U2VnbWVudFBhdGhDaGlsZCIsImNvbmNhdCIsIm5ld1NlZ21lbnRLZXlDaGlsZCIsImNyZWF0ZVJvdXRlckNhY2hlS2V5Iiwib2xkU2VnbWVudENoaWxkIiwidW5kZWZpbmVkIiwib2xkQ2FjaGVOb2RlQ2hpbGQiLCJ0YXNrQ2hpbGQiLCJERUZBVUxUX1NFR01FTlRfS0VZIiwic3Bhd25SZXVzZWRUYXNrIiwiYmVnaW5SZW5kZXJpbmdOZXdSb3V0ZVRyZWUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwibWF0Y2hTZWdtZW50Iiwic2V0IiwibmV3Q2FjaGVOb2RlQ2hpbGQiLCJuZXdTZWdtZW50TWFwQ2hpbGQiLCJ0YXNrQ2hpbGRSb3V0ZSIsImR5bmFtaWNSZXF1ZXN0VHJlZUNoaWxkIiwibmV3Q2FjaGVOb2RlIiwibGF6eURhdGEiLCJyc2MiLCJwcmVmZXRjaFJzYyIsImhlYWQiLCJsb2FkaW5nIiwicGF0Y2hSb3V0ZXJTdGF0ZVdpdGhOZXdDaGlsZHJlbiIsInBvc3NpYmx5UGFydGlhbFByZWZldGNoSGVhZCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNyZWF0ZUNhY2hlTm9kZU9uTmF2aWdhdGlvbiIsInJvdXRlclN0YXRlIiwic3Bhd25QZW5kaW5nVGFzayIsInJvdXRlclN0YXRlQ2hpbGRyZW4iLCJpc1ByZWZldGNoUnNjUGFydGlhbCIsImlzTGVhZlNlZ21lbnQiLCJjYWNoZU5vZGVDaGlsZHJlbiIsInB1c2giLCJyb3V0ZXJTdGF0ZUNoaWxkIiwic2VnbWVudENoaWxkIiwic2VnbWVudFBhdGhDaGlsZCIsInNlZ21lbnRLZXlDaGlsZCIsImJhc2VSb3V0ZXJTdGF0ZSIsIm5ld0NoaWxkcmVuIiwiY2xvbmUiLCJuZXdUYXNrIiwiY3JlYXRlUGVuZGluZ0NhY2hlTm9kZSIsInJldXNlZFJvdXRlclN0YXRlIiwidGFzayIsInJlc3BvbnNlUHJvbWlzZSIsInRoZW4iLCJmbGlnaHREYXRhIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlIiwic2VydmVyUm91dGVyU3RhdGUiLCJzZWVkRGF0YSIsImR5bmFtaWNEYXRhIiwiZHluYW1pY0hlYWQiLCJ3cml0ZUR5bmFtaWNEYXRhSW50b1BlbmRpbmdUYXNrIiwiZXJyb3IiLCJyb290VGFzayIsImkiLCJzZWdtZW50IiwidGFza1NlZ21lbnQiLCJmaW5pc2hUYXNrVXNpbmdEeW5hbWljRGF0YVBheWxvYWQiLCJ0YXNrTm9kZSIsImZpbmlzaFBlbmRpbmdDYWNoZU5vZGUiLCJzZXJ2ZXJDaGlsZHJlbiIsImR5bmFtaWNEYXRhQ2hpbGRyZW4iLCJzZXJ2ZXJSb3V0ZXJTdGF0ZUNoaWxkIiwiZHluYW1pY0RhdGFDaGlsZCIsInNpemUiLCJtYXliZVByZWZldGNoUnNjIiwibWF5YmVQcmVmZXRjaExvYWRpbmciLCJjcmVhdGVEZWZlcnJlZFJzYyIsImNhY2hlTm9kZSIsInRhc2tTdGF0ZSIsInNlcnZlclN0YXRlIiwidGFza1N0YXRlQ2hpbGRyZW4iLCJzZXJ2ZXJTdGF0ZUNoaWxkcmVuIiwiZGF0YUNoaWxkcmVuIiwidGFza1N0YXRlQ2hpbGQiLCJzZXJ2ZXJTdGF0ZUNoaWxkIiwiZGF0YUNoaWxkIiwic2VnbWVudE1hcENoaWxkIiwidGFza1NlZ21lbnRDaGlsZCIsInRhc2tTZWdtZW50S2V5Q2hpbGQiLCJjYWNoZU5vZGVDaGlsZCIsImFib3J0UGVuZGluZ0NhY2hlTm9kZSIsImR5bmFtaWNTZWdtZW50RGF0YSIsImlzRGVmZXJyZWRSc2MiLCJyZXNvbHZlIiwidmFsdWVzIiwicmVqZWN0IiwibmV3UGFyYWxsZWxSb3V0ZXMiLCJzaG91bGRVc2VQcmVmZXRjaCIsInN0YXR1cyIsIkRFRkVSUkVEIiwiU3ltYm9sIiwidmFsdWUiLCJ0YWciLCJwZW5kaW5nUnNjIiwiUHJvbWlzZSIsInJlcyIsInJlaiIsImZ1bGZpbGxlZFJzYyIsInJlamVjdGVkUnNjIiwicmVhc29uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime, staleTime } = param;\n    if (staleTime !== -1) {\n        // `staleTime` is the value sent by the server during static generation.\n        // When this is available, it takes precedence over any of the heuristics\n        // that follow.\n        //\n        // TODO: When PPR is enabled, the server will *always* return a stale time\n        // when prefetching. We should never use a prefetch entry that hasn't yet\n        // received data from the server. So the only two cases should be 1) we use\n        // the server-generated stale time 2) the unresolved entry is discarded.\n        return Date.now() < prefetchTime + staleTime ? _routerreducertypes.PrefetchCacheEntryStatus.fresh : _routerreducertypes.PrefetchCacheEntryStatus.stale;\n    }\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHJlZmV0Y2gtY2FjaGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBK1lhQSxtQkFBbUI7ZUFBbkJBOztJQW5JR0MsOEJBQThCO2VBQTlCQTs7SUE5R0FDLDZCQUE2QjtlQUE3QkE7O0lBK05BQyxrQkFBa0I7ZUFBbEJBOzs7aURBMVhUO2dEQU1BOzZDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNsQixJQUFJQyxrQkFBa0JILElBQUlJLFFBQVE7SUFFbEMsNEZBQTRGO0lBQzVGLDhEQUE4RDtJQUM5RCxxRkFBcUY7SUFDckYsZ0ZBQWdGO0lBQ2hGLHFEQUFxRDtJQUNyRCxJQUFJSCxxQkFBcUI7UUFDdkIsMEVBQTBFO1FBQzFFLGtGQUFrRjtRQUNsRiw0Q0FBNEM7UUFDNUNFLG1CQUFtQkgsSUFBSUssTUFBTTtJQUMvQjtJQUVBLElBQUlILFFBQVE7UUFDVixPQUFRLEtBQUVBLFNBQVNKLGdDQUFnQ0s7SUFDckQ7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0csdUJBQ1BOLEdBQVEsRUFDUk8sSUFBOEIsRUFDOUJDLE9BQXVCO0lBRXZCLE9BQU9ULDJCQUEyQkMsS0FBS08sU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFRjtBQUNyRTtBQUVBLFNBQVNHLHNCQUNQWCxHQUFRLEVBQ1JPLElBQTJDLEVBQzNDQyxPQUFzQixFQUN0QkksYUFBOEMsRUFDOUNDLGFBQXNCO0lBSHRCTixJQUFBQSxTQUFBQSxLQUFBQSxHQUFBQSxPQUFxQkUsb0JBQUFBLFlBQVksQ0FBQ0ssU0FBUztJQUszQyw4RUFBOEU7SUFD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QUM1RSxzREFBc0Q7SUFDdEQsSUFBSTFELFNBQVNFLG9CQUFBQSxZQUFZLENBQUN3RSxJQUFJLEVBQUU7UUFDOUIsSUFBSXJCLEtBQUtDLEdBQUcsS0FBS0YsZUFBZWpFLHFCQUFxQjtZQUNuRCxPQUFPc0Usb0JBQUFBLHdCQUF3QixDQUFDZSxLQUFLO1FBQ3ZDO0lBQ0Y7SUFFQSxpR0FBaUc7SUFDakcsSUFBSXhFLFNBQVNFLG9CQUFBQSxZQUFZLENBQUNDLElBQUksRUFBRTtRQUM5QixJQUFJa0QsS0FBS0MsR0FBRyxLQUFLRixlQUFlakUscUJBQXFCO1lBQ25ELE9BQU9zRSxvQkFBQUEsd0JBQXdCLENBQUNnQixRQUFRO1FBQzFDO0lBQ0Y7SUFFQSxPQUFPaEIsb0JBQUFBLHdCQUF3QixDQUFDVSxPQUFPO0FBQ3pDIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3ByZWZldGNoLWNhY2hlLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGZldGNoU2VydmVyUmVzcG9uc2UsXG4gIHR5cGUgRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCxcbn0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBQcmVmZXRjaEtpbmQsXG4gIHR5cGUgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuXG5jb25zdCBJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUiA9ICclJ1xuXG5leHBvcnQgdHlwZSBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5ID0gUHJlZmV0Y2hDYWNoZUVudHJ5ICYge1xuICAvKiogVGhpcyBpcyBhIHNwZWNpYWwgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgYSBwcmVmZXRjaCBlbnRyeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgVVJMXG4gICAqIHdhcyByZXR1cm5lZCByYXRoZXIgdGhhbiB0aGUgcmVxdWVzdGVkIFVSTC4gVGhpcyBzaWduYWxzIHRvIHRoZSByb3V0ZXIgdGhhdCBpdCBzaG91bGQgb25seVxuICAgKiBhcHBseSB0aGUgcGFydCB0aGF0IGRvZXNuJ3QgZGVwZW5kIG9uIHNlYXJjaFBhcmFtcyAoc3BlY2lmaWNhbGx5IHRoZSBsb2FkaW5nIHN0YXRlKS5cbiAgICovXG4gIGFsaWFzZWQ/OiBib29sZWFuXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNhY2hlIGtleSBmb3IgdGhlIHJvdXRlciBwcmVmZXRjaCBjYWNoZVxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIGJlaW5nIG5hdmlnYXRlZCB0b1xuICogQHBhcmFtIG5leHRVcmwgLSBhbiBpbnRlcm5hbCBVUkwsIHByaW1hcmlseSB1c2VkIGZvciBoYW5kbGluZyByZXdyaXRlcy4gRGVmYXVsdHMgdG8gJy8nLlxuICogQHJldHVybiBUaGUgZ2VuZXJhdGVkIHByZWZldGNoIGNhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gIHVybDogVVJMLFxuICBpbmNsdWRlU2VhcmNoUGFyYW1zOiBib29sZWFuLFxuICBwcmVmaXg/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgLy8gSW5pdGlhbGx5IHdlIG9ubHkgdXNlIHRoZSBwYXRobmFtZSBhcyB0aGUgY2FjaGUga2V5LiBXZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgLy8gc2VhcmNoIHBhcmFtcyBzbyB0aGF0IG11bHRpcGxlIFVSTHMgd2l0aCB0aGUgc2FtZSBzZWFyY2ggcGFyYW1ldGVyIGNhbiByZS11c2VcbiAgLy8gbG9hZGluZyBzdGF0ZXMuXG4gIGxldCBwYXRobmFtZUZyb21VcmwgPSB1cmwucGF0aG5hbWVcblxuICAvLyBSU0MgcmVzcG9uc2VzIGNhbiBkaWZmZXIgYmFzZWQgb24gc2VhcmNoIHBhcmFtcywgc3BlY2lmaWNhbGx5IGluIHRoZSBjYXNlIHdoZXJlIHdlIGFyZW4ndFxuICAvLyByZXR1cm5pbmcgYSBwYXJ0aWFsIHJlc3BvbnNlIChpZSB3aXRoIGBQcmVmZXRjaEtpbmQuQVVUT2ApLlxuICAvLyBJbiB0aGUgYXV0byBjYXNlLCBzaW5jZSBsb2FkaW5nLmpzICYgbGF5b3V0LmpzIHdvbid0IGhhdmUgYWNjZXNzIHRvIHNlYXJjaCBwYXJhbXMsXG4gIC8vIHdlIGNhbiBzYWZlbHkgcmUtdXNlIHRoYXQgY2FjaGUgZW50cnkuIEJ1dCBmb3IgZnVsbCBwcmVmZXRjaGVzLCB3ZSBzaG91bGQgbm90XG4gIC8vIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgYXMgdGhlIHJlc3BvbnNlIG1heSBkaWZmZXIuXG4gIGlmIChpbmNsdWRlU2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiBpbmNsdWRlIHRoZSBzZWFyY2ggcGFyYW0gaW4gdGhlIGtleSxcbiAgICAvLyBhcyB3ZSdsbCBiZSBnZXR0aW5nIGJhY2sgYSBmdWxsIHJlc3BvbnNlLiBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgcmVhZCB0aGUgc2VhcmNoXG4gICAgLy8gcGFyYW1zIHdoZW4gZ2VuZXJhdGluZyB0aGUgZnVsbCByZXNwb25zZS5cbiAgICBwYXRobmFtZUZyb21VcmwgKz0gdXJsLnNlYXJjaFxuICB9XG5cbiAgaWYgKHByZWZpeCkge1xuICAgIHJldHVybiBgJHtwcmVmaXh9JHtJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUn0ke3BhdGhuYW1lRnJvbVVybH1gXG4gIH1cblxuICByZXR1cm4gcGF0aG5hbWVGcm9tVXJsXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkoXG4gIHVybDogVVJMLFxuICBraW5kOiBQcmVmZXRjaEtpbmQgfCB1bmRlZmluZWQsXG4gIG5leHRVcmw/OiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgcmV0dXJuIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKHVybCwga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwsIG5leHRVcmwpXG59XG5cbmZ1bmN0aW9uIGdldEV4aXN0aW5nQ2FjaGVFbnRyeShcbiAgdXJsOiBVUkwsXG4gIGtpbmQ6IFByZWZldGNoS2luZCA9IFByZWZldGNoS2luZC5URU1QT1JBUlksXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGwsXG4gIHByZWZldGNoQ2FjaGU6IE1hcDxzdHJpbmcsIFByZWZldGNoQ2FjaGVFbnRyeT4sXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbik6IEFsaWFzZWRQcmVmZXRjaENhY2hlRW50cnkgfCB1bmRlZmluZWQge1xuICAvLyBXZSBmaXJzdCBjaGVjayBpZiB0aGVyZSdzIGEgbW9yZSBzcGVjaWZpYyBpbnRlcmNlcHRpb24gcm91dGUgcHJlZmV0Y2ggZW50cnlcbiAgLy8gVGhpcyBpcyBiZWNhdXNlIHdoZW4gd2UgZGV0ZWN0IGEgcHJlZmV0Y2ggdGhhdCBjb3JyZXNwb25kcyB3aXRoIGFuIGludGVyY2VwdGlvbiByb3V0ZSwgd2UgcHJlZml4IGl0IHdpdGggbmV4dFVybCAoc2VlIGBjcmVhdGVQcmVmZXRjaENhY2hlS2V5YClcbiAgLy8gdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgcGFnZXMgdGhhdCBtYXkgaGF2ZSB0aGUgc2FtZSBVUkwgYnV0IHJlbmRlciBkaWZmZXJlbnQgdGhpbmdzIGRlcGVuZGluZyBvbiB0aGUgYE5leHQtVVJMYCBoZWFkZXIuXG4gIGZvciAoY29uc3QgbWF5YmVOZXh0VXJsIG9mIFtuZXh0VXJsLCBudWxsXSkge1xuICAgIGNvbnN0IGNhY2hlS2V5V2l0aFBhcmFtcyA9IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICAgICAgdXJsLFxuICAgICAgdHJ1ZSxcbiAgICAgIG1heWJlTmV4dFVybFxuICAgIClcbiAgICBjb25zdCBjYWNoZUtleVdpdGhvdXRQYXJhbXMgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgICAgIHVybCxcbiAgICAgIGZhbHNlLFxuICAgICAgbWF5YmVOZXh0VXJsXG4gICAgKVxuXG4gICAgLy8gRmlyc3QsIHdlIGNoZWNrIGlmIHdlIGhhdmUgYSBjYWNoZSBlbnRyeSB0aGF0IGV4YWN0bHkgbWF0Y2hlcyB0aGUgVVJMXG4gICAgY29uc3QgY2FjaGVLZXlUb1VzZSA9IHVybC5zZWFyY2hcbiAgICAgID8gY2FjaGVLZXlXaXRoUGFyYW1zXG4gICAgICA6IGNhY2hlS2V5V2l0aG91dFBhcmFtc1xuXG4gICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KGNhY2hlS2V5VG9Vc2UpXG4gICAgaWYgKGV4aXN0aW5nRW50cnkgJiYgYWxsb3dBbGlhc2luZykge1xuICAgICAgLy8gV2Uga25vdyB3ZSdyZSByZXR1cm5pbmcgYW4gYWxpYXNlZCBlbnRyeSB3aGVuIHRoZSBwYXRobmFtZSBtYXRjaGVzIGJ1dCB0aGUgc2VhcmNoIHBhcmFtcyBkb24ndCxcbiAgICAgIGNvbnN0IGlzQWxpYXNlZCA9XG4gICAgICAgIGV4aXN0aW5nRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgZXhpc3RpbmdFbnRyeS51cmwuc2VhcmNoICE9PSB1cmwuc2VhcmNoXG5cbiAgICAgIGlmIChpc0FsaWFzZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5leGlzdGluZ0VudHJ5LFxuICAgICAgICAgIGFsaWFzZWQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nRW50cnlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBjb250YWlucyBzZWFyY2ggcGFyYW1zLCBhbmQgd2UncmUgbm90IGRvaW5nIGEgZnVsbCBwcmVmZXRjaCwgd2UgY2FuIHJldHVybiB0aGVcbiAgICAvLyBwYXJhbS1sZXNzIGVudHJ5IGlmIGl0IGV4aXN0cy5cbiAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IGNvdmVyZWQgYnkgdGhlIGNoZWNrIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmdW5jdGlvbiwgd2hpY2ggaXRlcmF0ZXMgb3ZlciBjYWNoZSBlbnRyaWVzLFxuICAgIC8vIGJ1dCBsZXRzIHVzIGFycml2ZSB0aGVyZSBxdWlja2VyIGluIHRoZSBwYXJhbS1mdWxsIGNhc2UuXG4gICAgY29uc3QgZW50cnlXaXRob3V0UGFyYW1zID0gcHJlZmV0Y2hDYWNoZS5nZXQoY2FjaGVLZXlXaXRob3V0UGFyYW1zKVxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAgICBhbGxvd0FsaWFzaW5nICYmXG4gICAgICB1cmwuc2VhcmNoICYmXG4gICAgICBraW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAgZW50cnlXaXRob3V0UGFyYW1zICYmXG4gICAgICAvLyBXZSBzaG91bGRuJ3QgcmV0dXJuIHRoZSBhbGlhc2VkIGVudHJ5IGlmIGl0IHdhcyByZWxvY2F0ZWQgdG8gYSBuZXcgY2FjaGUga2V5LlxuICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAhZW50cnlXaXRob3V0UGFyYW1zLmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICApIHtcbiAgICAgIHJldHVybiB7IC4uLmVudHJ5V2l0aG91dFBhcmFtcywgYWxpYXNlZDogdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UndmUgZ290dGVuIHRvIHRoaXMgcG9pbnQsIHdlIGRpZG4ndCBmaW5kIGEgc3BlY2lmaWMgY2FjaGUgZW50cnkgdGhhdCBtYXRjaGVkXG4gIC8vIHRoZSByZXF1ZXN0IFVSTC5cbiAgLy8gV2UgYXR0ZW1wdCBhIHBhcnRpYWwgbWF0Y2ggYnkgY2hlY2tpbmcgaWYgdGhlcmUncyBhIGNhY2hlIGVudHJ5IHdpdGggdGhlIHNhbWUgcGF0aG5hbWUuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCB3ZSBmaW5kLCBzaW5jZSBpdCBkb2Vzbid0IGNvcnJlc3BvbmQgd2l0aCB0aGUgcmVxdWVzdGVkIFVSTCwgd2UnbGwgbWFyayBpdCBcImFsaWFzZWRcIi5cbiAgLy8gVGhpcyB3aWxsIHNpZ25hbCB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHkgYXBwbHkgdGhlIGxvYWRpbmcgc3RhdGUgb24gdGhlIHByZWZldGNoZWQgZGF0YS5cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmXG4gICAga2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICBhbGxvd0FsaWFzaW5nXG4gICkge1xuICAgIGZvciAoY29uc3QgY2FjaGVFbnRyeSBvZiBwcmVmZXRjaENhY2hlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNhY2hlRW50cnkudXJsLnBhdGhuYW1lID09PSB1cmwucGF0aG5hbWUgJiZcbiAgICAgICAgLy8gV2Ugc2hvdWxkbid0IHJldHVybiB0aGUgYWxpYXNlZCBlbnRyeSBpZiBpdCB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGNhY2hlIGtleS5cbiAgICAgICAgLy8gU2luY2UgaXQncyByZXdyaXR0ZW4sIGl0IGNvdWxkIHJlc3BvbmQgd2l0aCBhIGNvbXBsZXRlbHkgZGlmZmVyZW50IGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICFjYWNoZUVudHJ5LmtleS5pbmNsdWRlcyhJTlRFUkNFUFRJT05fQ0FDSEVfS0VZX01BUktFUilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4geyAuLi5jYWNoZUVudHJ5LCBhbGlhc2VkOiB0cnVlIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZldGNoIGNhY2hlIGVudHJ5IGlmIG9uZSBleGlzdHMuIE90aGVyd2lzZSBjcmVhdGVzIGEgbmV3IG9uZSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0XG4gKiB0byByZXRyaWV2ZSB0aGUgcHJlZmV0Y2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIHVybCxcbiAgbmV4dFVybCxcbiAgdHJlZSxcbiAgcHJlZmV0Y2hDYWNoZSxcbiAga2luZCxcbiAgYWxsb3dBbGlhc2luZyA9IHRydWUsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZScgfCAndHJlZSc+ICYge1xuICB1cmw6IFVSTFxuICBraW5kPzogUHJlZmV0Y2hLaW5kXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbn0pOiBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5IHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gZ2V0RXhpc3RpbmdDYWNoZUVudHJ5KFxuICAgIHVybCxcbiAgICBraW5kLFxuICAgIG5leHRVcmwsXG4gICAgcHJlZmV0Y2hDYWNoZSxcbiAgICBhbGxvd0FsaWFzaW5nXG4gIClcblxuICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgLy8gR3JhYiB0aGUgbGF0ZXN0IHN0YXR1cyBvZiB0aGUgY2FjaGUgZW50cnkgYW5kIHVwZGF0ZSBpdFxuICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGF0dXMgPSBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMoZXhpc3RpbmdDYWNoZUVudHJ5KVxuXG4gICAgLy8gd2hlbiBga2luZGAgaXMgcHJvdmlkZWQsIGFuIGV4cGxpY2l0IHByZWZldGNoIHdhcyByZXF1ZXN0ZWQuXG4gICAgLy8gaWYgdGhlIHJlcXVlc3RlZCBwcmVmZXRjaCBpcyBcImZ1bGxcIiBhbmQgdGhlIGN1cnJlbnQgY2FjaGUgZW50cnkgd2Fzbid0LCB3ZSB3YW50IHRvIHJlLXByZWZldGNoIHdpdGggdGhlIG5ldyBpbnRlbnRcbiAgICBjb25zdCBzd2l0Y2hlZFRvRnVsbFByZWZldGNoID1cbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kICE9PSBQcmVmZXRjaEtpbmQuRlVMTCAmJlxuICAgICAga2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTExcblxuICAgIGlmIChzd2l0Y2hlZFRvRnVsbFByZWZldGNoKSB7XG4gICAgICAvLyBJZiB3ZSBzd2l0Y2hlZCB0byBhIGZ1bGwgcHJlZmV0Y2gsIHZhbGlkYXRlIHRoYXQgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGNvbnRhaW5lZCBwYXJ0aWFsIGRhdGEuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNhY2hlIGVudHJ5IHdhcyBzZWVkZWQgd2l0aCBmdWxsIGRhdGEgYnV0IGhhcyBhIGNhY2hlIHR5cGUgb2YgXCJhdXRvXCIgKGllIHdoZW4gY2FjaGUgZW50cmllc1xuICAgICAgLy8gYXJlIHNlZWRlZCBidXQgd2l0aG91dCBhIHByZWZldGNoIGludGVudClcbiAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5kYXRhLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNGdWxsUHJlZmV0Y2ggPVxuICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlZmV0Y2hSZXNwb25zZS5mbGlnaHREYXRhKSAmJlxuICAgICAgICAgIHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YS5zb21lKChmbGlnaHREYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHJlbmRlcmluZyBmcm9tIHRoZSByb290IGFuZCB3ZSByZXR1cm5lZCBSU0MgZGF0YSAoc2VlZERhdGEpLCB3ZSBhbHJlYWR5IGhhZCBhIGZ1bGwgcHJlZmV0Y2guXG4gICAgICAgICAgICByZXR1cm4gZmxpZ2h0RGF0YS5pc1Jvb3RSZW5kZXIgJiYgZmxpZ2h0RGF0YS5zZWVkRGF0YSAhPT0gbnVsbFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCFpc0Z1bGxQcmVmZXRjaCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFuIGV4cGxpY2l0IHByZWZldGNoIGtpbmQsIHdlIHdhbnQgdG8gc2V0IGEgdGVtcG9yYXJ5IGtpbmRcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFzc3VtaW5nIHRoZSBzYW1lIGludGVudCBhcyB0aGUgcHJldmlvdXMgZW50cnksIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBob3cgd2VcbiAgICAgICAgICAgIC8vIGxhemlseSBjcmVhdGUgcHJlZmV0Y2ggZW50cmllcyB3aGVuIGludGVudCBpcyBsZWZ0IHVuc3BlY2lmaWVkLlxuICAgICAgICAgICAga2luZDoga2luZCA/PyBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGV4aXN0aW5nIGNhY2hlIGVudHJ5IHdhcyBtYXJrZWQgYXMgdGVtcG9yYXJ5LCBpdCBtZWFucyBpdCB3YXMgbGF6aWx5IGNyZWF0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIGdldCBhbiBlbnRyeSxcbiAgICAvLyB3aGVyZSB3ZSBkaWRuJ3QgaGF2ZSB0aGUgcHJlZmV0Y2ggaW50ZW50LiBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBpbnRlbnQgKGluIGBraW5kYCksIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBlbnRyeSB0byB0aGUgbW9yZSBhY2N1cmF0ZSBraW5kLlxuICAgIGlmIChraW5kICYmIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID09PSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZKSB7XG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9IGtpbmRcbiAgICB9XG5cbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgdGhlIGV4aXN0aW5nIGVudHJ5IHdlIGZvdW5kIGlzIHN0aWxsIHZhbGlkLCBzbyB3ZSByZXR1cm4gaXQuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2FjaGVFbnRyeVxuICB9XG5cbiAgLy8gSWYgd2UgZGlkbid0IHJldHVybiBhbiBlbnRyeSwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgcmV0dXJuIGNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5KHtcbiAgICB0cmVlLFxuICAgIHVybCxcbiAgICBuZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAga2luZDoga2luZCB8fCBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICB9KVxufVxuXG4vKlxuICogVXNlZCB0byB0YWtlIGFuIGV4aXN0aW5nIGNhY2hlIGVudHJ5IGFuZCBwcmVmaXggaXQgd2l0aCB0aGUgbmV4dFVybCwgaWYgaXQgZXhpc3RzLlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBjb25mbGljdGluZyBjYWNoZSBlbnRyaWVzIGZvciB0aGUgc2FtZSBVUkwgKGFzIGlzIHRoZSBjYXNlIHdpdGggcm91dGUgaW50ZXJjZXB0aW9uKS5cbiAqL1xuZnVuY3Rpb24gcHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkoe1xuICB1cmwsXG4gIG5leHRVcmwsXG4gIHByZWZldGNoQ2FjaGUsXG4gIGV4aXN0aW5nQ2FjaGVLZXksXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBleGlzdGluZ0NhY2hlS2V5OiBzdHJpbmdcbn0pIHtcbiAgY29uc3QgZXhpc3RpbmdDYWNoZUVudHJ5ID0gcHJlZmV0Y2hDYWNoZS5nZXQoZXhpc3RpbmdDYWNoZUtleSlcbiAgaWYgKCFleGlzdGluZ0NhY2hlRW50cnkpIHtcbiAgICAvLyBuby1vcCAtLSB0aGVyZSB3YXNuJ3QgYW4gZW50cnkgdG8gbW92ZVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbmV3Q2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KFxuICAgIHVybCxcbiAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCxcbiAgICBuZXh0VXJsXG4gIClcbiAgcHJlZmV0Y2hDYWNoZS5zZXQobmV3Q2FjaGVLZXksIHsgLi4uZXhpc3RpbmdDYWNoZUVudHJ5LCBrZXk6IG5ld0NhY2hlS2V5IH0pXG4gIHByZWZldGNoQ2FjaGUuZGVsZXRlKGV4aXN0aW5nQ2FjaGVLZXkpXG5cbiAgcmV0dXJuIG5ld0NhY2hlS2V5XG59XG5cbi8qKlxuICogVXNlIHRvIHNlZWQgdGhlIHByZWZldGNoIGNhY2hlIHdpdGggZGF0YSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSh7XG4gIG5leHRVcmwsXG4gIHRyZWUsXG4gIHByZWZldGNoQ2FjaGUsXG4gIHVybCxcbiAgZGF0YSxcbiAga2luZCxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGRhdGE6IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHRcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59KSB7XG4gIC8vIFRoZSBpbml0aWFsIGNhY2hlIGVudHJ5IHRlY2huaWNhbGx5IGluY2x1ZGVzIGZ1bGwgZGF0YSwgYnV0IGl0IGlzbid0IGV4cGxpY2l0bHkgcHJlZmV0Y2hlZCAtLSB3ZSBqdXN0IHNlZWQgdGhlXG4gIC8vIHByZWZldGNoIGNhY2hlIHNvIHRoYXQgd2UgY2FuIHNraXAgYW4gZXh0cmEgcHJlZmV0Y2ggcmVxdWVzdCBsYXRlciwgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIHRoZSBkYXRhLlxuICAvLyBpZiB0aGUgcHJlZmV0Y2ggY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHVzZSB0aGUgbmV4dFVybCB0byBwcmVmaXggdGhlIGNhY2hlIGtleVxuICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gZGF0YS5jb3VsZEJlSW50ZXJjZXB0ZWRcbiAgICA/IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kLCBuZXh0VXJsKVxuICAgIDogY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpXG5cbiAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICBkYXRhOiBQcm9taXNlLnJlc29sdmUoZGF0YSksXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBEYXRlLm5vdygpLFxuICAgIHN0YWxlVGltZTogLTEsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfSBzYXRpc2ZpZXMgUHJlZmV0Y2hDYWNoZUVudHJ5XG5cbiAgcHJlZmV0Y2hDYWNoZS5zZXQocHJlZmV0Y2hDYWNoZUtleSwgcHJlZmV0Y2hFbnRyeSlcblxuICByZXR1cm4gcHJlZmV0Y2hFbnRyeVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwcmVmZXRjaCBlbnRyeSBlbnRyeSBhbmQgZW5xdWV1ZXMgYSBmZXRjaCByZXF1ZXN0IHRvIHJldHJpZXZlIHRoZSBkYXRhLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gIHVybCxcbiAga2luZCxcbiAgdHJlZSxcbiAgbmV4dFVybCxcbiAgcHJlZmV0Y2hDYWNoZSxcbn06IFBpY2s8UmVhZG9ubHlSZWR1Y2VyU3RhdGUsICduZXh0VXJsJyB8ICd0cmVlJyB8ICdwcmVmZXRjaENhY2hlJz4gJiB7XG4gIHVybDogVVJMXG4gIGtpbmQ6IFByZWZldGNoS2luZFxufSk6IFByZWZldGNoQ2FjaGVFbnRyeSB7XG4gIGNvbnN0IHByZWZldGNoQ2FjaGVLZXkgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZClcblxuICAvLyBpbml0aWF0ZXMgdGhlIGZldGNoIHJlcXVlc3QgZm9yIHRoZSBwcmVmZXRjaCBhbmQgYXR0YWNoZXMgYSBsaXN0ZW5lclxuICAvLyB0byB0aGUgcHJvbWlzZSB0byB1cGRhdGUgdGhlIHByZWZldGNoIGNhY2hlIGVudHJ5IHdoZW4gdGhlIHByb21pc2UgcmVzb2x2ZXMgKGlmIG5lY2Vzc2FyeSlcbiAgY29uc3QgZGF0YSA9IHByZWZldGNoUXVldWUuZW5xdWV1ZSgoKSA9PlxuICAgIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCB7XG4gICAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogdHJlZSxcbiAgICAgIG5leHRVcmwsXG4gICAgICBwcmVmZXRjaEtpbmQ6IGtpbmQsXG4gICAgfSkudGhlbigocHJlZmV0Y2hSZXNwb25zZSkgPT4ge1xuICAgICAgLy8gVE9ETzogYGZldGNoU2VydmVyUmVzcG9uc2VgIHNob3VsZCBiZSBtb3JlIHRpZ2hseSBjb3VwbGVkIHRvIHRoZXNlIHByZWZldGNoIGNhY2hlIG9wZXJhdGlvbnNcbiAgICAgIC8vIHRvIGF2b2lkIGRyaWZ0IGJldHdlZW4gdGhpcyBjYWNoZSBrZXkgcHJlZml4aW5nIGxvZ2ljXG4gICAgICAvLyAod2hpY2ggaXMgY3VycmVudGx5IGRpcmVjdGx5IGluZmx1ZW5jZWQgYnkgdGhlIHNlcnZlciByZXNwb25zZSlcbiAgICAgIGxldCBuZXdDYWNoZUtleVxuXG4gICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5jb3VsZEJlSW50ZXJjZXB0ZWQpIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBjYWNoZSBrZXkgd2l0aCB0aGUgbmV4dFVybFxuICAgICAgICBuZXdDYWNoZUtleSA9IHByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICAgICAgICBuZXh0VXJsLFxuICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwcmVmZXRjaCB3YXMgYSBjYWNoZSBoaXQsIHdlIHdhbnQgdG8gdXBkYXRlIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB0byByZWZsZWN0IHRoYXQgaXQgd2FzIGEgZnVsbCBwcmVmZXRjaC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYSBzdGF0aWMgcmVzcG9uc2Ugd2lsbCBjb250YWluIHRoZSBmdWxsIFJTQyBwYXlsb2FkLCBhbmQgY2FuIGJlIHVwZGF0ZWQgdG8gcmVzcGVjdCB0aGUgYHN0YXRpY2BcbiAgICAgIC8vIHN0YWxlVGltZS5cbiAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnByZXJlbmRlcmVkKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KFxuICAgICAgICAgIC8vIGlmIHdlIHByZWZpeGVkIHRoZSBjYWNoZSBrZXkgZHVlIHRvIHJvdXRlIGludGVyY2VwdGlvbiwgd2Ugd2FudCB0byB1c2UgdGhlIG5ldyBrZXkuIE90aGVyd2lzZSB3ZSB1c2UgdGhlIG9yaWdpbmFsIGtleVxuICAgICAgICAgIG5ld0NhY2hlS2V5ID8/IHByZWZldGNoQ2FjaGVLZXlcbiAgICAgICAgKVxuICAgICAgICBpZiAoZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgICAgICAgIGlmIChwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHN0YWxlIHRpbWUgdGhhdCB3YXMgY29sbGVjdGVkIGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nXG4gICAgICAgICAgICAvLyBzdGF0aWMgZ2VuZXJhdGlvbi4gVXNlIHRoaXMgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgc3RhbGUgdGltZS5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5zdGFsZVRpbWUgPSBwcmVmZXRjaFJlc3BvbnNlLnN0YWxlVGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlZmV0Y2hSZXNwb25zZVxuICAgIH0pXG4gIClcblxuICBjb25zdCBwcmVmZXRjaEVudHJ5ID0ge1xuICAgIHRyZWVBdFRpbWVPZlByZWZldGNoOiB0cmVlLFxuICAgIGRhdGEsXG4gICAga2luZCxcbiAgICBwcmVmZXRjaFRpbWU6IERhdGUubm93KCksXG4gICAgbGFzdFVzZWRUaW1lOiBudWxsLFxuICAgIHN0YWxlVGltZTogLTEsXG4gICAga2V5OiBwcmVmZXRjaENhY2hlS2V5LFxuICAgIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoLFxuICAgIHVybCxcbiAgfVxuXG4gIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpXG5cbiAgcmV0dXJuIHByZWZldGNoRW50cnlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBydW5lUHJlZmV0Y2hDYWNoZShcbiAgcHJlZmV0Y2hDYWNoZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGVbJ3ByZWZldGNoQ2FjaGUnXVxuKSB7XG4gIGZvciAoY29uc3QgW2hyZWYsIHByZWZldGNoQ2FjaGVFbnRyeV0gb2YgcHJlZmV0Y2hDYWNoZSkge1xuICAgIGlmIChcbiAgICAgIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyhwcmVmZXRjaENhY2hlRW50cnkpID09PVxuICAgICAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbiAgICApIHtcbiAgICAgIHByZWZldGNoQ2FjaGUuZGVsZXRlKGhyZWYpXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZXNlIHZhbHVlcyBhcmUgc2V0IGJ5IGBkZWZpbmUtZW52LXBsdWdpbmAgKGJhc2VkIG9uIGBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5zdGFsZVRpbWVzYClcbi8vIGFuZCBkZWZhdWx0IHRvIDUgbWludXRlcyAoc3RhdGljKSAvIDAgc2Vjb25kcyAoZHluYW1pYylcbmNvbnN0IERZTkFNSUNfU1RBTEVUSU1FX01TID1cbiAgTnVtYmVyKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FKSAqIDEwMDBcblxuZXhwb3J0IGNvbnN0IFNUQVRJQ19TVEFMRVRJTUVfTVMgPVxuICBOdW1iZXIocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSkgKiAxMDAwXG5cbmZ1bmN0aW9uIGdldFByZWZldGNoRW50cnlDYWNoZVN0YXR1cyh7XG4gIGtpbmQsXG4gIHByZWZldGNoVGltZSxcbiAgbGFzdFVzZWRUaW1lLFxuICBzdGFsZVRpbWUsXG59OiBQcmVmZXRjaENhY2hlRW50cnkpOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMge1xuICBpZiAoc3RhbGVUaW1lICE9PSAtMSkge1xuICAgIC8vIGBzdGFsZVRpbWVgIGlzIHRoZSB2YWx1ZSBzZW50IGJ5IHRoZSBzZXJ2ZXIgZHVyaW5nIHN0YXRpYyBnZW5lcmF0aW9uLlxuICAgIC8vIFdoZW4gdGhpcyBpcyBhdmFpbGFibGUsIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBhbnkgb2YgdGhlIGhldXJpc3RpY3NcbiAgICAvLyB0aGF0IGZvbGxvdy5cbiAgICAvL1xuICAgIC8vIFRPRE86IFdoZW4gUFBSIGlzIGVuYWJsZWQsIHRoZSBzZXJ2ZXIgd2lsbCAqYWx3YXlzKiByZXR1cm4gYSBzdGFsZSB0aW1lXG4gICAgLy8gd2hlbiBwcmVmZXRjaGluZy4gV2Ugc2hvdWxkIG5ldmVyIHVzZSBhIHByZWZldGNoIGVudHJ5IHRoYXQgaGFzbid0IHlldFxuICAgIC8vIHJlY2VpdmVkIGRhdGEgZnJvbSB0aGUgc2VydmVyLiBTbyB0aGUgb25seSB0d28gY2FzZXMgc2hvdWxkIGJlIDEpIHdlIHVzZVxuICAgIC8vIHRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHN0YWxlIHRpbWUgMikgdGhlIHVucmVzb2x2ZWQgZW50cnkgaXMgZGlzY2FyZGVkLlxuICAgIHJldHVybiBEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgc3RhbGVUaW1lXG4gICAgICA/IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaFxuICAgICAgOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuc3RhbGVcbiAgfVxuXG4gIC8vIFdlIHdpbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byB0aGUgYGR5bmFtaWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChEYXRlLm5vdygpIDwgKGxhc3RVc2VkVGltZSA/PyBwcmVmZXRjaFRpbWUpICsgRFlOQU1JQ19TVEFMRVRJTUVfTVMpIHtcbiAgICByZXR1cm4gbGFzdFVzZWRUaW1lXG4gICAgICA/IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgICAgOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZnJlc2hcbiAgfVxuXG4gIC8vIEZvciBcImF1dG9cIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIG9ubHkgdGhlIGxvYWRpbmcgYm91bmRhcnkgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIC8vIEEgc3RhbGUgZW50cnkgd2lsbCBvbmx5IHJlLXVzZSB0aGUgYGxvYWRpbmdgIGJvdW5kYXJ5LCBub3QgdGhlIGZ1bGwgZGF0YS5cbiAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBcImxhenkgZmV0Y2hcIiBmb3IgdGhlIGZ1bGwgZGF0YS5cbiAgaWYgKGtpbmQgPT09IFByZWZldGNoS2luZC5BVVRPKSB7XG4gICAgaWYgKERhdGUubm93KCkgPCBwcmVmZXRjaFRpbWUgKyBTVEFUSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlXG4gICAgfVxuICB9XG5cbiAgLy8gZm9yIFwiZnVsbFwiIHByZWZldGNoaW5nLCB3ZSdsbCByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGRhdGEgZm9yIHVwIHRvIGBzdGF0aWNgIHN0YWxldGltZSB3aW5kb3cuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuRlVMTCkge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5yZXVzYWJsZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMuZXhwaXJlZFxufVxuIl0sIm5hbWVzIjpbIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInBydW5lUHJlZmV0Y2hDYWNoZSIsIklOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwiLCJ1cmwiLCJpbmNsdWRlU2VhcmNoUGFyYW1zIiwicHJlZml4IiwicGF0aG5hbWVGcm9tVXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5Iiwia2luZCIsIm5leHRVcmwiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0RXhpc3RpbmdDYWNoZUVudHJ5IiwicHJlZmV0Y2hDYWNoZSIsImFsbG93QWxpYXNpbmciLCJURU1QT1JBUlkiLCJtYXliZU5leHRVcmwiLCJjYWNoZUtleVdpdGhQYXJhbXMiLCJjYWNoZUtleVdpdGhvdXRQYXJhbXMiLCJjYWNoZUtleVRvVXNlIiwiZXhpc3RpbmdFbnRyeSIsImdldCIsImlzQWxpYXNlZCIsImFsaWFzZWQiLCJlbnRyeVdpdGhvdXRQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJrZXkiLCJpbmNsdWRlcyIsImNhY2hlRW50cnkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJ0cmVlIiwiZXhpc3RpbmdDYWNoZUVudHJ5Iiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsImRhdGEiLCJ0aGVuIiwicHJlZmV0Y2hSZXNwb25zZSIsImlzRnVsbFByZWZldGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxpZ2h0RGF0YSIsInNvbWUiLCJpc1Jvb3RSZW5kZXIiLCJzZWVkRGF0YSIsImNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5IiwicHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkiLCJleGlzdGluZ0NhY2hlS2V5IiwibmV3Q2FjaGVLZXkiLCJzZXQiLCJkZWxldGUiLCJwcmVmZXRjaENhY2hlS2V5IiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlZmV0Y2hFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVmZXRjaFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFVzZWRUaW1lIiwic3RhbGVUaW1lIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwiZnJlc2giLCJwcmVmZXRjaFF1ZXVlIiwiZW5xdWV1ZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoS2luZCIsInByZXJlbmRlcmVkIiwiaHJlZiIsInByZWZldGNoQ2FjaGVFbnRyeSIsImV4cGlyZWQiLCJEWU5BTUlDX1NUQUxFVElNRV9NUyIsIk51bWJlciIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RZTkFNSUNfU1RBTEVUSU1FIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU1RBVElDX1NUQUxFVElNRSIsInN0YWxlIiwicmV1c2FibGUiLCJBVVRPIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"findHeadInCache\", ({\n    enumerable: true,\n    get: function() {\n        return findHeadInCache;\n    }\n}));\nconst _createroutercachekey = __webpack_require__(/*! ../create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\nfunction findHeadInCache(cache, parallelRoutes) {\n    return findHeadInCacheImpl(cache, parallelRoutes, '');\n}\nfunction findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        // Returns the entire Cache Node of the segment whose head we will render.\n        return [\n            cache,\n            keyPrefix\n        ];\n    }\n    // First try the 'children' parallel route if it exists\n    // when starting from the \"root\", this corresponds with the main page component\n    if (parallelRoutes.children) {\n        const [segment, childParallelRoutes] = parallelRoutes.children;\n        const childSegmentMap = cache.parallelRoutes.get('children');\n        if (childSegmentMap) {\n            const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n            const cacheNode = childSegmentMap.get(cacheKey);\n            if (cacheNode) {\n                const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n                if (item) return item;\n            }\n        }\n    }\n    // if we didn't find metadata in the page slot, check the other parallel routes\n    for(const key in parallelRoutes){\n        if (key === 'children') continue; // already checked above\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(segment);\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + '/' + cacheKey);\n        if (item) {\n            return item;\n        }\n    }\n    return null;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBSWdCQTs7O2VBQUFBOzs7a0RBRnFCO0FBRTlCLFNBQVNBLGdCQUNkQyxLQUFnQixFQUNoQkMsY0FBb0M7SUFFcEMsT0FBT0Msb0JBQW9CRixPQUFPQyxnQkFBZ0I7QUFDcEQ7QUFFQSxTQUFTQyxvQkFDUEYsS0FBZ0IsRUFDaEJDLGNBQW9DLEVBQ3BDRSxTQUFpQjtJQUVqQixNQUFNQyxhQUFhQyxPQUFPQyxJQUFJLENBQUNMLGdCQUFnQk0sTUFBTSxLQUFLO0lBQzFELElBQUlILFlBQVk7UUFDZCwwRUFBMEU7UUFDMUUsT0FBTztZQUFDSjtZQUFPRztTQUFVO0lBQzNCO0lBRUEsdURBQXVEO0lBQ3ZELCtFQUErRTtJQUMvRSxJQUFJRixlQUFlTyxRQUFRLEVBQUU7UUFDM0IsTUFBTSxDQUFDQyxTQUFTQyxvQkFBb0IsR0FBR1QsZUFBZU8sUUFBUTtRQUM5RCxNQUFNRyxrQkFBa0JYLE1BQU1DLGNBQWMsQ0FBQ1csR0FBRyxDQUFDO1FBQ2pELElBQUlELGlCQUFpQjtZQUNuQixNQUFNRSxXQUFXQyxDQUFBQSxHQUFBQSxzQkFBQUEsb0JBQUFBLEVBQXFCTDtZQUN0QyxNQUFNTSxZQUFZSixnQkFBZ0JDLEdBQUcsQ0FBQ0M7WUFDdEMsSUFBSUUsV0FBVztnQkFDYixNQUFNQyxPQUFPZCxvQkFDWGEsV0FDQUwscUJBQ0FQLFlBQVksTUFBTVU7Z0JBRXBCLElBQUlHLE1BQU0sT0FBT0E7WUFDbkI7UUFDRjtJQUNGO0lBRUEsK0VBQStFO0lBQy9FLElBQUssTUFBTUMsT0FBT2hCLGVBQWdCO1FBQ2hDLElBQUlnQixRQUFRLFlBQVksVUFBUyx3QkFBd0I7UUFFekQsTUFBTSxDQUFDUixTQUFTQyxvQkFBb0IsR0FBR1QsY0FBYyxDQUFDZ0IsSUFBSTtRQUMxRCxNQUFNTixrQkFBa0JYLE1BQU1DLGNBQWMsQ0FBQ1csR0FBRyxDQUFDSztRQUNqRCxJQUFJLENBQUNOLGlCQUFpQjtZQUNwQjtRQUNGO1FBRUEsTUFBTUUsV0FBV0MsQ0FBQUEsR0FBQUEsc0JBQUFBLG9CQUFBQSxFQUFxQkw7UUFFdEMsTUFBTU0sWUFBWUosZ0JBQWdCQyxHQUFHLENBQUNDO1FBQ3RDLElBQUksQ0FBQ0UsV0FBVztZQUNkO1FBQ0Y7UUFFQSxNQUFNQyxPQUFPZCxvQkFDWGEsV0FDQUwscUJBQ0FQLFlBQVksTUFBTVU7UUFFcEIsSUFBSUcsTUFBTTtZQUNSLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZVJvdXRlckNhY2hlS2V5IH0gZnJvbSAnLi4vY3JlYXRlLXJvdXRlci1jYWNoZS1rZXknXG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSGVhZEluQ2FjaGUoXG4gIGNhY2hlOiBDYWNoZU5vZGUsXG4gIHBhcmFsbGVsUm91dGVzOiBGbGlnaHRSb3V0ZXJTdGF0ZVsxXVxuKTogW0NhY2hlTm9kZSwgc3RyaW5nXSB8IG51bGwge1xuICByZXR1cm4gZmluZEhlYWRJbkNhY2hlSW1wbChjYWNoZSwgcGFyYWxsZWxSb3V0ZXMsICcnKVxufVxuXG5mdW5jdGlvbiBmaW5kSGVhZEluQ2FjaGVJbXBsKFxuICBjYWNoZTogQ2FjaGVOb2RlLFxuICBwYXJhbGxlbFJvdXRlczogRmxpZ2h0Um91dGVyU3RhdGVbMV0sXG4gIGtleVByZWZpeDogc3RyaW5nXG4pOiBbQ2FjaGVOb2RlLCBzdHJpbmddIHwgbnVsbCB7XG4gIGNvbnN0IGlzTGFzdEl0ZW0gPSBPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwXG4gIGlmIChpc0xhc3RJdGVtKSB7XG4gICAgLy8gUmV0dXJucyB0aGUgZW50aXJlIENhY2hlIE5vZGUgb2YgdGhlIHNlZ21lbnQgd2hvc2UgaGVhZCB3ZSB3aWxsIHJlbmRlci5cbiAgICByZXR1cm4gW2NhY2hlLCBrZXlQcmVmaXhdXG4gIH1cblxuICAvLyBGaXJzdCB0cnkgdGhlICdjaGlsZHJlbicgcGFyYWxsZWwgcm91dGUgaWYgaXQgZXhpc3RzXG4gIC8vIHdoZW4gc3RhcnRpbmcgZnJvbSB0aGUgXCJyb290XCIsIHRoaXMgY29ycmVzcG9uZHMgd2l0aCB0aGUgbWFpbiBwYWdlIGNvbXBvbmVudFxuICBpZiAocGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBbc2VnbWVudCwgY2hpbGRQYXJhbGxlbFJvdXRlc10gPSBwYXJhbGxlbFJvdXRlcy5jaGlsZHJlblxuICAgIGNvbnN0IGNoaWxkU2VnbWVudE1hcCA9IGNhY2hlLnBhcmFsbGVsUm91dGVzLmdldCgnY2hpbGRyZW4nKVxuICAgIGlmIChjaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUm91dGVyQ2FjaGVLZXkoc2VnbWVudClcbiAgICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpXG4gICAgICBpZiAoY2FjaGVOb2RlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBmaW5kSGVhZEluQ2FjaGVJbXBsKFxuICAgICAgICAgIGNhY2hlTm9kZSxcbiAgICAgICAgICBjaGlsZFBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgIGtleVByZWZpeCArICcvJyArIGNhY2hlS2V5XG4gICAgICAgIClcbiAgICAgICAgaWYgKGl0ZW0pIHJldHVybiBpdGVtXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgd2UgZGlkbid0IGZpbmQgbWV0YWRhdGEgaW4gdGhlIHBhZ2Ugc2xvdCwgY2hlY2sgdGhlIG90aGVyIHBhcmFsbGVsIHJvdXRlc1xuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcykge1xuICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIGNvbnRpbnVlIC8vIGFscmVhZHkgY2hlY2tlZCBhYm92ZVxuXG4gICAgY29uc3QgW3NlZ21lbnQsIGNoaWxkUGFyYWxsZWxSb3V0ZXNdID0gcGFyYWxsZWxSb3V0ZXNba2V5XVxuICAgIGNvbnN0IGNoaWxkU2VnbWVudE1hcCA9IGNhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpXG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVSb3V0ZXJDYWNoZUtleShzZWdtZW50KVxuXG4gICAgY29uc3QgY2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChjYWNoZUtleSlcbiAgICBpZiAoIWNhY2hlTm9kZSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtID0gZmluZEhlYWRJbkNhY2hlSW1wbChcbiAgICAgIGNhY2hlTm9kZSxcbiAgICAgIGNoaWxkUGFyYWxsZWxSb3V0ZXMsXG4gICAgICBrZXlQcmVmaXggKyAnLycgKyBjYWNoZUtleVxuICAgIClcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbImZpbmRIZWFkSW5DYWNoZSIsImNhY2hlIiwicGFyYWxsZWxSb3V0ZXMiLCJmaW5kSGVhZEluQ2FjaGVJbXBsIiwia2V5UHJlZml4IiwiaXNMYXN0SXRlbSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJjaGlsZHJlbiIsInNlZ21lbnQiLCJjaGlsZFBhcmFsbGVsUm91dGVzIiwiY2hpbGRTZWdtZW50TWFwIiwiZ2V0IiwiY2FjaGVLZXkiLCJjcmVhdGVSb3V0ZXJDYWNoZUtleSIsImNhY2hlTm9kZSIsIml0ZW0iLCJrZXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js ***!
  \***********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSegmentValue\", ({\n    enumerable: true,\n    get: function() {\n        return getSegmentValue;\n    }\n}));\nfunction getSegmentValue(segment) {\n    return Array.isArray(segment) ? segment[1] : segment;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-segment-value.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7OzttREFFZ0JBOzs7ZUFBQUE7OztBQUFULFNBQVNBLGdCQUFnQkMsT0FBZ0I7SUFDOUMsT0FBT0MsTUFBTUMsT0FBTyxDQUFDRixXQUFXQSxPQUFPLENBQUMsRUFBRSxHQUFHQTtBQUMvQyIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9nZXQtc2VnbWVudC12YWx1ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFNlZ21lbnQgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlZ21lbnRWYWx1ZShzZWdtZW50OiBTZWdtZW50KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnRcbn1cbiJdLCJuYW1lcyI6WyJnZXRTZWdtZW50VmFsdWUiLCJzZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js ***!
  \********************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hasInterceptionRouteInCurrentTree\", ({\n    enumerable: true,\n    get: function() {\n        return hasInterceptionRouteInCurrentTree;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../shared/lib/router/utils/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interception-routes.js\");\nfunction hasInterceptionRouteInCurrentTree(param) {\n    let [segment, parallelRoutes] = param;\n    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n    if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n        return true;\n    }\n    // If segment is not an array, apply the existing string-based check\n    if (typeof segment === 'string' && (0, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {\n        return true;\n    }\n    // Iterate through parallelRoutes if they exist\n    if (parallelRoutes) {\n        for(const key in parallelRoutes){\n            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-interception-route-in-current-tree.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUuanMiLCJtYXBwaW5ncyI6Ijs7OztxRUFHZ0JBOzs7ZUFBQUE7OztnREFGMkI7QUFFcEMsU0FBU0Esa0NBQWtDLEtBRzlCO0lBSDhCLEtBQ2hEQyxTQUNBQyxlQUNrQixHQUg4QjtJQUloRCx3R0FBd0c7SUFDeEcsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxZQUFhQSxDQUFBQSxPQUFPLENBQUMsRUFBRSxLQUFLLFFBQVFBLE9BQU8sQ0FBQyxFQUFFLEtBQUssS0FBRyxFQUFJO1FBQzFFLE9BQU87SUFDVDtJQUVBLG9FQUFvRTtJQUNwRSxJQUFJLE9BQU9BLFlBQVksWUFBWUksQ0FBQUEsR0FBQUEsb0JBQUFBLDBCQUFBQSxFQUEyQkosVUFBVTtRQUN0RSxPQUFPO0lBQ1Q7SUFFQSwrQ0FBK0M7SUFDL0MsSUFBSUMsZ0JBQWdCO1FBQ2xCLElBQUssTUFBTUksT0FBT0osZUFBZ0I7WUFDaEMsSUFBSUYsa0NBQWtDRSxjQUFjLENBQUNJLElBQUksR0FBRztnQkFDMUQsT0FBTztZQUNUO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgeyBpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVyY2VwdGlvbi1yb3V0ZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoW1xuICBzZWdtZW50LFxuICBwYXJhbGxlbFJvdXRlcyxcbl06IEZsaWdodFJvdXRlclN0YXRlKTogYm9vbGVhbiB7XG4gIC8vIElmIHdlIGhhdmUgYSBkeW5hbWljIHNlZ21lbnQsIGl0J3MgbWFya2VkIGFzIGFuIGludGVyY2VwdGlvbiByb3V0ZSBieSB0aGUgcHJlc2VuY2Ugb2YgdGhlIGBpYCBzdWZmaXguXG4gIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpICYmIChzZWdtZW50WzJdID09PSAnZGknIHx8IHNlZ21lbnRbMl0gPT09ICdjaScpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIElmIHNlZ21lbnQgaXMgbm90IGFuIGFycmF5LCBhcHBseSB0aGUgZXhpc3Rpbmcgc3RyaW5nLWJhc2VkIGNoZWNrXG4gIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycgJiYgaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgoc2VnbWVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIHBhcmFsbGVsUm91dGVzIGlmIHRoZXkgZXhpc3RcbiAgaWYgKHBhcmFsbGVsUm91dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgIGlmIChoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUocGFyYWxsZWxSb3V0ZXNba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiJdLCJuYW1lcyI6WyJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJpc0ludGVyY2VwdGlvblJvdXRlQXBwUGF0aCIsImtleSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3FEQTZIYUE7OztlQUFBQTs7O2lEQTdIdUI7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7NkNBQ0U7dUNBRUs7bURBQ0M7K0RBQ1k7QUFFbEQsd0ZBQXdGO0FBQ3hGLFNBQVNDLHNCQUNQQyxLQUEyQixFQUMzQkMsTUFBd0I7SUFFeEIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CRixRQUFRRywwQkFBMEIsR0FBRztJQUVyQyxNQUFNQyxRQUFtQkMsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQUFBO0lBQ3pCLHNGQUFzRjtJQUN0RixzSEFBc0g7SUFDdEgsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQUFBLEVBQWtDVixNQUFNVyxJQUFJO0lBRW5FLHVEQUF1RDtJQUN2RCx3Q0FBd0M7SUFDeENKLE1BQU1LLFFBQVEsR0FBR0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQixJQUFJQyxJQUFJVixNQUFNRixTQUFTO1FBQzFEYSxtQkFBbUI7WUFBQ2YsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRTtTQUFVO1FBQzNFSyxTQUFTUCxpQkFBaUJULE1BQU1nQixPQUFPLEdBQUc7UUFDMUNDLGNBQWM7SUFDaEI7SUFFQSxPQUFPVixNQUFNSyxRQUFRLENBQUNNLElBQUksQ0FDeEI7WUFBQyxFQUFFQyxVQUFVLEVBQUVkLGNBQWNlLG9CQUFvQixFQUFFO1FBQ2pELDREQUE0RDtRQUM1RCxJQUFJLE9BQU9ELGVBQWUsVUFBVTtZQUNsQyxPQUFPRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0xyQixPQUNBRyxTQUNBZ0IsWUFDQW5CLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7UUFFN0I7UUFFQSwrREFBK0Q7UUFDL0RoQixNQUFNSyxRQUFRLEdBQUc7UUFFakIsSUFBSVksY0FBY3hCLE1BQU1XLElBQUk7UUFDNUIsSUFBSWMsZUFBZXpCLE1BQU1PLEtBQUs7UUFFOUIsS0FBSyxNQUFNbUIsd0JBQXdCUCxXQUFZO1lBQzdDLE1BQU0sRUFBRVIsTUFBTWdCLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdGO1lBQzFDLElBQUksQ0FBQ0UsY0FBYztnQkFDakIsb0NBQW9DO2dCQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU85QjtZQUNUO1lBRUEsTUFBTStCLFVBQVVDLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFDZDtnQkFDQzthQUFHLEVBQ0pSLGFBQ0FHLFdBQ0EzQixNQUFNSyxZQUFZO1lBR3BCLElBQUkwQixZQUFZLE1BQU07Z0JBQ3BCLE9BQU9FLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBQUEsRUFBc0JqQyxPQUFPQyxRQUFRMEI7WUFDOUM7WUFFQSxJQUFJTyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQTRCVixhQUFhTyxVQUFVO2dCQUNyRCxPQUFPVixDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0xyQixPQUNBRyxTQUNBQyxNQUNBSixNQUFNc0IsT0FBTyxDQUFDQyxXQUFXO1lBRTdCO1lBRUEsTUFBTVksMkJBQTJCZix1QkFDN0JnQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCaEIsd0JBQ2xCaUI7WUFFSixJQUFJakIsc0JBQXNCO2dCQUN4QmpCLFFBQVFFLFlBQVksR0FBRzhCO1lBQ3pCO1lBQ0EsTUFBTUcsVUFBVUMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQ2RkLGNBQ0FsQixPQUNBbUI7WUFHRixJQUFJWSxTQUFTO2dCQUNYbkMsUUFBUUksS0FBSyxHQUFHQTtnQkFDaEJrQixlQUFlbEI7WUFDakI7WUFFQUosUUFBUXFDLFdBQVcsR0FBR1Q7WUFDdEI1QixRQUFRRSxZQUFZLEdBQUdEO1lBRXZCb0IsY0FBY087UUFDaEI7UUFDQSxPQUFPVSxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjekMsT0FBT0c7SUFDOUIsR0FDQSxJQUFNSDtBQUVWO0FBRUEsU0FBUzBDLHNCQUNQMUMsS0FBMkIsRUFDM0IyQyxPQUF5QjtJQUV6QixPQUFPM0M7QUFDVDtBQUVPLE1BQU1GLG9CQTdHcUMsTUE4RzVCLEdBQ2hCNEMsQ0FBcUJBLEdBQ3JCM0MiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHsgY3JlYXRlSHJlZkZyb21VcmwgfSBmcm9tICcuLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSB9IGZyb20gJy4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQgdHlwZSB7XG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBSZWR1Y2VyU3RhdGUsXG4gIEhtclJlZnJlc2hBY3Rpb24sXG4gIE11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBoYW5kbGVNdXRhYmxlIH0gZnJvbSAnLi4vaGFuZGxlLW11dGFibGUnXG5pbXBvcnQgeyBhcHBseUZsaWdodERhdGEgfSBmcm9tICcuLi9hcHBseS1mbGlnaHQtZGF0YSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYW5kbGVTZWdtZW50TWlzbWF0Y2ggfSBmcm9tICcuLi9oYW5kbGUtc2VnbWVudC1taXNtYXRjaCdcbmltcG9ydCB7IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSB9IGZyb20gJy4vaGFzLWludGVyY2VwdGlvbi1yb3V0ZS1pbi1jdXJyZW50LXRyZWUnXG5cbi8vIEEgdmVyc2lvbiBvZiByZWZyZXNoIHJlZHVjZXIgdGhhdCBrZWVwcyB0aGUgY2FjaGUgYXJvdW5kIGluc3RlYWQgb2Ygd2lwaW5nIGFsbCBvZiBpdC5cbmZ1bmN0aW9uIGhtclJlZnJlc2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgb3JpZ2luIH0gPSBhY3Rpb25cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG4gIGNvbnN0IGhyZWYgPSBzdGF0ZS5jYW5vbmljYWxVcmxcblxuICBtdXRhYmxlLnByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlID0gZmFsc2VcblxuICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAvLyBJZiB0aGUgY3VycmVudCB0cmVlIHdhcyBpbnRlcmNlcHRlZCwgdGhlIG5leHRVcmwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSByZWZyZXNoIHJlcXVlc3QgZG9lc24ndCBnZXQgaW50ZXJjZXB0ZWQsIGFjY2lkZW50YWxseSB0cmlnZ2VyaW5nIHRoZSBpbnRlcmNlcHRpb24gcm91dGUuXG4gIGNvbnN0IGluY2x1ZGVOZXh0VXJsID0gaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG5cbiAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAvLyBGZXRjaCBkYXRhIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gIGNhY2hlLmxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW3N0YXRlLnRyZWVbMF0sIHN0YXRlLnRyZWVbMV0sIHN0YXRlLnRyZWVbMl0sICdyZWZldGNoJ10sXG4gICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgICBpc0htclJlZnJlc2g6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBsaWVkID0gYXBwbHlGbGlnaHREYXRhKFxuICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgICAgICB9XG5cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBocmVmXG5cbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cblxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJOb29wKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIF9hY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgaG1yUmVmcmVzaFJlZHVjZXIgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBobXJSZWZyZXNoUmVkdWNlck5vb3BcbiAgICA6IGhtclJlZnJlc2hSZWR1Y2VySW1wbFxuIl0sIm5hbWVzIjpbImhtclJlZnJlc2hSZWR1Y2VyIiwiaG1yUmVmcmVzaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsImlzSG1yUmVmcmVzaCIsInRoZW4iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImhtclJlZnJlc2hSZWR1Y2VyTm9vcCIsIl9hY3Rpb24iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    handleExternalUrl: function() {\n        return handleExternalUrl;\n    },\n    navigateReducer: function() {\n        return navigateReducer;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _invalidatecachebelowflightsegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _shouldhardnavigate = __webpack_require__(/*! ../should-hard-navigate */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _segment = __webpack_require__(/*! ../../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _clearcachenodedataforsegmentpath = __webpack_require__(/*! ../clear-cache-node-data-for-segment-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js\");\nconst _aliasedprefetchnavigations = __webpack_require__(/*! ../aliased-prefetch-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.scrollableSegments = undefined;\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nfunction generateSegmentsFromPatch(flightRouterPatch) {\n    const segments = [];\n    const [segment, parallelRoutes] = flightRouterPatch;\n    if (Object.keys(parallelRoutes).length === 0) {\n        return [\n            [\n                segment\n            ]\n        ];\n    }\n    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){\n        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){\n            // If the segment is empty, it means we are at the root of the tree\n            if (segment === '') {\n                segments.push([\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            } else {\n                segments.push([\n                    segment,\n                    parallelRouteKey,\n                    ...childSegment\n                ]);\n            }\n        }\n    }\n    return segments;\n}\nfunction triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {\n    let appliedPatch = false;\n    newCache.rsc = currentCache.rsc;\n    newCache.prefetchRsc = currentCache.prefetchRsc;\n    newCache.loading = currentCache.loading;\n    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);\n    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[\n            ...flightSegmentPath,\n            ...segment\n        ]);\n    for (const segmentPaths of segmentPathsToFill){\n        (0, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);\n        appliedPatch = true;\n    }\n    return appliedPatch;\n}\nfunction handleNavigationResult(url, state, mutable, pendingPush, result) {\n    switch(result.tag){\n        case _segmentcache.NavigationResultTag.MPA:\n            {\n                // Perform an MPA navigation.\n                const newUrl = result.data;\n                return handleExternalUrl(state, mutable, newUrl, pendingPush);\n            }\n        case _segmentcache.NavigationResultTag.NoOp:\n            {\n                // The server responded with no change to the current page. However, if\n                // the URL changed, we still need to update that.\n                const newCanonicalUrl = result.data.canonicalUrl;\n                mutable.canonicalUrl = newCanonicalUrl;\n                // Check if the only thing that changed was the hash fragment.\n                const oldUrl = new URL(state.canonicalUrl, url);\n                const onlyHashChange = // navigations are always same-origin.\n                url.pathname === oldUrl.pathname && url.search === oldUrl.search && url.hash !== oldUrl.hash;\n                if (onlyHashChange) {\n                    // The only updated part of the URL is the hash.\n                    mutable.onlyHashChange = true;\n                    mutable.shouldScroll = result.data.shouldScroll;\n                    mutable.hashFragment = url.hash;\n                    // Setting this to an empty array triggers a scroll for all new and\n                    // updated segments. See `ScrollAndFocusHandler` for more details.\n                    mutable.scrollableSegments = [];\n                }\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Success:\n            {\n                // Received a new result.\n                mutable.cache = result.data.cacheNode;\n                mutable.patchedTree = result.data.flightRouterState;\n                mutable.canonicalUrl = result.data.canonicalUrl;\n                mutable.scrollableSegments = result.data.scrollableSegments;\n                mutable.shouldScroll = result.data.shouldScroll;\n                mutable.hashFragment = result.data.hash;\n                return (0, _handlemutable.handleMutable)(state, mutable);\n            }\n        case _segmentcache.NavigationResultTag.Async:\n            {\n                return result.data.then((asyncResult)=>handleNavigationResult(url, state, mutable, pendingPush, asyncResult), // TODO: This matches the current behavior but we need to do something\n                // better here if the network fails.\n                ()=>{\n                    return state;\n                });\n            }\n        default:\n            {\n                result;\n                return state;\n            }\n    }\n}\nfunction navigateReducer(state, action) {\n    const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;\n    const mutable = {};\n    const { hash } = url;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    const pendingPush = navigateType === 'push';\n    // we want to prune the prefetch cache on every navigation to avoid it growing too large\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    mutable.preserveCustomHistoryState = false;\n    mutable.pendingPush = pendingPush;\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n    // which will trigger an MPA navigation.\n    if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    if (false) {}\n    const prefetchValues = (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        tree: state.tree,\n        prefetchCache: state.prefetchCache,\n        allowAliasing\n    });\n    const { treeAtTimeOfPrefetch, data } = prefetchValues;\n    _prefetchreducer.prefetchQueue.bump(data);\n    return data.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;\n        let isFirstRead = false;\n        // we only want to mark this once\n        if (!prefetchValues.lastUsedTime) {\n            // important: we should only mark the cache node as dirty after we unsuspend from the call above\n            prefetchValues.lastUsedTime = Date.now();\n            isFirstRead = true;\n        }\n        if (prefetchValues.aliased) {\n            const result = (0, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(state, flightData, url, mutable);\n            // We didn't return new router state because we didn't apply the aliased entry for some reason.\n            // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n            // will create an on-demand prefetch entry.\n            if (result === false) {\n                return navigateReducer(state, {\n                    ...action,\n                    allowAliasing: false\n                });\n            }\n            return result;\n        }\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        const updatedCanonicalUrl = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;\n        const onlyHashChange = !!hash && state.canonicalUrl.split('#', 1)[0] === updatedCanonicalUrl.split('#', 1)[0];\n        // If only the hash has changed, the server hasn't sent us any new data. We can just update\n        // the mutable properties responsible for URL and scroll handling and return early.\n        if (onlyHashChange) {\n            mutable.onlyHashChange = true;\n            mutable.canonicalUrl = updatedCanonicalUrl;\n            mutable.shouldScroll = shouldScroll;\n            mutable.hashFragment = hash;\n            mutable.scrollableSegments = [];\n            return (0, _handlemutable.handleMutable)(state, mutable);\n        }\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        let scrollableSegments = [];\n        for (const normalizedFlightData of flightData){\n            const { pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;\n            let treePatch = normalizedFlightData.tree;\n            // TODO-APP: remove ''\n            const flightSegmentPathWithLeadingEmpty = [\n                '',\n                ...flightSegmentPath\n            ];\n            // Create new tree based on the flightSegmentPath and router state patch\n            let newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);\n            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n            if (newTree === null) {\n                newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);\n            }\n            if (newTree !== null) {\n                if (// will send back a static response that's rendered from\n                // the root. If for some reason it doesn't, we fall back to the\n                // non-PPR implementation.\n                // TODO: We should get rid of the else branch and do all navigations\n                // via startPPRNavigation. The current structure is just\n                // an incremental step.\n                seedData && isRootRender && postponed) {\n                    const task = (0, _pprnavigations.startPPRNavigation)(currentCache, currentTree, treePatch, seedData, head, isHeadPartial, false, scrollableSegments);\n                    if (task !== null) {\n                        if (task.route === null) {\n                            // Detected a change to the root layout. Perform an full-\n                            // page navigation.\n                            return handleExternalUrl(state, mutable, href, pendingPush);\n                        }\n                        // Use the tree computed by startPPRNavigation instead\n                        // of the one computed by applyRouterStatePatchToTree.\n                        // TODO: We should remove applyRouterStatePatchToTree\n                        // from the PPR path entirely.\n                        const patchedRouterState = task.route;\n                        newTree = patchedRouterState;\n                        const newCache = task.node;\n                        if (newCache !== null) {\n                            // We've created a new Cache Node tree that contains a prefetched\n                            // version of the next page. This can be rendered instantly.\n                            mutable.cache = newCache;\n                        }\n                        const dynamicRequestTree = task.dynamicRequestTree;\n                        if (dynamicRequestTree !== null) {\n                            // The prefetched tree has dynamic holes in it. We initiate a\n                            // dynamic request to fill them in.\n                            //\n                            // Do not block on the result. We'll immediately render the Cache\n                            // Node tree and suspend on the dynamic parts. When the request\n                            // comes in, we'll fill in missing data and ping React to\n                            // re-render. Unlike the lazy fetching model in the non-PPR\n                            // implementation, this is modeled as a single React update +\n                            // streaming, rather than multiple top-level updates. (However,\n                            // even in the new model, we'll still need to sometimes update the\n                            // root multiple times per navigation, like if the server sends us\n                            // a different response than we expected. For now, we revert back\n                            // to the lazy fetching mechanism in that case.)\n                            const dynamicRequest = (0, _fetchserverresponse.fetchServerResponse)(url, {\n                                flightRouterState: dynamicRequestTree,\n                                nextUrl: state.nextUrl\n                            });\n                            (0, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);\n                        // We store the dynamic request on the `lazyData` property of the CacheNode\n                        // because we're not going to await the dynamic request here. Since we're not blocking\n                        // on the dynamic request, `layout-router` will\n                        // task.node.lazyData = dynamicRequest\n                        } else {\n                        // The prefetched tree does not contain dynamic holes — it's\n                        // fully static. We can skip the dynamic request.\n                        }\n                    } else {\n                        // Nothing changed, so reuse the old cache.\n                        // TODO: What if the head changed but not any of the segment data?\n                        // Is that possible? If so, we should clone the whole tree and\n                        // update the head.\n                        newTree = treePatch;\n                    }\n                } else {\n                    // The static response does not include any dynamic holes, so\n                    // there's no need to do a second request.\n                    // TODO: As an incremental step this just reverts back to the\n                    // non-PPR implementation. We can simplify this branch further,\n                    // given that PPR prefetches are always static and return the whole\n                    // tree. Or in the meantime we could factor it out into a\n                    // separate function.\n                    if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                        return handleExternalUrl(state, mutable, href, pendingPush);\n                    }\n                    const cache = (0, _approuter.createEmptyCacheNode)();\n                    let applied = false;\n                    if (prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale && !isFirstRead) {\n                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n                        // while copying over the `loading` for the segment that contains the page data.\n                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n                        // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);\n                        // since we re-used the stale cache's loading state & refreshed the data,\n                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n                        prefetchValues.lastUsedTime = Date.now();\n                    } else {\n                        applied = (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData, prefetchValues);\n                    }\n                    const hardNavigate = (0, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);\n                    if (hardNavigate) {\n                        // Copy rsc for the root node of the cache.\n                        cache.rsc = currentCache.rsc;\n                        cache.prefetchRsc = currentCache.prefetchRsc;\n                        (0, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        mutable.cache = cache;\n                    } else if (applied) {\n                        mutable.cache = cache;\n                        // If we applied the cache, we update the \"current cache\" value so any other\n                        // segments in the FlightDataPath will be able to reference the updated cache.\n                        currentCache = cache;\n                    }\n                    for (const subSegment of generateSegmentsFromPatch(treePatch)){\n                        const scrollableSegmentPath = [\n                            ...flightSegmentPath,\n                            ...subSegment\n                        ];\n                        // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n                        if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== _segment.DEFAULT_SEGMENT_KEY) {\n                            scrollableSegments.push(scrollableSegmentPath);\n                        }\n                    }\n                }\n                currentTree = newTree;\n            }\n        }\n        mutable.patchedTree = currentTree;\n        mutable.canonicalUrl = updatedCanonicalUrl;\n        mutable.scrollableSegments = scrollableSegments;\n        mutable.hashFragment = hash;\n        mutable.shouldScroll = shouldScroll;\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvQ2dCQSxpQkFBaUI7ZUFBakJBOztJQXNJQUMsZUFBZTtlQUFmQTs7O2lEQXJLb0I7K0NBQ0Y7bUVBQ29CO3lEQUNWO2dEQUNUO3lEQUNTO2dEQU9yQzsyQ0FDdUI7NkNBQ0U7NkNBQ0Y7dUNBQ087cUNBQ0Q7NENBQ3dCO2dEQUlyRDs4REFDMEM7d0RBQ047MENBS3BDO0FBRUEsU0FBU0Qsa0JBQ2RFLEtBQTJCLEVBQzNCQyxPQUFnQixFQUNoQkMsR0FBVyxFQUNYQyxXQUFvQjtJQUVwQkYsUUFBUUcsYUFBYSxHQUFHO0lBQ3hCSCxRQUFRSSxZQUFZLEdBQUdIO0lBQ3ZCRCxRQUFRRSxXQUFXLEdBQUdBO0lBQ3RCRixRQUFRSyxrQkFBa0IsR0FBR0M7SUFFN0IsT0FBT0MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBQUEsRUFBY1IsT0FBT0M7QUFDOUI7QUFFQSxTQUFTUSwwQkFDUEMsaUJBQW9DO0lBRXBDLE1BQU1DLFdBQWdDLEVBQUU7SUFDeEMsTUFBTSxDQUFDQyxTQUFTQyxlQUFlLEdBQUdIO0lBRWxDLElBQUlJLE9BQU9DLElBQUksQ0FBQ0YsZ0JBQWdCRyxNQUFNLEtBQUssR0FBRztRQUM1QyxPQUFPO1lBQUM7Z0JBQUNKO2FBQVE7U0FBQztJQUNwQjtJQUVBLEtBQUssTUFBTSxDQUFDSyxrQkFBa0JDLGNBQWMsSUFBSUosT0FBT0ssT0FBTyxDQUM1RE4sZ0JBQ0M7UUFDRCxLQUFLLE1BQU1PLGdCQUFnQlgsMEJBQTBCUyxlQUFnQjtZQUNuRSxtRUFBbUU7WUFDbkUsSUFBSU4sWUFBWSxJQUFJO2dCQUNsQkQsU0FBU1UsSUFBSSxDQUFDO29CQUFDSjt1QkFBcUJHO2lCQUFhO1lBQ25ELE9BQU87Z0JBQ0xULFNBQVNVLElB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Q0FBQUEscUNBQUFBLEVBQ0VyRSxPQUNBOUIsY0FDQUM7d0JBRUYsOEVBQThFO3dCQUM5RXhCLFFBQVFxRCxLQUFLLEdBQUdBO29CQUNsQixPQUFPLElBQUk4RCxTQUFTO3dCQUNsQm5ILFFBQVFxRCxLQUFLLEdBQUdBO3dCQUNoQiw0RUFBNEU7d0JBQzVFLDhFQUE4RTt3QkFDOUU5QixlQUFlOEI7b0JBQ2pCO29CQUVBLEtBQUssTUFBTXNFLGNBQWNuSCwwQkFBMEJpQixXQUFZO3dCQUM3RCxNQUFNbUcsd0JBQXdCOytCQUN6QnBHOytCQUNBbUc7eUJBQ0o7d0JBQ0Qsa0ZBQWtGO3dCQUNsRixJQUNFQyxxQkFBcUIsQ0FBQ0Esc0JBQXNCN0csTUFBTSxHQUFHLEVBQUUsS0FDdkQ4RyxTQUFBQSxtQkFBbUIsRUFDbkI7NEJBQ0F4SCxtQkFBbUJlLElBQUksQ0FBQ3dHO3dCQUMxQjtvQkFDRjtnQkFDRjtnQkFFQTlCLGNBQWNRO1lBQ2hCO1FBQ0Y7UUFFQXRHLFFBQVF1RCxXQUFXLEdBQUd1QztRQUN0QjlGLFFBQVFJLFlBQVksR0FBR3dGO1FBQ3ZCNUYsUUFBUUssa0JBQWtCLEdBQUdBO1FBQzdCTCxRQUFRbUQsWUFBWSxHQUFHRjtRQUN2QmpELFFBQVFrRCxZQUFZLEdBQUdBO1FBRXZCLE9BQU8zQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFBQSxFQUFjUixPQUFPQztJQUM5QixHQUNBLElBQU1EO0FBRVYiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENhY2hlTm9kZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0U2VnbWVudFBhdGgsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgZmV0Y2hTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJy4uL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vaW52YWxpZGF0ZS1jYWNoZS1iZWxvdy1mbGlnaHQtc2VnbWVudHBhdGgnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IHNob3VsZEhhcmROYXZpZ2F0ZSB9IGZyb20gJy4uL3Nob3VsZC1oYXJkLW5hdmlnYXRlJ1xuaW1wb3J0IHsgaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IH0gZnJvbSAnLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXQnXG5pbXBvcnQge1xuICBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMsXG4gIHR5cGUgTXV0YWJsZSxcbiAgdHlwZSBOYXZpZ2F0ZUFjdGlvbixcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgdHlwZSBSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHsgYXBwbHlGbGlnaHREYXRhIH0gZnJvbSAnLi4vYXBwbHktZmxpZ2h0LWRhdGEnXG5pbXBvcnQgeyBwcmVmZXRjaFF1ZXVlIH0gZnJvbSAnLi9wcmVmZXRjaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgREVGQVVMVF9TRUdNRU5UX0tFWSB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvc2VnbWVudCdcbmltcG9ydCB7IGxpc3RlbkZvckR5bmFtaWNSZXF1ZXN0LCBzdGFydFBQUk5hdmlnYXRpb24gfSBmcm9tICcuLi9wcHItbmF2aWdhdGlvbnMnXG5pbXBvcnQge1xuICBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSxcbiAgcHJ1bmVQcmVmZXRjaENhY2hlLFxufSBmcm9tICcuLi9wcmVmZXRjaC1jYWNoZS11dGlscydcbmltcG9ydCB7IGNsZWFyQ2FjaGVOb2RlRGF0YUZvclNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vY2xlYXItY2FjaGUtbm9kZS1kYXRhLWZvci1zZWdtZW50LXBhdGgnXG5pbXBvcnQgeyBoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSB9IGZyb20gJy4uL2FsaWFzZWQtcHJlZmV0Y2gtbmF2aWdhdGlvbnMnXG5pbXBvcnQge1xuICBuYXZpZ2F0ZSBhcyBuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlLFxuICBOYXZpZ2F0aW9uUmVzdWx0VGFnLFxuICB0eXBlIE5hdmlnYXRpb25SZXN1bHQsXG59IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFeHRlcm5hbFVybChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBtdXRhYmxlOiBNdXRhYmxlLFxuICB1cmw6IHN0cmluZyxcbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW5cbikge1xuICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSB0cnVlXG4gIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXJsXG4gIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaFxuICBtdXRhYmxlLnNjcm9sbGFibGVTZWdtZW50cyA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKFxuICBmbGlnaHRSb3V0ZXJQYXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbik6IEZsaWdodFNlZ21lbnRQYXRoW10ge1xuICBjb25zdCBzZWdtZW50czogRmxpZ2h0U2VnbWVudFBhdGhbXSA9IFtdXG4gIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJQYXRjaFxuXG4gIGlmIChPYmplY3Qua2V5cyhwYXJhbGxlbFJvdXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtbc2VnbWVudF1dXG4gIH1cblxuICBmb3IgKGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBwYXJhbGxlbFJvdXRlXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICBwYXJhbGxlbFJvdXRlc1xuICApKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZFNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaChwYXJhbGxlbFJvdXRlKSkge1xuICAgICAgLy8gSWYgdGhlIHNlZ21lbnQgaXMgZW1wdHksIGl0IG1lYW5zIHdlIGFyZSBhdCB0aGUgcm9vdCBvZiB0aGUgdHJlZVxuICAgICAgaWYgKHNlZ21lbnQgPT09ICcnKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goW3BhcmFsbGVsUm91dGVLZXksIC4uLmNoaWxkU2VnbWVudF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5LCAuLi5jaGlsZFNlZ21lbnRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKFxuICBuZXdDYWNoZTogQ2FjaGVOb2RlLFxuICBjdXJyZW50Q2FjaGU6IENhY2hlTm9kZSxcbiAgZmxpZ2h0U2VnbWVudFBhdGg6IEZsaWdodFNlZ21lbnRQYXRoLFxuICB0cmVlUGF0Y2g6IEZsaWdodFJvdXRlclN0YXRlXG4pIHtcbiAgbGV0IGFwcGxpZWRQYXRjaCA9IGZhbHNlXG5cbiAgbmV3Q2FjaGUucnNjID0gY3VycmVudENhY2hlLnJzY1xuICBuZXdDYWNoZS5wcmVmZXRjaFJzYyA9IGN1cnJlbnRDYWNoZS5wcmVmZXRjaFJzY1xuICBuZXdDYWNoZS5sb2FkaW5nID0gY3VycmVudENhY2hlLmxvYWRpbmdcbiAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMgPSBuZXcgTWFwKGN1cnJlbnRDYWNoZS5wYXJhbGxlbFJvdXRlcylcblxuICBjb25zdCBzZWdtZW50UGF0aHNUb0ZpbGwgPSBnZW5lcmF0ZVNlZ21lbnRzRnJvbVBhdGNoKHRyZWVQYXRjaCkubWFwKFxuICAgIChzZWdtZW50KSA9PiBbLi4uZmxpZ2h0U2VnbWVudFBhdGgsIC4uLnNlZ21lbnRdXG4gIClcblxuICBmb3IgKGNvbnN0IHNlZ21lbnRQYXRocyBvZiBzZWdtZW50UGF0aHNUb0ZpbGwpIHtcbiAgICBjbGVhckNhY2hlTm9kZURhdGFGb3JTZWdtZW50UGF0aChuZXdDYWNoZSwgY3VycmVudENhY2hlLCBzZWdtZW50UGF0aHMpXG5cbiAgICBhcHBsaWVkUGF0Y2ggPSB0cnVlXG4gIH1cblxuICByZXR1cm4gYXBwbGllZFBhdGNoXG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQoXG4gIHVybDogVVJMLFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIG11dGFibGU6IE11dGFibGUsXG4gIHBlbmRpbmdQdXNoOiBib29sZWFuLFxuICByZXN1bHQ6IE5hdmlnYXRpb25SZXN1bHRcbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHN3aXRjaCAocmVzdWx0LnRhZykge1xuICAgIGNhc2UgTmF2aWdhdGlvblJlc3VsdFRhZy5NUEE6IHtcbiAgICAgIC8vIFBlcmZvcm0gYW4gTVBBIG5hdmlnYXRpb24uXG4gICAgICBjb25zdCBuZXdVcmwgPSByZXN1bHQuZGF0YVxuICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBuZXdVcmwsIHBlbmRpbmdQdXNoKVxuICAgIH1cbiAgICBjYXNlIE5hdmlnYXRpb25SZXN1bHRUYWcuTm9PcDoge1xuICAgICAgLy8gVGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBubyBjaGFuZ2UgdG8gdGhlIGN1cnJlbnQgcGFnZS4gSG93ZXZlciwgaWZcbiAgICAgIC8vIHRoZSBVUkwgY2hhbmdlZCwgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhhdC5cbiAgICAgIGNvbnN0IG5ld0Nhbm9uaWNhbFVybCA9IHJlc3VsdC5kYXRhLmNhbm9uaWNhbFVybFxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBuZXdDYW5vbmljYWxVcmxcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG9ubHkgdGhpbmcgdGhhdCBjaGFuZ2VkIHdhcyB0aGUgaGFzaCBmcmFnbWVudC5cbiAgICAgIGNvbnN0IG9sZFVybCA9IG5ldyBVUkwoc3RhdGUuY2Fub25pY2FsVXJsLCB1cmwpXG4gICAgICBjb25zdCBvbmx5SGFzaENoYW5nZSA9XG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29tcGFyZSB0aGUgb3JpZ2lucywgYmVjYXVzZSBjbGllbnQtZHJpdmVuXG4gICAgICAgIC8vIG5hdmlnYXRpb25zIGFyZSBhbHdheXMgc2FtZS1vcmlnaW4uXG4gICAgICAgIHVybC5wYXRobmFtZSA9PT0gb2xkVXJsLnBhdGhuYW1lICYmXG4gICAgICAgIHVybC5zZWFyY2ggPT09IG9sZFVybC5zZWFyY2ggJiZcbiAgICAgICAgdXJsLmhhc2ggIT09IG9sZFVybC5oYXNoXG4gICAgICBpZiAob25seUhhc2hDaGFuZ2UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgdXBkYXRlZCBwYXJ0IG9mIHRoZSBVUkwgaXMgdGhlIGhhc2guXG4gICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlXG4gICAgICAgIG11dGFibGUuc2hvdWxkU2Nyb2xsID0gcmVzdWx0LmRhdGEuc2hvdWxkU2Nyb2xsXG4gICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gdXJsLmhhc2hcbiAgICAgICAgLy8gU2V0dGluZyB0aGlzIHRvIGFuIGVtcHR5IGFycmF5IHRyaWdnZXJzIGEgc2Nyb2xsIGZvciBhbGwgbmV3IGFuZFxuICAgICAgICAvLyB1cGRhdGVkIHNlZ21lbnRzLiBTZWUgYFNjcm9sbEFuZEZvY3VzSGFuZGxlcmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBbXVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLlN1Y2Nlc3M6IHtcbiAgICAgIC8vIFJlY2VpdmVkIGEgbmV3IHJlc3VsdC5cbiAgICAgIG11dGFibGUuY2FjaGUgPSByZXN1bHQuZGF0YS5jYWNoZU5vZGVcbiAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSByZXN1bHQuZGF0YS5mbGlnaHRSb3V0ZXJTdGF0ZVxuICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSByZXN1bHQuZGF0YS5jYW5vbmljYWxVcmxcbiAgICAgIG11dGFibGUuc2Nyb2xsYWJsZVNlZ21lbnRzID0gcmVzdWx0LmRhdGEuc2Nyb2xsYWJsZVNlZ21lbnRzXG4gICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHJlc3VsdC5kYXRhLnNob3VsZFNjcm9sbFxuICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgPSByZXN1bHQuZGF0YS5oYXNoXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9XG4gICAgY2FzZSBOYXZpZ2F0aW9uUmVzdWx0VGFnLkFzeW5jOiB7XG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGEudGhlbihcbiAgICAgICAgKGFzeW5jUmVzdWx0KSA9PlxuICAgICAgICAgIGhhbmRsZU5hdmlnYXRpb25SZXN1bHQodXJsLCBzdGF0ZSwgbXV0YWJsZSwgcGVuZGluZ1B1c2gsIGFzeW5jUmVzdWx0KSxcbiAgICAgICAgLy8gSWYgdGhlIG5hdmlnYXRpb24gZmFpbGVkLCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgbWF0Y2hlcyB0aGUgY3VycmVudCBiZWhhdmlvciBidXQgd2UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAgICAgICAgLy8gYmV0dGVyIGhlcmUgaWYgdGhlIG5ldHdvcmsgZmFpbHMuXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXN1bHQgc2F0aXNmaWVzIG5ldmVyXG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRlUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IE5hdmlnYXRlQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IHVybCwgaXNFeHRlcm5hbFVybCwgbmF2aWdhdGVUeXBlLCBzaG91bGRTY3JvbGwsIGFsbG93QWxpYXNpbmcgfSA9XG4gICAgYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuICBjb25zdCB7IGhhc2ggfSA9IHVybFxuICBjb25zdCBocmVmID0gY3JlYXRlSHJlZkZyb21VcmwodXJsKVxuICBjb25zdCBwZW5kaW5nUHVzaCA9IG5hdmlnYXRlVHlwZSA9PT0gJ3B1c2gnXG4gIC8vIHdlIHdhbnQgdG8gcHJ1bmUgdGhlIHByZWZldGNoIGNhY2hlIG9uIGV2ZXJ5IG5hdmlnYXRpb24gdG8gYXZvaWQgaXQgZ3Jvd2luZyB0b28gbGFyZ2VcbiAgcHJ1bmVQcmVmZXRjaENhY2hlKHN0YXRlLnByZWZldGNoQ2FjaGUpXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG4gIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaFxuXG4gIGlmIChpc0V4dGVybmFsVXJsKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwudG9TdHJpbmcoKSwgcGVuZGluZ1B1c2gpXG4gIH1cblxuICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgYDxtZXRhIGh0dHAtZXF1aXY9XCJyZWZyZXNoXCI+YCB0YWcgaXMgcHJlc2VudCxcbiAgLy8gd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIE1QQSBuYXZpZ2F0aW9uLlxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fbmV4dC1wYWdlLXJlZGlyZWN0JykpIHtcbiAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgIC8vIChWZXJ5IEVhcmx5IEV4cGVyaW1lbnRhbCBGZWF0dXJlKSBTZWdtZW50IENhY2hlXG4gICAgLy9cbiAgICAvLyBCeXBhc3MgdGhlIG5vcm1hbCBwcmVmZXRjaCBjYWNoZSBhbmQgdXNlIHRoZSBuZXcgcGVyLXNlZ21lbnQgY2FjaGVcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGlmIFBQUiBpcyBlbmFibGVkLCB0b28uXG4gICAgLy9cbiAgICAvLyBUZW1wb3JhcnkgZ2x1ZSBjb2RlIGJldHdlZW4gdGhlIHJvdXRlciByZWR1Y2VyIGFuZCB0aGUgbmV3IG5hdmlnYXRpb25cbiAgICAvLyBpbXBsZW1lbnRhdGlvbi4gRXZlbnR1YWxseSB3ZSdsbCByZXdyaXRlIHRoZSByb3V0ZXIgcmVkdWNlciB0byBhXG4gICAgLy8gc3RhdGUgbWFjaGluZS5cbiAgICBjb25zdCByZXN1bHQgPSBuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlKFxuICAgICAgdXJsLFxuICAgICAgc3RhdGUuY2FjaGUsXG4gICAgICBzdGF0ZS50cmVlLFxuICAgICAgc3RhdGUubmV4dFVybCxcbiAgICAgIHNob3VsZFNjcm9sbFxuICAgIClcbiAgICByZXR1cm4gaGFuZGxlTmF2aWdhdGlvblJlc3VsdCh1cmwsIHN0YXRlLCBtdXRhYmxlLCBwZW5kaW5nUHVzaCwgcmVzdWx0KVxuICB9XG5cbiAgY29uc3QgcHJlZmV0Y2hWYWx1ZXMgPSBnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgdXJsLFxuICAgIG5leHRVcmw6IHN0YXRlLm5leHRVcmwsXG4gICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIGFsbG93QWxpYXNpbmcsXG4gIH0pXG4gIGNvbnN0IHsgdHJlZUF0VGltZU9mUHJlZmV0Y2gsIGRhdGEgfSA9IHByZWZldGNoVmFsdWVzXG5cbiAgcHJlZmV0Y2hRdWV1ZS5idW1wKGRhdGEpXG5cbiAgcmV0dXJuIGRhdGEudGhlbihcbiAgICAoeyBmbGlnaHREYXRhLCBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlLCBwb3N0cG9uZWQgfSkgPT4ge1xuICAgICAgbGV0IGlzRmlyc3RSZWFkID0gZmFsc2VcbiAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBtYXJrIHRoaXMgb25jZVxuICAgICAgaWYgKCFwcmVmZXRjaFZhbHVlcy5sYXN0VXNlZFRpbWUpIHtcbiAgICAgICAgLy8gaW1wb3J0YW50OiB3ZSBzaG91bGQgb25seSBtYXJrIHRoZSBjYWNoZSBub2RlIGFzIGRpcnR5IGFmdGVyIHdlIHVuc3VzcGVuZCBmcm9tIHRoZSBjYWxsIGFib3ZlXG4gICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IERhdGUubm93KClcbiAgICAgICAgaXNGaXJzdFJlYWQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVmZXRjaFZhbHVlcy5hbGlhc2VkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhhbmRsZUFsaWFzZWRQcmVmZXRjaEVudHJ5KFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIG11dGFibGVcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFdlIGRpZG4ndCByZXR1cm4gbmV3IHJvdXRlciBzdGF0ZSBiZWNhdXNlIHdlIGRpZG4ndCBhcHBseSB0aGUgYWxpYXNlZCBlbnRyeSBmb3Igc29tZSByZWFzb24uXG4gICAgICAgIC8vIFdlJ2xsIHJlLWludm9rZSB0aGUgbmF2aWdhdGlvbiBoYW5kbGVyIGJ1dCBlbnN1cmUgdGhhdCB3ZSBkb24ndCBhdHRlbXB0IHRvIHVzZSB0aGUgYWxpYXNlZCBlbnRyeS4gVGhpc1xuICAgICAgICAvLyB3aWxsIGNyZWF0ZSBhbiBvbi1kZW1hbmQgcHJlZmV0Y2ggZW50cnkuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRlUmVkdWNlcihzdGF0ZSwgeyAuLi5hY3Rpb24sIGFsbG93QWxpYXNpbmc6IGZhbHNlIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGZsaWdodERhdGEsIHBlbmRpbmdQdXNoKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGVkQ2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgPyBjcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSlcbiAgICAgICAgOiBocmVmXG5cbiAgICAgIGNvbnN0IG9ubHlIYXNoQ2hhbmdlID1cbiAgICAgICAgISFoYXNoICYmXG4gICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybC5zcGxpdCgnIycsIDEpWzBdID09PVxuICAgICAgICAgIHVwZGF0ZWRDYW5vbmljYWxVcmwuc3BsaXQoJyMnLCAxKVswXVxuXG4gICAgICAvLyBJZiBvbmx5IHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGUgc2VydmVyIGhhc24ndCBzZW50IHVzIGFueSBuZXcgZGF0YS4gV2UgY2FuIGp1c3QgdXBkYXRlXG4gICAgICAvLyB0aGUgbXV0YWJsZSBwcm9wZXJ0aWVzIHJlc3BvbnNpYmxlIGZvciBVUkwgYW5kIHNjcm9sbCBoYW5kbGluZyBhbmQgcmV0dXJuIGVhcmx5LlxuICAgICAgaWYgKG9ubHlIYXNoQ2hhbmdlKSB7XG4gICAgICAgIG11dGFibGUub25seUhhc2hDaGFuZ2UgPSB0cnVlXG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXBkYXRlZENhbm9uaWNhbFVybFxuICAgICAgICBtdXRhYmxlLnNob3VsZFNjcm9sbCA9IHNob3VsZFNjcm9sbFxuICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IGhhc2hcbiAgICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBbXVxuICAgICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICAgIH1cblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG4gICAgICBsZXQgc2Nyb2xsYWJsZVNlZ21lbnRzOiBGbGlnaHRTZWdtZW50UGF0aFtdID0gW11cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGF0aFRvU2VnbWVudDogZmxpZ2h0U2VnbWVudFBhdGgsXG4gICAgICAgICAgc2VlZERhdGEsXG4gICAgICAgICAgaGVhZCxcbiAgICAgICAgICBpc0hlYWRQYXJ0aWFsLFxuICAgICAgICAgIGlzUm9vdFJlbmRlcixcbiAgICAgICAgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gICAgICAgIGxldCB0cmVlUGF0Y2ggPSBub3JtYWxpemVkRmxpZ2h0RGF0YS50cmVlXG5cbiAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aFdpdGhMZWFkaW5nRW1wdHkgPSBbJycsIC4uLmZsaWdodFNlZ21lbnRQYXRoXVxuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICBsZXQgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShcbiAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBocmVmXG4gICAgICAgIClcblxuICAgICAgICAvLyBJZiB0aGUgdHJlZSBwYXRjaCBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHRyZWUgdGhlbiB3ZSB1c2UgdGhlIHRyZWUgYXQgdGltZSBvZiBwcmVmZXRjaFxuICAgICAgICAvLyBUT0RPLUFQUDogVGhpcyBzaG91bGQgaW5zdGVhZCBmaWxsIGluIHRoZSBtaXNzaW5nIHBpZWNlcyBpbiBgY3VycmVudFRyZWVgIHdpdGggdGhlIGRhdGEgZnJvbSBgdHJlZUF0VGltZU9mUHJlZmV0Y2hgLCB0aGVuIGFwcGx5IHRoZSBwYXRjaC5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgZmxpZ2h0U2VnbWVudFBhdGhXaXRoTGVhZGluZ0VtcHR5LFxuICAgICAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2gsXG4gICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICBocmVmXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGp1c3QgYSBwYXJhbm9pZCBjaGVjay4gV2hlbiBhIHJvdXRlIGlzIFBQUmVkLCB0aGUgc2VydmVyXG4gICAgICAgICAgICAvLyB3aWxsIHNlbmQgYmFjayBhIHN0YXRpYyByZXNwb25zZSB0aGF0J3MgcmVuZGVyZWQgZnJvbVxuICAgICAgICAgICAgLy8gdGhlIHJvb3QuIElmIGZvciBzb21lIHJlYXNvbiBpdCBkb2Vzbid0LCB3ZSBmYWxsIGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBub24tUFBSIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlIGVsc2UgYnJhbmNoIGFuZCBkbyBhbGwgbmF2aWdhdGlvbnNcbiAgICAgICAgICAgIC8vIHZpYSBzdGFydFBQUk5hdmlnYXRpb24uIFRoZSBjdXJyZW50IHN0cnVjdHVyZSBpcyBqdXN0XG4gICAgICAgICAgICAvLyBhbiBpbmNyZW1lbnRhbCBzdGVwLlxuICAgICAgICAgICAgc2VlZERhdGEgJiZcbiAgICAgICAgICAgIGlzUm9vdFJlbmRlciAmJlxuICAgICAgICAgICAgcG9zdHBvbmVkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gc3RhcnRQUFJOYXZpZ2F0aW9uKFxuICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUsXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgICAgICB0cmVlUGF0Y2gsXG4gICAgICAgICAgICAgIHNlZWREYXRhLFxuICAgICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgICBpc0hlYWRQYXJ0aWFsLFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgc2Nyb2xsYWJsZVNlZ21lbnRzXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmICh0YXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0YXNrLnJvdXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZWN0ZWQgYSBjaGFuZ2UgdG8gdGhlIHJvb3QgbGF5b3V0LiBQZXJmb3JtIGFuIGZ1bGwtXG4gICAgICAgICAgICAgICAgLy8gcGFnZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSB0cmVlIGNvbXB1dGVkIGJ5IHN0YXJ0UFBSTmF2aWdhdGlvbiBpbnN0ZWFkXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBvbmUgY29tcHV0ZWQgYnkgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgcmVtb3ZlIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZVxuICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBQUFIgcGF0aCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZFJvdXRlclN0YXRlOiBGbGlnaHRSb3V0ZXJTdGF0ZSA9IHRhc2sucm91dGVcbiAgICAgICAgICAgICAgbmV3VHJlZSA9IHBhdGNoZWRSb3V0ZXJTdGF0ZVxuXG4gICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlID0gdGFzay5ub2RlXG4gICAgICAgICAgICAgIGlmIChuZXdDYWNoZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGNyZWF0ZWQgYSBuZXcgQ2FjaGUgTm9kZSB0cmVlIHRoYXQgY29udGFpbnMgYSBwcmVmZXRjaGVkXG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBvZiB0aGUgbmV4dCBwYWdlLiBUaGlzIGNhbiBiZSByZW5kZXJlZCBpbnN0YW50bHkuXG4gICAgICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IG5ld0NhY2hlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pY1JlcXVlc3RUcmVlID0gdGFzay5keW5hbWljUmVxdWVzdFRyZWVcbiAgICAgICAgICAgICAgaWYgKGR5bmFtaWNSZXF1ZXN0VHJlZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmZXRjaGVkIHRyZWUgaGFzIGR5bmFtaWMgaG9sZXMgaW4gaXQuIFdlIGluaXRpYXRlIGFcbiAgICAgICAgICAgICAgICAvLyBkeW5hbWljIHJlcXVlc3QgdG8gZmlsbCB0aGVtIGluLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGJsb2NrIG9uIHRoZSByZXN1bHQuIFdlJ2xsIGltbWVkaWF0ZWx5IHJlbmRlciB0aGUgQ2FjaGVcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHRyZWUgYW5kIHN1c3BlbmQgb24gdGhlIGR5bmFtaWMgcGFydHMuIFdoZW4gdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBjb21lcyBpbiwgd2UnbGwgZmlsbCBpbiBtaXNzaW5nIGRhdGEgYW5kIHBpbmcgUmVhY3QgdG9cbiAgICAgICAgICAgICAgICAvLyByZS1yZW5kZXIuIFVubGlrZSB0aGUgbGF6eSBmZXRjaGluZyBtb2RlbCBpbiB0aGUgbm9uLVBQUlxuICAgICAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB0aGlzIGlzIG1vZGVsZWQgYXMgYSBzaW5nbGUgUmVhY3QgdXBkYXRlICtcbiAgICAgICAgICAgICAgICAvLyBzdHJlYW1pbmcsIHJhdGhlciB0aGFuIG11bHRpcGxlIHRvcC1sZXZlbCB1cGRhdGVzLiAoSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyBldmVuIGluIHRoZSBuZXcgbW9kZWwsIHdlJ2xsIHN0aWxsIG5lZWQgdG8gc29tZXRpbWVzIHVwZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByb290IG11bHRpcGxlIHRpbWVzIHBlciBuYXZpZ2F0aW9uLCBsaWtlIGlmIHRoZSBzZXJ2ZXIgc2VuZHMgdXNcbiAgICAgICAgICAgICAgICAvLyBhIGRpZmZlcmVudCByZXNwb25zZSB0aGFuIHdlIGV4cGVjdGVkLiBGb3Igbm93LCB3ZSByZXZlcnQgYmFja1xuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBsYXp5IGZldGNoaW5nIG1lY2hhbmlzbSBpbiB0aGF0IGNhc2UuKVxuICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZXF1ZXN0ID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIHtcbiAgICAgICAgICAgICAgICAgIGZsaWdodFJvdXRlclN0YXRlOiBkeW5hbWljUmVxdWVzdFRyZWUsXG4gICAgICAgICAgICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBsaXN0ZW5Gb3JEeW5hbWljUmVxdWVzdCh0YXNrLCBkeW5hbWljUmVxdWVzdClcbiAgICAgICAgICAgICAgICAvLyBXZSBzdG9yZSB0aGUgZHluYW1pYyByZXF1ZXN0IG9uIHRoZSBgbGF6eURhdGFgIHByb3BlcnR5IG9mIHRoZSBDYWNoZU5vZGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlJ3JlIG5vdCBnb2luZyB0byBhd2FpdCB0aGUgZHluYW1pYyByZXF1ZXN0IGhlcmUuIFNpbmNlIHdlJ3JlIG5vdCBibG9ja2luZ1xuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBkeW5hbWljIHJlcXVlc3QsIGBsYXlvdXQtcm91dGVyYCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdGFzay5ub2RlLmxhenlEYXRhID0gZHluYW1pY1JlcXVlc3RcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJlZmV0Y2hlZCB0cmVlIGRvZXMgbm90IGNvbnRhaW4gZHluYW1pYyBob2xlcyDigJQgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGZ1bGx5IHN0YXRpYy4gV2UgY2FuIHNraXAgdGhlIGR5bmFtaWMgcmVxdWVzdC5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBzbyByZXVzZSB0aGUgb2xkIGNhY2hlLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHRoZSBoZWFkIGNoYW5nZWQgYnV0IG5vdCBhbnkgb2YgdGhlIHNlZ21lbnQgZGF0YT9cbiAgICAgICAgICAgICAgLy8gSXMgdGhhdCBwb3NzaWJsZT8gSWYgc28sIHdlIHNob3VsZCBjbG9uZSB0aGUgd2hvbGUgdHJlZSBhbmRcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBoZWFkLlxuICAgICAgICAgICAgICBuZXdUcmVlID0gdHJlZVBhdGNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBzdGF0aWMgcmVzcG9uc2UgZG9lcyBub3QgaW5jbHVkZSBhbnkgZHluYW1pYyBob2xlcywgc29cbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBkbyBhIHNlY29uZCByZXF1ZXN0LlxuICAgICAgICAgICAgLy8gVE9ETzogQXMgYW4gaW5jcmVtZW50YWwgc3RlcCB0aGlzIGp1c3QgcmV2ZXJ0cyBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gbm9uLVBQUiBpbXBsZW1lbnRhdGlvbi4gV2UgY2FuIHNpbXBsaWZ5IHRoaXMgYnJhbmNoIGZ1cnRoZXIsXG4gICAgICAgICAgICAvLyBnaXZlbiB0aGF0IFBQUiBwcmVmZXRjaGVzIGFyZSBhbHdheXMgc3RhdGljIGFuZCByZXR1cm4gdGhlIHdob2xlXG4gICAgICAgICAgICAvLyB0cmVlLiBPciBpbiB0aGUgbWVhbnRpbWUgd2UgY291bGQgZmFjdG9yIGl0IG91dCBpbnRvIGFcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIGZ1bmN0aW9uLlxuXG4gICAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoc3RhdGUsIG11dGFibGUsIGhyZWYsIHBlbmRpbmdQdXNoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAgICAgICAgICAgbGV0IGFwcGxpZWQgPSBmYWxzZVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLnN0YXR1cyA9PT0gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLnN0YWxlICYmXG4gICAgICAgICAgICAgICFpc0ZpcnN0UmVhZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBhIHN0YWxlIHByZWZldGNoIGVudHJ5LCB3ZSBvbmx5IHdhbnQgdG8gcmUtdXNlIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoZSByb3V0ZSB3ZSdyZSBuYXZpZ2F0aW5nIHRvLCB0byBzdXBwb3J0IGluc3RhbnQgbG9hZGluZyBuYXZpZ2F0aW9uc1xuICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgdHJpZ2dlciBhIGxhenkgZmV0Y2ggZm9yIHRoZSBhY3R1YWwgcGFnZSBkYXRhIGJ5IG51bGxpbmcgdGhlIGByc2NgIGFuZCBgcHJlZmV0Y2hSc2NgIHZhbHVlcyBmb3IgcGFnZSBkYXRhLFxuICAgICAgICAgICAgICAvLyB3aGlsZSBjb3B5aW5nIG92ZXIgdGhlIGBsb2FkaW5nYCBmb3IgdGhlIHNlZ21lbnQgdGhhdCBjb250YWlucyB0aGUgcGFnZSBkYXRhLlxuICAgICAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgb24gc3Vic2VxdWVudCByZWFkcywgYXMgb3RoZXJ3aXNlIHRoZXJlJ2QgYmUgbm8gbG9hZGluZyBkYXRhIHRvIHJlLXVzZS5cblxuICAgICAgICAgICAgICAvLyBXZSBza2lwIHRoaXMgYnJhbmNoIGlmIG9ubHkgdGhlIGhhc2ggZnJhZ21lbnQgaGFzIGNoYW5nZWQsIGFzIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGxhenkgZmV0Y2ggaW4gdGhhdCBjYXNlXG4gICAgICAgICAgICAgIGFwcGxpZWQgPSB0cmlnZ2VyTGF6eUZldGNoRm9yTGVhZlNlZ21lbnRzKFxuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICB0cmVlUGF0Y2hcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSByZS11c2VkIHRoZSBzdGFsZSBjYWNoZSdzIGxvYWRpbmcgc3RhdGUgJiByZWZyZXNoZWQgdGhlIGRhdGEsXG4gICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYGxhc3RVc2VkVGltZWAgc28gdGhhdCBpdCBjYW4gY29udGludWUgdG8gYmUgcmUtdXNlZCBmb3IgdGhlIG5leHQgMzBzXG4gICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzLmxhc3RVc2VkVGltZSA9IERhdGUubm93KClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGxpZWQgPSBhcHBseUZsaWdodERhdGEoXG4gICAgICAgICAgICAgICAgY3VycmVudENhY2hlLFxuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhLFxuICAgICAgICAgICAgICAgIHByZWZldGNoVmFsdWVzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gc2hvdWxkSGFyZE5hdmlnYXRlKFxuICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgIGZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSxcbiAgICAgICAgICAgICAgY3VycmVudFRyZWVcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYgKGhhcmROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAvLyBDb3B5IHJzYyBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgIGNhY2hlLnJzYyA9IGN1cnJlbnRDYWNoZS5yc2NcbiAgICAgICAgICAgICAgY2FjaGUucHJlZmV0Y2hSc2MgPSBjdXJyZW50Q2FjaGUucHJlZmV0Y2hSc2NcblxuICAgICAgICAgICAgICBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKFxuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZXhpc3RpbmcgY2FjaGUgdmFsdWUgaXMgdXNlZCB3aGVuIHRoZSBjYWNoZSB3YXMgbm90IGludmFsaWRhdGVkLlxuICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXBwbGllZCkge1xuICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICAgICAgLy8gSWYgd2UgYXBwbGllZCB0aGUgY2FjaGUsIHdlIHVwZGF0ZSB0aGUgXCJjdXJyZW50IGNhY2hlXCIgdmFsdWUgc28gYW55IG90aGVyXG4gICAgICAgICAgICAgIC8vIHNlZ21lbnRzIGluIHRoZSBGbGlnaHREYXRhUGF0aCB3aWxsIGJlIGFibGUgdG8gcmVmZXJlbmNlIHRoZSB1cGRhdGVkIGNhY2hlLlxuICAgICAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YlNlZ21lbnQgb2YgZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCh0cmVlUGF0Y2gpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNjcm9sbGFibGVTZWdtZW50UGF0aCA9IFtcbiAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICAuLi5zdWJTZWdtZW50LFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIF9fREVGQVVMVF9fIHBhdGhzIGFzIHRoZXkgc2hvdWxkbid0IGJlIHNjcm9sbGVkIHRvIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHNjcm9sbGFibGVTZWdtZW50UGF0aFtzY3JvbGxhYmxlU2VnbWVudFBhdGgubGVuZ3RoIC0gMV0gIT09XG4gICAgICAgICAgICAgICAgREVGQVVMVF9TRUdNRU5UX0tFWVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlU2VnbWVudHMucHVzaChzY3JvbGxhYmxlU2VnbWVudFBhdGgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gY3VycmVudFRyZWVcbiAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gdXBkYXRlZENhbm9uaWNhbFVybFxuICAgICAgbXV0YWJsZS5zY3JvbGxhYmxlU2VnbWVudHMgPSBzY3JvbGxhYmxlU2VnbWVudHNcbiAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gaGFzaFxuICAgICAgbXV0YWJsZS5zaG91bGRTY3JvbGwgPSBzaG91bGRTY3JvbGxcblxuICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpXG4gICAgfSxcbiAgICAoKSA9PiBzdGF0ZVxuICApXG59XG4iXSwibmFtZXMiOlsiaGFuZGxlRXh0ZXJuYWxVcmwiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJzdGF0ZSIsIm11dGFibGUiLCJ1cmwiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJjYW5vbmljYWxVcmwiLCJzY3JvbGxhYmxlU2VnbWVudHMiLCJ1bmRlZmluZWQiLCJoYW5kbGVNdXRhYmxlIiwiZ2VuZXJhdGVTZWdtZW50c0Zyb21QYXRjaCIsImZsaWdodFJvdXRlclBhdGNoIiwic2VnbWVudHMiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZUtleSIsInBhcmFsbGVsUm91dGUiLCJlbnRyaWVzIiwiY2hpbGRTZWdtZW50IiwicHVzaCIsInRyaWdnZXJMYXp5RmV0Y2hGb3JMZWFmU2VnbWVudHMiLCJuZXdDYWNoZSIsImN1cnJlbnRDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwidHJlZVBhdGNoIiwiYXBwbGllZFBhdGNoIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJsb2FkaW5nIiwiTWFwIiwic2VnbWVudFBhdGhzVG9GaWxsIiwibWFwIiwic2VnbWVudFBhdGhzIiwiY2xlYXJDYWNoZU5vZGVEYXRhRm9yU2VnbWVudFBhdGgiLCJoYW5kbGVOYXZpZ2F0aW9uUmVzdWx0IiwicmVzdWx0IiwidGFnIiwiTmF2aWdhdGlvblJlc3VsdFRhZyIsIk1QQSIsIm5ld1VybCIsImRhdGEiLCJOb09wIiwibmV3Q2Fub25pY2FsVXJsIiwib2xkVXJsIiwiVVJMIiwib25seUhhc2hDaGFuZ2UiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJzaG91bGRTY3JvbGwiLCJoYXNoRnJhZ21lbnQiLCJTdWNjZXNzIiwiY2FjaGUiLCJjYWNoZU5vZGUiLCJwYXRjaGVkVHJlZSIsImZsaWdodFJvdXRlclN0YXRlIiwiQXN5bmMiLCJ0aGVuIiwiYXN5bmNSZXN1bHQiLCJhY3Rpb24iLCJpc0V4dGVybmFsVXJsIiwibmF2aWdhdGVUeXBlIiwiYWxsb3dBbGlhc2luZyIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInBydW5lUHJlZmV0Y2hDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsInRvU3RyaW5nIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJuYXZpZ2F0ZVVzaW5nU2VnbWVudENhY2hlIiwidHJlZSIsIm5leHRVcmwiLCJwcmVmZXRjaFZhbHVlcyIsImdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5IiwidHJlZUF0VGltZU9mUHJlZmV0Y2giLCJwcmVmZXRjaFF1ZXVlIiwiYnVtcCIsImZsaWdodERhdGEiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInBvc3Rwb25lZCIsImlzRmlyc3RSZWFkIiwibGFzdFVzZWRUaW1lIiwiRGF0ZSIsIm5vdyIsImFsaWFzZWQiLCJoYW5kbGVBbGlhc2VkUHJlZmV0Y2hFbnRyeSIsInVwZGF0ZWRDYW5vbmljYWxVcmwiLCJzcGxpdCIsImN1cnJlbnRUcmVlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJwYXRoVG9TZWdtZW50Iiwic2VlZERhdGEiLCJoZWFkIiwiaXNIZWFkUGFydGlhbCIsImlzUm9vdFJlbmRlciIsImZsaWdodFNlZ21lbnRQYXRoV2l0aExlYWRpbmdFbXB0eSIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJ0YXNrIiwic3RhcnRQUFJOYXZpZ2F0aW9uIiwicm91dGUiLCJwYXRjaGVkUm91dGVyU3RhdGUiLCJub2RlIiwiZHluYW1pY1JlcXVlc3RUcmVlIiwiZHluYW1pY1JlcXVlc3QiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwibGlzdGVuRm9yRHluYW1pY1JlcXVlc3QiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImFwcGxpZWQiLCJzdGF0dXMiLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJzdGFsZSIsImFwcGx5RmxpZ2h0RGF0YSIsImhhcmROYXZpZ2F0ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJzdWJTZWdtZW50Iiwic2Nyb2xsYWJsZVNlZ21lbnRQYXRoIiwiREVGQVVMVF9TRUdNRU5UX0tFWSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    prefetchQueue: function() {\n        return prefetchQueue;\n    },\n    prefetchReducer: function() {\n        return prefetchReducer;\n    }\n});\nconst _promisequeue = __webpack_require__(/*! ../../promise-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/promise-queue.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst prefetchQueue = new _promisequeue.PromiseQueue(5);\nconst prefetchReducer =  false ? 0 : prefetchReducerImpl;\nfunction identityReducerWhenSegmentCacheIsEnabled(state) {\n    // Unlike the old implementation, the Segment Cache doesn't store its data in\n    // the router reducer state.\n    //\n    // This shouldn't be reachable because we wrap the prefetch API in a check,\n    // too, which prevents the action from being dispatched. But it's here for\n    // clarity + code elimination.\n    return state;\n}\nfunction prefetchReducerImpl(state, action) {\n    // let's prune the prefetch cache before we do anything else\n    (0, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);\n    const { url } = action;\n    (0, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({\n        url,\n        nextUrl: state.nextUrl,\n        prefetchCache: state.prefetchCache,\n        kind: action.kind,\n        tree: state.tree,\n        allowAliasing: true\n    });\n    return state;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFVYUEsYUFBYTtlQUFiQTs7SUFFQUMsZUFBZTtlQUFmQTs7OzBDQVBnQjtnREFJdEI7QUFDQSxNQUFNRCxnQkFBZ0IsSUFBSUUsY0FBQUEsWUFBWSxDQUFDO0FBRXZDLE1BQU1ELGtCQUFrQkUsTUFBdUMsR0FDbEVHLENBQXdDQSxHQUN4Q0M7QUFFSixTQUFTRCx5Q0FBNENFLEtBQVE7SUFDM0QsNkVBQTZFO0lBQzdFLDRCQUE0QjtJQUM1QixFQUFFO0lBQ0YsMkVBQTJFO0lBQzNFLDBFQUEwRTtJQUMxRSw4QkFBOEI7SUFDOUIsT0FBT0E7QUFDVDtBQUVBLFNBQVNELG9CQUNQQyxLQUEyQixFQUMzQkMsTUFBc0I7SUFFdEIsNERBQTREO0lBQzVEQyxDQUFBQSxHQUFBQSxvQkFBQUEsa0JBQUFBLEVBQW1CRixNQUFNRyxhQUFhO0lBRXRDLE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdIO0lBRWhCSSxDQUFBQSxHQUFBQSxvQkFBQUEsNkJBQUFBLEVBQThCO1FBQzVCRDtRQUNBRSxTQUFTTixNQUFNTSxPQUFPO1FBQ3RCSCxlQUFlSCxNQUFNRyxhQUFhO1FBQ2xDSSxNQUFNTixPQUFPTSxJQUFJO1FBQ2pCQyxNQUFNUixNQUFNUSxJQUFJO1FBQ2hCQyxlQUFlO0lBQ2pCO0lBRUEsT0FBT1Q7QUFDVCIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgUHJlZmV0Y2hBY3Rpb24sXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgUHJvbWlzZVF1ZXVlIH0gZnJvbSAnLi4vLi4vcHJvbWlzZS1xdWV1ZSdcbmltcG9ydCB7XG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5LFxuICBwcnVuZVByZWZldGNoQ2FjaGUsXG59IGZyb20gJy4uL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuZXhwb3J0IGNvbnN0IHByZWZldGNoUXVldWUgPSBuZXcgUHJvbWlzZVF1ZXVlKDUpXG5cbmV4cG9ydCBjb25zdCBwcmVmZXRjaFJlZHVjZXIgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgPyBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkXG4gIDogcHJlZmV0Y2hSZWR1Y2VySW1wbFxuXG5mdW5jdGlvbiBpZGVudGl0eVJlZHVjZXJXaGVuU2VnbWVudENhY2hlSXNFbmFibGVkPFQ+KHN0YXRlOiBUKTogVCB7XG4gIC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0cyBkYXRhIGluXG4gIC8vIHRoZSByb3V0ZXIgcmVkdWNlciBzdGF0ZS5cbiAgLy9cbiAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlIGJlY2F1c2Ugd2Ugd3JhcCB0aGUgcHJlZmV0Y2ggQVBJIGluIGEgY2hlY2ssXG4gIC8vIHRvbywgd2hpY2ggcHJldmVudHMgdGhlIGFjdGlvbiBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuIEJ1dCBpdCdzIGhlcmUgZm9yXG4gIC8vIGNsYXJpdHkgKyBjb2RlIGVsaW1pbmF0aW9uLlxuICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gcHJlZmV0Y2hSZWR1Y2VySW1wbChcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFByZWZldGNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICAvLyBsZXQncyBwcnVuZSB0aGUgcHJlZmV0Y2ggY2FjaGUgYmVmb3JlIHdlIGRvIGFueXRoaW5nIGVsc2VcbiAgcHJ1bmVQcmVmZXRjaENhY2hlKHN0YXRlLnByZWZldGNoQ2FjaGUpXG5cbiAgY29uc3QgeyB1cmwgfSA9IGFjdGlvblxuXG4gIGdldE9yQ3JlYXRlUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICB1cmwsXG4gICAgbmV4dFVybDogc3RhdGUubmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgIGtpbmQ6IGFjdGlvbi5raW5kLFxuICAgIHRyZWU6IHN0YXRlLnRyZWUsXG4gICAgYWxsb3dBbGlhc2luZzogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gc3RhdGVcbn1cbiJdLCJuYW1lcyI6WyJwcmVmZXRjaFF1ZXVlIiwicHJlZmV0Y2hSZWR1Y2VyIiwiUHJvbWlzZVF1ZXVlIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsImlkZW50aXR5UmVkdWNlcldoZW5TZWdtZW50Q2FjaGVJc0VuYWJsZWQiLCJwcmVmZXRjaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJwcnVuZVByZWZldGNoQ2FjaGUiLCJwcmVmZXRjaENhY2hlIiwidXJsIiwiZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkiLCJuZXh0VXJsIiwia2luZCIsInRyZWUiLCJhbGxvd0FsaWFzaW5nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"refreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return refreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nfunction refreshReducer(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            currentTree[0],\n            currentTree[1],\n            currentTree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null\n    });\n    return cache.lazyData.then(async (param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            // Handles case where prefetch only returns the router tree patch without rendered components.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const loading = cacheNodeSeedData[3];\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = loading;\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n            }\n            await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                state,\n                updatedTree: newTree,\n                updatedCache: cache,\n                includeNextUrl,\n                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n            });\n            mutable.cache = cache;\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7a0RBb0JnQkE7OztlQUFBQTs7O2lEQXBCb0I7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7MkRBRWdCO3VDQUNUO21EQUNDOytEQUNZOzZEQUNGOzBDQUNWO0FBRS9CLFNBQVNBLGVBQ2RDLEtBQTJCLEVBQzNCQyxNQUFxQjtJQUVyQixNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRDtJQUNuQixNQUFNRSxVQUFtQixDQUFDO0lBQzFCLE1BQU1DLE9BQU9KLE1BQU1LLFlBQVk7SUFFL0IsSUFBSUMsY0FBY04sTUFBTU8sSUFBSTtJQUU1QkosUUFBUUssMEJBQTBCLEdBQUc7SUFFckMsTUFBTUMsUUFBbUJDLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFBQTtJQUV6QixzRkFBc0Y7SUFDdEYsc0hBQXNIO0lBQ3RILE1BQU1DLGlCQUFpQkMsQ0FBQUEsR0FBQUEsbUNBQUFBLGlDQUFpQyxFQUFDWixNQUFNTyxJQUFJO0lBRW5FLHVEQUF1RDtJQUN2RCx3Q0FBd0M7SUFDeENFLE1BQU1JLFFBQVEsR0FBR0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQixJQUFJQyxJQUFJWCxNQUFNRixTQUFTO1FBQzFEYyxtQkFBbUI7WUFDakJWLFdBQVcsQ0FBQyxFQUFFO1lBQ2RBLFdBQVcsQ0FBQyxFQUFFO1lBQ2RBLFdBQVcsQ0FBQyxFQUFFO1lBQ2Q7U0FDRDtRQUNEVyxTQUFTTixpQkFBaUJYLE1BQU1pQixPQUFPLEdBQUc7SUFDNUM7SUFFQSxPQUFPUixNQUFNSSxRQUFRLENBQUNLLElBQUksQ0FDeEI7WUFBTyxFQUFFQyxVQUFVLEVBQUVkLGNBQWNlLG9CQUFvQixFQUFFO1FBQ3ZELDREQUE0RDtRQUM1RCxJQUFJLE9BQU9ELGVBQWUsVUFBVTtZQUNsQyxPQUFPRSxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0xyQixPQUNBRyxTQUNBZ0IsWUFDQW5CLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7UUFFN0I7UUFFQSwrREFBK0Q7UUFDL0RkLE1BQU1JLFFBQVEsR0FBRztRQUVqQixLQUFLLE1BQU1XLHdCQUF3QkwsV0FBWTtZQUM3QyxNQUFNLEVBQ0paLE1BQU1rQixTQUFTLEVBQ2ZDLFVBQVVDLGlCQUFpQixFQUMzQkMsSUFBSSxFQUNKQyxZQUFZLEVBQ2IsR0FBR0w7WUFFSixJQUFJLENBQUNLLGNBQWM7Z0JBQ2pCLG9DQUFvQztnQkFDcENDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPL0I7WUFDVDtZQUVBLE1BQU1nQyxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQ2Q7Z0JBQ0M7YUFBRyxFQUNKM0IsYUFDQW1CLFdBQ0F6QixNQUFNSyxZQUFZO1lBR3BCLElBQUkyQixZQUFZLE1BQU07Z0JBQ3BCLE9BQU9FLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBcUIsRUFBQ2xDLE9BQU9DLFFBQVF3QjtZQUM5QztZQUVBLElBQUlVLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFBNEI3QixhQUFhMEIsVUFBVTtnQkFDckQsT0FBT1gsQ0FBQUEsR0FBQUEsaUJBQUFBLGlCQUFpQixFQUN0QnJCLE9BQ0FHLFNBQ0FDLE1BQ0FKLE1BQU1zQixPQUFPLENBQUNDLFdBQVc7WUFFN0I7WUFFQSxNQUFNYSwyQkFBMkJoQix1QkFDN0JpQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCakIsd0JBQ2xCa0I7WUFFSixJQUFJbEIsc0JBQXNCO2dCQUN4QmpCLFFBQVFFLFlBQVksR0FBRytCO1lBQ3pCO1lBRUEsOEZBQThGO1lBQzlGLElBQUlULHNCQUFzQixNQUFNO2dCQUM5QixNQUFNWSxNQUFNWixpQkFBaUIsQ0FBQyxFQUFFO2dCQUNoQyxNQUFNYSxVQUFVYixpQkFBaUIsQ0FBQyxFQUFFO2dCQUNwQ2xCLE1BQU04QixHQUFHLEdBQUdBO2dCQUNaOUIsTUFBTWdDLFdBQVcsR0FBRztnQkFDcEJoQyxNQUFNK0IsT0FBTyxHQUFHQTtnQkFDaEJFLENBQUFBLEdBQUFBLCtCQUFBQSw2QkFBQUEsRUFDRWpDLE9BRUE2QixXQUNBYixXQUNBRSxtQkFDQUMsTUFDQVU7Z0JBRUYsSUFBSUssS0FBdUMsRUFBRSxFQUU1QyxNQUFNO29CQUNMeEMsUUFBUTRDLGFBQWEsR0FBRyxJQUFJQztnQkFDOUI7WUFDRjtZQUVBLE1BQU1DLENBQUFBLEdBQUFBLGlDQUFBQSwrQkFBQUEsRUFBZ0M7Z0JBQ3BDakQ7Z0JBQ0FrRCxhQUFhbEI7Z0JBQ2JtQixjQUFjMUM7Z0JBQ2RFO2dCQUNBTixjQUFjRixRQUFRRSxZQUFZLElBQUlMLE1BQU1LLFlBQVk7WUFDMUQ7WUFFQUYsUUFBUU0sS0FBSyxHQUFHQTtZQUNoQk4sUUFBUWlELFdBQVcsR0FBR3BCO1lBRXRCMUIsY0FBYzBCO1FBQ2hCO1FBRUEsT0FBT3FCLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWNyRCxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVYiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgTXV0YWJsZSxcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgUmVmcmVzaEFjdGlvbixcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCB9IGZyb20gJy4uL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkJ1xuaW1wb3J0IHsgY3JlYXRlRW1wdHlDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi9hcHAtcm91dGVyJ1xuaW1wb3J0IHsgaGFuZGxlU2VnbWVudE1pc21hdGNoIH0gZnJvbSAnLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2gnXG5pbXBvcnQgeyBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUgfSBmcm9tICcuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlJ1xuaW1wb3J0IHsgcmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyB9IGZyb20gJy4uL3JlZmV0Y2gtaW5hY3RpdmUtcGFyYWxsZWwtc2VnbWVudHMnXG5pbXBvcnQgeyByZXZhbGlkYXRlRW50aXJlQ2FjaGUgfSBmcm9tICcuLi8uLi9zZWdtZW50LWNhY2hlJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVmcmVzaFJlZHVjZXIoXG4gIHN0YXRlOiBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgYWN0aW9uOiBSZWZyZXNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7IG9yaWdpbiB9ID0gYWN0aW9uXG4gIGNvbnN0IG11dGFibGU6IE11dGFibGUgPSB7fVxuICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsXG5cbiAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG5cbiAgLy8gSWYgdGhlIGN1cnJlbnQgdHJlZSB3YXMgaW50ZXJjZXB0ZWQsIHRoZSBuZXh0VXJsIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC5cbiAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB0aGUgcmVmcmVzaCByZXF1ZXN0IGRvZXNuJ3QgZ2V0IGludGVyY2VwdGVkLCBhY2NpZGVudGFsbHkgdHJpZ2dlcmluZyB0aGUgaW50ZXJjZXB0aW9uIHJvdXRlLlxuICBjb25zdCBpbmNsdWRlTmV4dFVybCA9IGhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZShzdGF0ZS50cmVlKVxuXG4gIC8vIFRPRE8tQVBQOiB2ZXJpZnkgdGhhdCBgaHJlZmAgaXMgbm90IGFuIGV4dGVybmFsIHVybC5cbiAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICBjYWNoZS5sYXp5RGF0YSA9IGZldGNoU2VydmVyUmVzcG9uc2UobmV3IFVSTChocmVmLCBvcmlnaW4pLCB7XG4gICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtcbiAgICAgIGN1cnJlbnRUcmVlWzBdLFxuICAgICAgY3VycmVudFRyZWVbMV0sXG4gICAgICBjdXJyZW50VHJlZVsyXSxcbiAgICAgICdyZWZldGNoJyxcbiAgICBdLFxuICAgIG5leHRVcmw6IGluY2x1ZGVOZXh0VXJsID8gc3RhdGUubmV4dFVybCA6IG51bGwsXG4gIH0pXG5cbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgYXN5bmMgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0cmVlOiB0cmVlUGF0Y2gsXG4gICAgICAgICAgc2VlZERhdGE6IGNhY2hlTm9kZVNlZWREYXRhLFxuICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgaXNSb290UmVuZGVyLFxuICAgICAgICB9ID0gbm9ybWFsaXplZEZsaWdodERhdGFcblxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgICAgICAgaWYgKGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMV1cbiAgICAgICAgICBjb25zdCBsb2FkaW5nID0gY2FjaGVOb2RlU2VlZERhdGFbM11cbiAgICAgICAgICBjYWNoZS5yc2MgPSByc2NcbiAgICAgICAgICBjYWNoZS5wcmVmZXRjaFJzYyA9IG51bGxcbiAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gbG9hZGluZ1xuICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAvLyBFeGlzdGluZyBjYWNoZSBpcyBub3QgcGFzc2VkIGluIGFzIGByb3V0ZXIucmVmcmVzaCgpYCBoYXMgdG8gaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLlxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgICAgY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUpIHtcbiAgICAgICAgICAgIHJldmFsaWRhdGVFbnRpcmVDYWNoZShzdGF0ZS5uZXh0VXJsLCBuZXdUcmVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdXRhYmxlLnByZWZldGNoQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHtcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB1cGRhdGVkVHJlZTogbmV3VHJlZSxcbiAgICAgICAgICB1cGRhdGVkQ2FjaGU6IGNhY2hlLFxuICAgICAgICAgIGluY2x1ZGVOZXh0VXJsLFxuICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmwgfHwgc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICB9KVxuXG4gICAgICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZVxuXG4gICAgICAgIGN1cnJlbnRUcmVlID0gbmV3VHJlZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJyZWZyZXNoUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwib3JpZ2luIiwibXV0YWJsZSIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJjdXJyZW50VHJlZSIsInRyZWUiLCJwcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJpbmNsdWRlTmV4dFVybCIsImhhc0ludGVyY2VwdGlvblJvdXRlSW5DdXJyZW50VHJlZSIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInRoZW4iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZVBhdGNoIiwic2VlZERhdGEiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwicnNjIiwibG9hZGluZyIsInByZWZldGNoUnNjIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicmV2YWxpZGF0ZUVudGlyZUNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsIk1hcCIsInJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMiLCJ1cGRhdGVkVHJlZSIsInVwZGF0ZWRDYWNoZSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js ***!
  \*********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"restoreReducer\", ({\n    enumerable: true,\n    get: function() {\n        return restoreReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _computechangedpath = __webpack_require__(/*! ../compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _pprnavigations = __webpack_require__(/*! ../ppr-navigations */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/ppr-navigations.js\");\nfunction restoreReducer(state, action) {\n    const { url, tree } = action;\n    const href = (0, _createhreffromurl.createHrefFromUrl)(url);\n    // This action is used to restore the router state from the history state.\n    // However, it's possible that the history state no longer contains the `FlightRouterState`.\n    // We will copy over the internal state on pushState/replaceState events, but if a history entry\n    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n    // the history state will not contain the `FlightRouterState`.\n    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n    const treeToRestore = tree || state.tree;\n    const oldCache = state.cache;\n    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a\n    // back/forward navigation.\n    0 : oldCache;\n    var _extractPathFromFlightRouterState;\n    return {\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // Ensures that the custom history state that was set is preserved when applying this update.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: newCache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: treeToRestore,\n        nextUrl: (_extractPathFromFlightRouterState = (0, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcmVzdG9yZS1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7a0RBU2dCQTs7O2VBQUFBOzs7K0NBVGtCO2dEQU1lOzRDQUNJO0FBRTlDLFNBQVNBLGVBQ2RDLEtBQTJCLEVBQzNCQyxNQUFxQjtJQUVyQixNQUFNLEVBQUVDLEdBQUcsRUFBRUMsSUFBSSxFQUFFLEdBQUdGO0lBQ3RCLE1BQU1HLE9BQU9DLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JIO0lBQy9CLDBFQUEwRTtJQUMxRSw0RkFBNEY7SUFDNUYsZ0dBQWdHO0lBQ2hHLDZGQUE2RjtJQUM3Riw4REFBOEQ7SUFDOUQseUdBQXlHO0lBQ3pHLE1BQU1JLGdCQUFnQkgsUUFBUUgsTUFBTUcsSUFBSTtJQUV4QyxNQUFNSSxXQUFXUCxNQUFNUSxLQUFLO0lBQzVCLE1BQU1DLFdBQVdDLE1BQXNCLEdBRW5DLDJEQUMyRDtJQUMzRCwyQkFBMkI7SUFDM0JHLENBQTZEUCxHQUM3REM7UUFnQk9PO0lBZFgsT0FBTztRQUNMLG9CQUFvQjtRQUNwQkMsY0FBY1g7UUFDZFksU0FBUztZQUNQQyxhQUFhO1lBQ2JDLGVBQWU7WUFDZiw2RkFBNkY7WUFDN0ZDLDRCQUE0QjtRQUM5QjtRQUNBQyxtQkFBbUJwQixNQUFNb0IsaUJBQWlCO1FBQzFDWixPQUFPQztRQUNQWSxlQUFlckIsTUFBTXFCLGFBQWE7UUFDbEMsd0JBQXdCO1FBQ3hCbEIsTUFBTUc7UUFDTmdCLFNBQVNSLENBQUFBLG9DQUFBQSxDQUFBQSxHQUFBQSxvQkFBQUEsZ0NBQUFBLEVBQWlDUixjQUFBQSxLQUFBQSxPQUFqQ1Esb0NBQW1EWixJQUFJcUIsUUFBUTtJQUMxRTtBQUNGIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3Jlc3RvcmUtcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHR5cGUge1xuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgUmVkdWNlclN0YXRlLFxuICBSZXN0b3JlQWN0aW9uLFxufSBmcm9tICcuLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi4vY29tcHV0ZS1jaGFuZ2VkLXBhdGgnXG5pbXBvcnQgeyB1cGRhdGVDYWNoZU5vZGVPblBvcHN0YXRlUmVzdG9yYXRpb24gfSBmcm9tICcuLi9wcHItbmF2aWdhdGlvbnMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlc3RvcmVBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIGNvbnN0IHsgdXJsLCB0cmVlIH0gPSBhY3Rpb25cbiAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybClcbiAgLy8gVGhpcyBhY3Rpb24gaXMgdXNlZCB0byByZXN0b3JlIHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgLy8gSG93ZXZlciwgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBoaXN0b3J5IHN0YXRlIG5vIGxvbmdlciBjb250YWlucyB0aGUgYEZsaWdodFJvdXRlclN0YXRlYC5cbiAgLy8gV2Ugd2lsbCBjb3B5IG92ZXIgdGhlIGludGVybmFsIHN0YXRlIG9uIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgZXZlbnRzLCBidXQgaWYgYSBoaXN0b3J5IGVudHJ5XG4gIC8vIG9jY3VycmVkIGJlZm9yZSBoeWRyYXRpb24sIG9yIGlmIHRoZSB1c2VyIG5hdmlnYXRlZCB0byBhIGhhc2ggdXNpbmcgYSByZWd1bGFyIGFuY2hvciBsaW5rLFxuICAvLyB0aGUgaGlzdG9yeSBzdGF0ZSB3aWxsIG5vdCBjb250YWluIHRoZSBgRmxpZ2h0Um91dGVyU3RhdGVgLlxuICAvLyBJbiB0aGlzIGNhc2UsIHdlJ2xsIGNvbnRpbnVlIHRvIHVzZSB0aGUgZXhpc3RpbmcgdHJlZSBzbyB0aGUgcm91dGVyIGRvZXNuJ3QgZ2V0IGludG8gYW4gaW52YWxpZCBzdGF0ZS5cbiAgY29uc3QgdHJlZVRvUmVzdG9yZSA9IHRyZWUgfHwgc3RhdGUudHJlZVxuXG4gIGNvbnN0IG9sZENhY2hlID0gc3RhdGUuY2FjaGVcbiAgY29uc3QgbmV3Q2FjaGUgPSBwcm9jZXNzLmVudi5fX05FWFRfUFBSXG4gICAgPyAvLyBXaGVuIFBQUiBpcyBlbmFibGVkLCB3ZSB1cGRhdGUgdGhlIGNhY2hlIHRvIGRyb3AgdGhlIHByZWZldGNoXG4gICAgICAvLyBkYXRhIGZvciBhbnkgc2VnbWVudCB3aG9zZSBkeW5hbWljIGRhdGEgd2FzIGFscmVhZHkgcmVjZWl2ZWQuIFRoaXNcbiAgICAgIC8vIHByZXZlbnRzIGFuIHVubmVjZXNzYXJ5IGZsYXNoIGJhY2sgdG8gUFBSIHN0YXRlIGR1cmluZyBhXG4gICAgICAvLyBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbi5cbiAgICAgIHVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbihvbGRDYWNoZSwgdHJlZVRvUmVzdG9yZSlcbiAgICA6IG9sZENhY2hlXG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTZXQgY2Fub25pY2FsIHVybFxuICAgIGNhbm9uaWNhbFVybDogaHJlZixcbiAgICBwdXNoUmVmOiB7XG4gICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCB0aGUgY3VzdG9tIGhpc3Rvcnkgc3RhdGUgdGhhdCB3YXMgc2V0IGlzIHByZXNlcnZlZCB3aGVuIGFwcGx5aW5nIHRoaXMgdXBkYXRlLlxuICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWUsXG4gICAgfSxcbiAgICBmb2N1c0FuZFNjcm9sbFJlZjogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgY2FjaGU6IG5ld0NhY2hlLFxuICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgLy8gUmVzdG9yZSBwcm92aWRlZCB0cmVlXG4gICAgdHJlZTogdHJlZVRvUmVzdG9yZSxcbiAgICBuZXh0VXJsOiBleHRyYWN0UGF0aEZyb21GbGlnaHRSb3V0ZXJTdGF0ZSh0cmVlVG9SZXN0b3JlKSA/PyB1cmwucGF0aG5hbWUsXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJyZXN0b3JlUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidXJsIiwidHJlZSIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInRyZWVUb1Jlc3RvcmUiLCJvbGRDYWNoZSIsImNhY2hlIiwibmV3Q2FjaGUiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1BQUiIsInVwZGF0ZUNhY2hlTm9kZU9uUG9wc3RhdGVSZXN0b3JhdGlvbiIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiY2Fub25pY2FsVXJsIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJwcmVmZXRjaENhY2hlIiwibmV4dFVybCIsInBhdGhuYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverActionReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverActionReducer;\n    }\n}));\nconst _appcallserver = __webpack_require__(/*! ../../../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterheaders = __webpack_require__(/*! ../../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _routerreducertypes = __webpack_require__(/*! ../router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _assignlocation = __webpack_require__(/*! ../../../assign-location */ \"(app-pages-browser)/./node_modules/next/dist/client/assign-location.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ../refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _redirect = __webpack_require__(/*! ../../redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ../../redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ../prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _serverreferenceinfo = __webpack_require__(/*! ../../../../shared/lib/server-reference-info */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/server-reference-info.js\");\nconst _segmentcache = __webpack_require__(/*! ../../segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, createTemporaryReferenceSet, encodeReply } =  false ? 0 : __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nasync function fetchServerAction(state, nextUrl, param) {\n    let { actionId, actionArgs } = param;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const info = (0, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);\n    // TODO: Currently, we're only omitting unused args for the experimental \"use\n    // cache\" functions. Once the server reference info byte feature is stable, we\n    // should apply this to server actions as well.\n    const usedArgs = info.type === 'use-cache' ? (0, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;\n    const body = await encodeReply(usedArgs, {\n        temporaryReferences\n    });\n    const res = await fetch('', {\n        method: 'POST',\n        headers: {\n            Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,\n            [_approuterheaders.ACTION_HEADER]: actionId,\n            [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(JSON.stringify(state.tree)),\n            ... false ? 0 : {},\n            ...nextUrl ? {\n                [_approuterheaders.NEXT_URL]: nextUrl\n            } : {}\n        },\n        body\n    });\n    const redirectHeader = res.headers.get('x-action-redirect');\n    const [location, _redirectType] = (redirectHeader == null ? void 0 : redirectHeader.split(';')) || [];\n    let redirectType;\n    switch(_redirectType){\n        case 'push':\n            redirectType = _redirecterror.RedirectType.push;\n            break;\n        case 'replace':\n            redirectType = _redirecterror.RedirectType.replace;\n            break;\n        default:\n            redirectType = undefined;\n    }\n    const isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);\n    let revalidatedParts;\n    try {\n        const revalidatedHeader = JSON.parse(res.headers.get('x-action-revalidated') || '[[],0,0]');\n        revalidatedParts = {\n            paths: revalidatedHeader[0] || [],\n            tag: !!revalidatedHeader[1],\n            cookie: revalidatedHeader[2]\n        };\n    } catch (e) {\n        revalidatedParts = {\n            paths: [],\n            tag: false,\n            cookie: false\n        };\n    }\n    const redirectLocation = location ? (0, _assignlocation.assignLocation)(location, new URL(state.canonicalUrl, window.location.href)) : undefined;\n    const contentType = res.headers.get('content-type');\n    if (contentType == null ? void 0 : contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER)) {\n        const response = await createFromFetch(Promise.resolve(res), {\n            callServer: _appcallserver.callServer,\n            findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,\n            temporaryReferences\n        });\n        if (location) {\n            // if it was a redirection, then result is just a regular RSC payload\n            return {\n                actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n                redirectLocation,\n                redirectType,\n                revalidatedParts,\n                isPrerender\n            };\n        }\n        return {\n            actionResult: response.a,\n            actionFlightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            redirectLocation,\n            redirectType,\n            revalidatedParts,\n            isPrerender\n        };\n    }\n    // Handle invalid server action responses\n    if (res.status >= 400) {\n        // The server can respond with a text/plain error message, but we'll fallback to something generic\n        // if there isn't one.\n        const error = contentType === 'text/plain' ? await res.text() : 'An unexpected response was received from the server.';\n        throw Object.defineProperty(new Error(error), \"__NEXT_ERROR_CODE\", {\n            value: \"E394\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return {\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender\n    };\n}\nfunction serverActionReducer(state, action) {\n    const { resolve, reject } = action;\n    const mutable = {};\n    let currentTree = state.tree;\n    mutable.preserveCustomHistoryState = false;\n    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n    // If the route has been intercepted, the action should be as well.\n    // Otherwise the server action might be intercepted with the wrong action id\n    // (ie, one that corresponds with the intercepted route)\n    const nextUrl = state.nextUrl && (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : null;\n    return fetchServerAction(state, nextUrl, action).then(async (param)=>{\n        let { actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;\n        let redirectHref;\n        // honor the redirect type instead of defaulting to push in case of server actions.\n        if (redirectLocation) {\n            if (redirectType === _redirecterror.RedirectType.replace) {\n                state.pushRef.pendingPush = false;\n                mutable.pendingPush = false;\n            } else {\n                state.pushRef.pendingPush = true;\n                mutable.pendingPush = true;\n            }\n            redirectHref = (0, _createhreffromurl.createHrefFromUrl)(redirectLocation, false);\n            mutable.canonicalUrl = redirectHref;\n        }\n        if (!flightData) {\n            resolve(actionResult);\n            // If there is a redirect but no flight data we need to do a mpaNavigation.\n            if (redirectLocation) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);\n            }\n            return state;\n        }\n        if (typeof flightData === 'string') {\n            // Handle case when navigating to page in `pages` from `app`\n            resolve(actionResult);\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        const actionRevalidated = revalidatedParts.paths.length > 0 || revalidatedParts.tag || revalidatedParts.cookie;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('SERVER ACTION APPLY FAILED');\n                resolve(actionResult);\n                return state;\n            }\n            // Given the path can only have two items the items are only the router state and rsc for the root.\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);\n            if (newTree === null) {\n                resolve(actionResult);\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                resolve(actionResult);\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);\n            }\n            // The server sent back RSC data for the server action, so we need to apply it to the cache.\n            if (cacheNodeSeedData !== null) {\n                const rsc = cacheNodeSeedData[1];\n                const cache = (0, _approuter.createEmptyCacheNode)();\n                cache.rsc = rsc;\n                cache.prefetchRsc = null;\n                cache.loading = cacheNodeSeedData[3];\n                (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(cache, undefined, treePatch, cacheNodeSeedData, head, undefined);\n                mutable.cache = cache;\n                if (false) {} else {\n                    mutable.prefetchCache = new Map();\n                }\n                if (actionRevalidated) {\n                    await (0, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({\n                        state,\n                        updatedTree: newTree,\n                        updatedCache: cache,\n                        includeNextUrl: Boolean(nextUrl),\n                        canonicalUrl: mutable.canonicalUrl || state.canonicalUrl\n                    });\n                }\n            }\n            mutable.patchedTree = newTree;\n            currentTree = newTree;\n        }\n        if (redirectLocation && redirectHref) {\n            if ( true && !actionRevalidated) {\n                // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n                // with the FlightData that we got from the server action for the target page, so that it's\n                // available when the page is navigated to and doesn't need to be re-fetched.\n                // We only do this if the server action didn't revalidate any data, as in that case the\n                // client cache will be cleared and the data will be re-fetched anyway.\n                // NOTE: We don't do this in the Segment Cache implementation.\n                // Dynamic data should never be placed into the cache, unless it's\n                // \"converted\" to static data using <Link prefetch={true}>. What we\n                // do instead is re-prefetch links and forms whenever the cache is\n                // invalidated.\n                (0, _prefetchcacheutils.createSeededPrefetchCacheEntry)({\n                    url: redirectLocation,\n                    data: {\n                        flightData,\n                        canonicalUrl: undefined,\n                        couldBeIntercepted: false,\n                        prerendered: false,\n                        postponed: false,\n                        // TODO: We should be able to set this if the server action\n                        // returned a fully static response.\n                        staleTime: -1\n                    },\n                    tree: state.tree,\n                    prefetchCache: state.prefetchCache,\n                    nextUrl: state.nextUrl,\n                    kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO\n                });\n                mutable.prefetchCache = state.prefetchCache;\n            }\n            // If the action triggered a redirect, the action promise will be rejected with\n            // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n            // action result to resolve the promise with. This will effectively reset the state of\n            // the component that called the action as the error boundary will remount the tree.\n            // The status code doesn't matter here as the action handler will have already sent\n            // a response with the correct status code.\n            reject((0, _redirect.getRedirectError)((0, _hasbasepath.hasBasePath)(redirectHref) ? (0, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));\n        } else {\n            resolve(actionResult);\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, (e)=>{\n        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n        reject(e);\n        return state;\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-action-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLWFjdGlvbi1yZWR1Y2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7dURBNE1nQkE7OztlQUFBQTs7OzJDQXhNVztpREFDTTs4Q0FPMUI7Z0RBb0JBOzRDQUN3QjsrQ0FDRzs2Q0FDQTt5REFDVTt5REFDQTsyQ0FFZDsyREFDZ0I7dUNBQ1Q7K0RBQ2E7bURBQ1o7NkRBQ1U7K0NBSXpDO3NDQUMwQjsyQ0FDSjtnREFDa0I7NENBQ2hCO3lDQUNIO2lEQUlyQjswQ0FDK0I7QUE1Q3RDLGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSxNQUFNLEVBQUVDLGVBQWUsRUFBRUMsMkJBQTJCLEVBQUVDLFdBQVcsRUFBRSxHQUNqRSxNQUEwQixHQUV0QkksQ0FBK0MsR0FFL0NBLG1CQUFPQSxDQUFDLGlJQUFpQztBQWtEL0MsZUFBZUMsa0JBQ2JDLEtBQTJCLEVBQzNCQyxPQUF3QyxFQUN4QyxLQUE0QztJQUE1QyxNQUFFQyxRQUFRLEVBQUVDLFVBQVUsRUFBc0IsR0FBNUM7SUFFQSxNQUFNQyxzQkFBc0JYO0lBQzVCLE1BQU1ZLE9BQU9DLENBQUFBLEdBQUFBLHFCQUFBQSxnQ0FBZ0MsRUFBQ0o7SUFFOUMsNkVBQTZFO0lBQzdFLDhFQUE4RTtJQUM5RSwrQ0FBK0M7SUFDL0MsTUFBTUssV0FDSkYsS0FBS0csSUFBSSxLQUFLLGNBQWNDLENBQUFBLEdBQUFBLHFCQUFBQSxjQUFBQSxFQUFlTixZQUFZRSxRQUFRRjtJQUVqRSxNQUFNTyxPQUFPLE1BQU1oQixZQUFZYSxVQUFVO1FBQUVIO0lBQW9CO0lBRS9ELE1BQU1PLE1BQU0sTUFBTUMsTUFBTSxJQUFJO1FBQzFCQyxRQUFRO1FBQ1JDLFNBQVM7WUFDUEMsUUFBUUMsa0JBQUFBLHVCQUF1QjtZQUMvQixDQUFDQyxrQkFB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Yjt3QkFDZDhFLG9CQUFvQjt3QkFDcEJDLGFBQWE7d0JBQ2JDLFdBQVc7d0JBQ1gsMkRBQTJEO3dCQUMzRCxvQ0FBb0M7d0JBQ3BDQyxXQUFXLENBQUM7b0JBQ2Q7b0JBQ0E3RixNQUFNdEIsTUFBTXNCLElBQUk7b0JBQ2hCK0UsZUFBZXJHLE1BQU1xRyxhQUFhO29CQUNsQ3BHLFNBQVNELE1BQU1DLE9BQU87b0JBQ3RCbUgsTUFBTWpGLGNBQWNrRixvQkFBQUEsWUFBWSxDQUFDQyxJQUFJLEdBQUdELG9CQUFBQSxZQUFZLENBQUNFLElBQUk7Z0JBQzNEO2dCQUNBbkQsUUFBUWlDLGFBQWEsR0FBR3JHLE1BQU1xRyxhQUFhO1lBQzdDO1lBRUEsK0VBQStFO1lBQy9FLCtFQUErRTtZQUMvRSxzRkFBc0Y7WUFDdEYsb0ZBQW9GO1lBQ3BGLG1GQUFtRjtZQUNuRiwyQ0FBMkM7WUFDM0NsQyxPQUNFcUQsQ0FBQUEsR0FBQUEsVUFBQUEsZ0JBQUFBLEVBQ0VDLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVkvQyxnQkFDUmdELENBQUFBLEdBQUFBLGdCQUFBQSxjQUFBQSxFQUFlaEQsZ0JBQ2ZBLGNBQ0o1QyxnQkFBZ0JDLGVBQUFBLFlBQVksQ0FBQ0MsSUFBSTtRQUd2QyxPQUFPO1lBQ0xzQixRQUFRTTtRQUNWO1FBRUEsT0FBTytELENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWMzSCxPQUFPb0U7SUFDOUIsR0FDQSxDQUFDekI7UUFDQyxtSEFBbUg7UUFDbkh3QixPQUFPeEI7UUFFUCxPQUFPM0M7SUFDVDtBQUVKIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1hY3Rpb24tcmVkdWNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7XG4gIEFjdGlvbkZsaWdodFJlc3BvbnNlLFxuICBBY3Rpb25SZXN1bHQsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY2FsbFNlcnZlciB9IGZyb20gJy4uLy4uLy4uL2FwcC1jYWxsLXNlcnZlcidcbmltcG9ydCB7IGZpbmRTb3VyY2VNYXBVUkwgfSBmcm9tICcuLi8uLi8uLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7XG4gIEFDVElPTl9IRUFERVIsXG4gIE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIsXG4gIE5FWFRfVVJMLFxuICBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbn0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuXG4vLyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4vLyBpbXBvcnQgeyBjcmVhdGVGcm9tRmV0Y2ggfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuLy8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuLy8gaW1wb3J0IHsgZW5jb2RlUmVwbHkgfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuY29uc3QgeyBjcmVhdGVGcm9tRmV0Y2gsIGNyZWF0ZVRlbXBvcmFyeVJlZmVyZW5jZVNldCwgZW5jb2RlUmVwbHkgfSA9IChcbiAgISFwcm9jZXNzLmVudi5ORVhUX1JVTlRJTUVcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbiAgICAgIHJlcXVpcmUoJ3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnQuZWRnZScpXG4gICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gICAgICByZXF1aXJlKCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50JylcbikgYXMgdHlwZW9mIGltcG9ydCgncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCcpXG5cbmltcG9ydCB7XG4gIFByZWZldGNoS2luZCxcbiAgdHlwZSBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgdHlwZSBSZWR1Y2VyU3RhdGUsXG4gIHR5cGUgU2VydmVyQWN0aW9uQWN0aW9uLFxuICB0eXBlIFNlcnZlckFjdGlvbk11dGFibGUsXG59IGZyb20gJy4uL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgYXNzaWduTG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi9hc3NpZ24tbG9jYXRpb24nXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgaGFuZGxlRXh0ZXJuYWxVcmwgfSBmcm9tICcuL25hdmlnYXRlLXJlZHVjZXInXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi4vZmlsbC1sYXp5LWl0ZW1zLXRpbGwtbGVhZi13aXRoLWhlYWQnXG5pbXBvcnQgeyBjcmVhdGVFbXB0eUNhY2hlTm9kZSB9IGZyb20gJy4uLy4uL2FwcC1yb3V0ZXInXG5pbXBvcnQgeyBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUgfSBmcm9tICcuL2hhcy1pbnRlcmNlcHRpb24tcm91dGUtaW4tY3VycmVudC10cmVlJ1xuaW1wb3J0IHsgaGFuZGxlU2VnbWVudE1pc21hdGNoIH0gZnJvbSAnLi4vaGFuZGxlLXNlZ21lbnQtbWlzbWF0Y2gnXG5pbXBvcnQgeyByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIH0gZnJvbSAnLi4vcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cydcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUZsaWdodERhdGEsXG4gIHR5cGUgTm9ybWFsaXplZEZsaWdodERhdGEsXG59IGZyb20gJy4uLy4uLy4uL2ZsaWdodC1kYXRhLWhlbHBlcnMnXG5pbXBvcnQgeyBnZXRSZWRpcmVjdEVycm9yIH0gZnJvbSAnLi4vLi4vcmVkaXJlY3QnXG5pbXBvcnQgeyBSZWRpcmVjdFR5cGUgfSBmcm9tICcuLi8uLi9yZWRpcmVjdC1lcnJvcidcbmltcG9ydCB7IGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSB9IGZyb20gJy4uL3ByZWZldGNoLWNhY2hlLXV0aWxzJ1xuaW1wb3J0IHsgcmVtb3ZlQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHtcbiAgZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQsXG4gIG9taXRVbnVzZWRBcmdzLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL3NlcnZlci1yZWZlcmVuY2UtaW5mbydcbmltcG9ydCB7IHJldmFsaWRhdGVFbnRpcmVDYWNoZSB9IGZyb20gJy4uLy4uL3NlZ21lbnQtY2FjaGUnXG5cbnR5cGUgRmV0Y2hTZXJ2ZXJBY3Rpb25SZXN1bHQgPSB7XG4gIHJlZGlyZWN0TG9jYXRpb246IFVSTCB8IHVuZGVmaW5lZFxuICByZWRpcmVjdFR5cGU6IFJlZGlyZWN0VHlwZSB8IHVuZGVmaW5lZFxuICBhY3Rpb25SZXN1bHQ/OiBBY3Rpb25SZXN1bHRcbiAgYWN0aW9uRmxpZ2h0RGF0YT86IE5vcm1hbGl6ZWRGbGlnaHREYXRhW10gfCBzdHJpbmdcbiAgaXNQcmVyZW5kZXI6IGJvb2xlYW5cbiAgcmV2YWxpZGF0ZWRQYXJ0czoge1xuICAgIHRhZzogYm9vbGVhblxuICAgIGNvb2tpZTogYm9vbGVhblxuICAgIHBhdGhzOiBzdHJpbmdbXVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmVyQWN0aW9uKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIG5leHRVcmw6IFJlYWRvbmx5UmVkdWNlclN0YXRlWyduZXh0VXJsJ10sXG4gIHsgYWN0aW9uSWQsIGFjdGlvbkFyZ3MgfTogU2VydmVyQWN0aW9uQWN0aW9uXG4pOiBQcm9taXNlPEZldGNoU2VydmVyQWN0aW9uUmVzdWx0PiB7XG4gIGNvbnN0IHRlbXBvcmFyeVJlZmVyZW5jZXMgPSBjcmVhdGVUZW1wb3JhcnlSZWZlcmVuY2VTZXQoKVxuICBjb25zdCBpbmZvID0gZXh0cmFjdEluZm9Gcm9tU2VydmVyUmVmZXJlbmNlSWQoYWN0aW9uSWQpXG5cbiAgLy8gVE9ETzogQ3VycmVudGx5LCB3ZSdyZSBvbmx5IG9taXR0aW5nIHVudXNlZCBhcmdzIGZvciB0aGUgZXhwZXJpbWVudGFsIFwidXNlXG4gIC8vIGNhY2hlXCIgZnVuY3Rpb25zLiBPbmNlIHRoZSBzZXJ2ZXIgcmVmZXJlbmNlIGluZm8gYnl0ZSBmZWF0dXJlIGlzIHN0YWJsZSwgd2VcbiAgLy8gc2hvdWxkIGFwcGx5IHRoaXMgdG8gc2VydmVyIGFjdGlvbnMgYXMgd2VsbC5cbiAgY29uc3QgdXNlZEFyZ3MgPVxuICAgIGluZm8udHlwZSA9PT0gJ3VzZS1jYWNoZScgPyBvbWl0VW51c2VkQXJncyhhY3Rpb25BcmdzLCBpbmZvKSA6IGFjdGlvbkFyZ3NcblxuICBjb25zdCBib2R5ID0gYXdhaXQgZW5jb2RlUmVwbHkodXNlZEFyZ3MsIHsgdGVtcG9yYXJ5UmVmZXJlbmNlcyB9KVxuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcnLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgICAgIFtBQ1RJT05fSEVBREVSXTogYWN0aW9uSWQsXG4gICAgICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdOiBlbmNvZGVVUklDb21wb25lbnQoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpXG4gICAgICApLFxuICAgICAgLi4uKHByb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRFxuICAgICAgICA/IHtcbiAgICAgICAgICAgICd4LWRlcGxveW1lbnQtaWQnOiBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUQsXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9KSxcbiAgICAgIC4uLihuZXh0VXJsXG4gICAgICAgID8ge1xuICAgICAgICAgICAgW05FWFRfVVJMXTogbmV4dFVybCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge30pLFxuICAgIH0sXG4gICAgYm9keSxcbiAgfSlcblxuICBjb25zdCByZWRpcmVjdEhlYWRlciA9IHJlcy5oZWFkZXJzLmdldCgneC1hY3Rpb24tcmVkaXJlY3QnKVxuICBjb25zdCBbbG9jYXRpb24sIF9yZWRpcmVjdFR5cGVdID0gcmVkaXJlY3RIZWFkZXI/LnNwbGl0KCc7JykgfHwgW11cbiAgbGV0IHJlZGlyZWN0VHlwZTogUmVkaXJlY3RUeXBlIHwgdW5kZWZpbmVkXG4gIHN3aXRjaCAoX3JlZGlyZWN0VHlwZSkge1xuICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgcmVkaXJlY3RUeXBlID0gUmVkaXJlY3RUeXBlLnB1c2hcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICByZWRpcmVjdFR5cGUgPSBSZWRpcmVjdFR5cGUucmVwbGFjZVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmVkaXJlY3RUeXBlID0gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBpc1ByZXJlbmRlciA9ICEhcmVzLmhlYWRlcnMuZ2V0KE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUilcbiAgbGV0IHJldmFsaWRhdGVkUGFydHM6IEZldGNoU2VydmVyQWN0aW9uUmVzdWx0WydyZXZhbGlkYXRlZFBhcnRzJ11cbiAgdHJ5IHtcbiAgICBjb25zdCByZXZhbGlkYXRlZEhlYWRlciA9IEpTT04ucGFyc2UoXG4gICAgICByZXMuaGVhZGVycy5nZXQoJ3gtYWN0aW9uLXJldmFsaWRhdGVkJykgfHwgJ1tbXSwwLDBdJ1xuICAgIClcbiAgICByZXZhbGlkYXRlZFBhcnRzID0ge1xuICAgICAgcGF0aHM6IHJldmFsaWRhdGVkSGVhZGVyWzBdIHx8IFtdLFxuICAgICAgdGFnOiAhIXJldmFsaWRhdGVkSGVhZGVyWzFdLFxuICAgICAgY29va2llOiByZXZhbGlkYXRlZEhlYWRlclsyXSxcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXZhbGlkYXRlZFBhcnRzID0ge1xuICAgICAgcGF0aHM6IFtdLFxuICAgICAgdGFnOiBmYWxzZSxcbiAgICAgIGNvb2tpZTogZmFsc2UsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVkaXJlY3RMb2NhdGlvbiA9IGxvY2F0aW9uXG4gICAgPyBhc3NpZ25Mb2NhdGlvbihcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIG5ldyBVUkwoc3RhdGUuY2Fub25pY2FsVXJsLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgIClcbiAgICA6IHVuZGVmaW5lZFxuXG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKVxuXG4gIGlmIChjb250ZW50VHlwZT8uc3RhcnRzV2l0aChSU0NfQ09OVEVOVF9UWVBFX0hFQURFUikpIHtcbiAgICBjb25zdCByZXNwb25zZTogQWN0aW9uRmxpZ2h0UmVzcG9uc2UgPSBhd2FpdCBjcmVhdGVGcm9tRmV0Y2goXG4gICAgICBQcm9taXNlLnJlc29sdmUocmVzKSxcbiAgICAgIHsgY2FsbFNlcnZlciwgZmluZFNvdXJjZU1hcFVSTCwgdGVtcG9yYXJ5UmVmZXJlbmNlcyB9XG4gICAgKVxuXG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAvLyBpZiBpdCB3YXMgYSByZWRpcmVjdGlvbiwgdGhlbiByZXN1bHQgaXMganVzdCBhIHJlZ3VsYXIgUlNDIHBheWxvYWRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGlvbkZsaWdodERhdGE6IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZiksXG4gICAgICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgICAgIHJlZGlyZWN0VHlwZSxcbiAgICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyxcbiAgICAgICAgaXNQcmVyZW5kZXIsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvblJlc3VsdDogcmVzcG9uc2UuYSxcbiAgICAgIGFjdGlvbkZsaWdodERhdGE6IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZiksXG4gICAgICByZWRpcmVjdExvY2F0aW9uLFxuICAgICAgcmVkaXJlY3RUeXBlLFxuICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyxcbiAgICAgIGlzUHJlcmVuZGVyLFxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBpbnZhbGlkIHNlcnZlciBhY3Rpb24gcmVzcG9uc2VzXG4gIGlmIChyZXMuc3RhdHVzID49IDQwMCkge1xuICAgIC8vIFRoZSBzZXJ2ZXIgY2FuIHJlc3BvbmQgd2l0aCBhIHRleHQvcGxhaW4gZXJyb3IgbWVzc2FnZSwgYnV0IHdlJ2xsIGZhbGxiYWNrIHRvIHNvbWV0aGluZyBnZW5lcmljXG4gICAgLy8gaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgIGNvbnN0IGVycm9yID1cbiAgICAgIGNvbnRlbnRUeXBlID09PSAndGV4dC9wbGFpbidcbiAgICAgICAgPyBhd2FpdCByZXMudGV4dCgpXG4gICAgICAgIDogJ0FuIHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4nXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlZGlyZWN0TG9jYXRpb24sXG4gICAgcmVkaXJlY3RUeXBlLFxuICAgIHJldmFsaWRhdGVkUGFydHMsXG4gICAgaXNQcmVyZW5kZXIsXG4gIH1cbn1cblxuLypcbiAqIFRoaXMgcmVkdWNlciBpcyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgc2VydmVyIGFjdGlvbiBhbmQgcHJvY2Vzc2luZyBhbnkgc2lkZS1lZmZlY3RzIGZyb20gdGhlIHNlcnZlciBhY3Rpb24uXG4gKiBJdCBkb2VzIG5vdCBtdXRhdGUgdGhlIHN0YXRlIGJ5IGl0c2VsZiBidXQgcmF0aGVyIGRlbGVnYXRlcyB0byBvdGhlciByZWR1Y2VycyB0byBkbyB0aGUgYWN0dWFsIG11dGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VydmVyQWN0aW9uUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFNlcnZlckFjdGlvbkFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBTZXJ2ZXJBY3Rpb25NdXRhYmxlID0ge31cblxuICBsZXQgY3VycmVudFRyZWUgPSBzdGF0ZS50cmVlXG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgLy8gb25seSBwYXNzIGFsb25nIHRoZSBgbmV4dFVybGAgcGFyYW0gKHVzZWQgZm9yIGludGVyY2VwdGlvbiByb3V0ZXMpIGlmIHRoZSBjdXJyZW50IHJvdXRlIHdhcyBpbnRlcmNlcHRlZC5cbiAgLy8gSWYgdGhlIHJvdXRlIGhhcyBiZWVuIGludGVyY2VwdGVkLCB0aGUgYWN0aW9uIHNob3VsZCBiZSBhcyB3ZWxsLlxuICAvLyBPdGhlcndpc2UgdGhlIHNlcnZlciBhY3Rpb24gbWlnaHQgYmUgaW50ZXJjZXB0ZWQgd2l0aCB0aGUgd3JvbmcgYWN0aW9uIGlkXG4gIC8vIChpZSwgb25lIHRoYXQgY29ycmVzcG9uZHMgd2l0aCB0aGUgaW50ZXJjZXB0ZWQgcm91dGUpXG4gIGNvbnN0IG5leHRVcmwgPVxuICAgIHN0YXRlLm5leHRVcmwgJiYgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlKHN0YXRlLnRyZWUpXG4gICAgICA/IHN0YXRlLm5leHRVcmxcbiAgICAgIDogbnVsbFxuXG4gIHJldHVybiBmZXRjaFNlcnZlckFjdGlvbihzdGF0ZSwgbmV4dFVybCwgYWN0aW9uKS50aGVuKFxuICAgIGFzeW5jICh7XG4gICAgICBhY3Rpb25SZXN1bHQsXG4gICAgICBhY3Rpb25GbGlnaHREYXRhOiBmbGlnaHREYXRhLFxuICAgICAgcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgIHJlZGlyZWN0VHlwZSxcbiAgICAgIGlzUHJlcmVuZGVyLFxuICAgICAgcmV2YWxpZGF0ZWRQYXJ0cyxcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgcmVkaXJlY3RIcmVmOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAgICAgLy8gaG9ub3IgdGhlIHJlZGlyZWN0IHR5cGUgaW5zdGVhZCBvZiBkZWZhdWx0aW5nIHRvIHB1c2ggaW4gY2FzZSBvZiBzZXJ2ZXIgYWN0aW9ucy5cbiAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09IFJlZGlyZWN0VHlwZS5yZXBsYWNlKSB7XG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICAgICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCA9IHRydWVcbiAgICAgICAgICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmVkaXJlY3RIcmVmID0gY3JlYXRlSHJlZkZyb21VcmwocmVkaXJlY3RMb2NhdGlvbiwgZmFsc2UpXG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gcmVkaXJlY3RIcmVmXG4gICAgICB9XG5cbiAgICAgIGlmICghZmxpZ2h0RGF0YSkge1xuICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IGJ1dCBubyBmbGlnaHQgZGF0YSB3ZSBuZWVkIHRvIGRvIGEgbXBhTmF2aWdhdGlvbi5cbiAgICAgICAgaWYgKHJlZGlyZWN0TG9jYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgICByZWRpcmVjdExvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgIHN0YXRlLnB1c2hSZWYucGVuZGluZ1B1c2hcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3Rpb25SZXZhbGlkYXRlZCA9XG4gICAgICAgIHJldmFsaWRhdGVkUGFydHMucGF0aHMubGVuZ3RoID4gMCB8fFxuICAgICAgICByZXZhbGlkYXRlZFBhcnRzLnRhZyB8fFxuICAgICAgICByZXZhbGlkYXRlZFBhcnRzLmNvb2tpZVxuXG4gICAgICBmb3IgKGNvbnN0IG5vcm1hbGl6ZWRGbGlnaHREYXRhIG9mIGZsaWdodERhdGEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRyZWU6IHRyZWVQYXRjaCxcbiAgICAgICAgICBzZWVkRGF0YTogY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgaGVhZCxcbiAgICAgICAgICBpc1Jvb3RSZW5kZXIsXG4gICAgICAgIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuXG4gICAgICAgIGlmICghaXNSb290UmVuZGVyKSB7XG4gICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1NFUlZFUiBBQ1RJT04gQVBQTFkgRkFJTEVEJylcbiAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2l2ZW4gdGhlIHBhdGggY2FuIG9ubHkgaGF2ZSB0d28gaXRlbXMgdGhlIGl0ZW1zIGFyZSBvbmx5IHRoZSByb3V0ZXIgc3RhdGUgYW5kIHJzYyBmb3IgdGhlIHJvb3QuXG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoXG4gICAgICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgIFsnJ10sXG4gICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgIHJlZGlyZWN0SHJlZiA/IHJlZGlyZWN0SHJlZiA6IHN0YXRlLmNhbm9uaWNhbFVybFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAgIHJldHVybiBoYW5kbGVTZWdtZW50TWlzbWF0Y2goc3RhdGUsIGFjdGlvbiwgdHJlZVBhdGNoKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgICByZXNvbHZlKGFjdGlvblJlc3VsdClcblxuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIHJlZGlyZWN0SHJlZiB8fCBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHNlcnZlciBzZW50IGJhY2sgUlNDIGRhdGEgZm9yIHRoZSBzZXJ2ZXIgYWN0aW9uLCBzbyB3ZSBuZWVkIHRvIGFwcGx5IGl0IHRvIHRoZSBjYWNoZS5cbiAgICAgICAgaWYgKGNhY2hlTm9kZVNlZWREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcnNjID0gY2FjaGVOb2RlU2VlZERhdGFbMV1cbiAgICAgICAgICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0gY3JlYXRlRW1wdHlDYWNoZU5vZGUoKVxuICAgICAgICAgIGNhY2hlLnJzYyA9IHJzY1xuICAgICAgICAgIGNhY2hlLnByZWZldGNoUnNjID0gbnVsbFxuICAgICAgICAgIGNhY2hlLmxvYWRpbmcgPSBjYWNoZU5vZGVTZWVkRGF0YVszXVxuICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICAvLyBFeGlzdGluZyBjYWNoZSBpcyBub3QgcGFzc2VkIGluIGFzIHNlcnZlciBhY3Rpb25zIGhhdmUgdG8gaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLlxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHJlZVBhdGNoLFxuICAgICAgICAgICAgY2FjaGVOb2RlU2VlZERhdGEsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSkge1xuICAgICAgICAgICAgcmV2YWxpZGF0ZUVudGlyZUNhY2hlKHN0YXRlLm5leHRVcmwsIG5ld1RyZWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11dGFibGUucHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXAoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWN0aW9uUmV2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoe1xuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgdXBkYXRlZFRyZWU6IG5ld1RyZWUsXG4gICAgICAgICAgICAgIHVwZGF0ZWRDYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgIGluY2x1ZGVOZXh0VXJsOiBCb29sZWFuKG5leHRVcmwpLFxuICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsIHx8IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG5cbiAgICAgIGlmIChyZWRpcmVjdExvY2F0aW9uICYmIHJlZGlyZWN0SHJlZikge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSAmJiAhYWN0aW9uUmV2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBSZWRpcmVjdEJvdW5kYXJ5IHdpbGwgdHJpZ2dlciBhIG5hdmlnYXRpb24sIHdlIG5lZWQgdG8gc2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGVcbiAgICAgICAgICAvLyB3aXRoIHRoZSBGbGlnaHREYXRhIHRoYXQgd2UgZ290IGZyb20gdGhlIHNlcnZlciBhY3Rpb24gZm9yIHRoZSB0YXJnZXQgcGFnZSwgc28gdGhhdCBpdCdzXG4gICAgICAgICAgLy8gYXZhaWxhYmxlIHdoZW4gdGhlIHBhZ2UgaXMgbmF2aWdhdGVkIHRvIGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgcmUtZmV0Y2hlZC5cbiAgICAgICAgICAvLyBXZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHNlcnZlciBhY3Rpb24gZGlkbid0IHJldmFsaWRhdGUgYW55IGRhdGEsIGFzIGluIHRoYXQgY2FzZSB0aGVcbiAgICAgICAgICAvLyBjbGllbnQgY2FjaGUgd2lsbCBiZSBjbGVhcmVkIGFuZCB0aGUgZGF0YSB3aWxsIGJlIHJlLWZldGNoZWQgYW55d2F5LlxuICAgICAgICAgIC8vIE5PVEU6IFdlIGRvbid0IGRvIHRoaXMgaW4gdGhlIFNlZ21lbnQgQ2FjaGUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgLy8gRHluYW1pYyBkYXRhIHNob3VsZCBuZXZlciBiZSBwbGFjZWQgaW50byB0aGUgY2FjaGUsIHVubGVzcyBpdCdzXG4gICAgICAgICAgLy8gXCJjb252ZXJ0ZWRcIiB0byBzdGF0aWMgZGF0YSB1c2luZyA8TGluayBwcmVmZXRjaD17dHJ1ZX0+LiBXaGF0IHdlXG4gICAgICAgICAgLy8gZG8gaW5zdGVhZCBpcyByZS1wcmVmZXRjaCBsaW5rcyBhbmQgZm9ybXMgd2hlbmV2ZXIgdGhlIGNhY2hlIGlzXG4gICAgICAgICAgLy8gaW52YWxpZGF0ZWQuXG4gICAgICAgICAgY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgICAgICAgICAgIHVybDogcmVkaXJlY3RMb2NhdGlvbixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogZmFsc2UsXG4gICAgICAgICAgICAgIHByZXJlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgcG9zdHBvbmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gc2V0IHRoaXMgaWYgdGhlIHNlcnZlciBhY3Rpb25cbiAgICAgICAgICAgICAgLy8gcmV0dXJuZWQgYSBmdWxseSBzdGF0aWMgcmVzcG9uc2UuXG4gICAgICAgICAgICAgIHN0YWxlVGltZTogLTEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICBuZXh0VXJsOiBzdGF0ZS5uZXh0VXJsLFxuICAgICAgICAgICAga2luZDogaXNQcmVyZW5kZXIgPyBQcmVmZXRjaEtpbmQuRlVMTCA6IFByZWZldGNoS2luZC5BVVRPLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgbXV0YWJsZS5wcmVmZXRjaENhY2hlID0gc3RhdGUucHJlZmV0Y2hDYWNoZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiB0cmlnZ2VyZWQgYSByZWRpcmVjdCwgdGhlIGFjdGlvbiBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aFxuICAgICAgICAvLyBhIHJlZGlyZWN0IHNvIHRoYXQgaXQncyBoYW5kbGVkIGJ5IFJlZGlyZWN0Qm91bmRhcnkgYXMgd2Ugd29uJ3QgaGF2ZSBhIHZhbGlkXG4gICAgICAgIC8vIGFjdGlvbiByZXN1bHQgdG8gcmVzb2x2ZSB0aGUgcHJvbWlzZSB3aXRoLiBUaGlzIHdpbGwgZWZmZWN0aXZlbHkgcmVzZXQgdGhlIHN0YXRlIG9mXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgdGhhdCBjYWxsZWQgdGhlIGFjdGlvbiBhcyB0aGUgZXJyb3IgYm91bmRhcnkgd2lsbCByZW1vdW50IHRoZSB0cmVlLlxuICAgICAgICAvLyBUaGUgc3RhdHVzIGNvZGUgZG9lc24ndCBtYXR0ZXIgaGVyZSBhcyB0aGUgYWN0aW9uIGhhbmRsZXIgd2lsbCBoYXZlIGFscmVhZHkgc2VudFxuICAgICAgICAvLyBhIHJlc3BvbnNlIHdpdGggdGhlIGNvcnJlY3Qgc3RhdHVzIGNvZGUuXG4gICAgICAgIHJlamVjdChcbiAgICAgICAgICBnZXRSZWRpcmVjdEVycm9yKFxuICAgICAgICAgICAgaGFzQmFzZVBhdGgocmVkaXJlY3RIcmVmKVxuICAgICAgICAgICAgICA/IHJlbW92ZUJhc2VQYXRoKHJlZGlyZWN0SHJlZilcbiAgICAgICAgICAgICAgOiByZWRpcmVjdEhyZWYsXG4gICAgICAgICAgICByZWRpcmVjdFR5cGUgfHwgUmVkaXJlY3RUeXBlLnB1c2hcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoYWN0aW9uUmVzdWx0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgIChlOiBhbnkpID0+IHtcbiAgICAgIC8vIFdoZW4gdGhlIHNlcnZlciBhY3Rpb24gaXMgcmVqZWN0ZWQgd2UgZG9uJ3QgdXBkYXRlIHRoZSBzdGF0ZSBhbmQgaW5zdGVhZCBjYWxsIHRoZSByZWplY3QgaGFuZGxlciBvZiB0aGUgcHJvbWlzZS5cbiAgICAgIHJlamVjdChlKVxuXG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJzZXJ2ZXJBY3Rpb25SZWR1Y2VyIiwiY3JlYXRlRnJvbUZldGNoIiwiY3JlYXRlVGVtcG9yYXJ5UmVmZXJlbmNlU2V0IiwiZW5jb2RlUmVwbHkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9SVU5USU1FIiwicmVxdWlyZSIsImZldGNoU2VydmVyQWN0aW9uIiwic3RhdGUiLCJuZXh0VXJsIiwiYWN0aW9uSWQiLCJhY3Rpb25BcmdzIiwidGVtcG9yYXJ5UmVmZXJlbmNlcyIsImluZm8iLCJleHRyYWN0SW5mb0Zyb21TZXJ2ZXJSZWZlcmVuY2VJZCIsInVzZWRBcmdzIiwidHlwZSIsIm9taXRVbnVzZWRBcmdzIiwiYm9keSIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsIlJTQ19DT05URU5UX1RZUEVfSEVBREVSIiwiQUNUSU9OX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInRyZWUiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJORVhUX1VSTCIsInJlZGlyZWN0SGVhZGVyIiwiZ2V0IiwibG9jYXRpb24iLCJfcmVkaXJlY3RUeXBlIiwic3BsaXQiLCJyZWRpcmVjdFR5cGUiLCJSZWRpcmVjdFR5cGUiLCJwdXNoIiwicmVwbGFjZSIsInVuZGVmaW5lZCIsImlzUHJlcmVuZGVyIiwiTkVYVF9JU19QUkVSRU5ERVJfSEVBREVSIiwicmV2YWxpZGF0ZWRQYXJ0cyIsInJldmFsaWRhdGVkSGVhZGVyIiwicGFyc2UiLCJwYXRocyIsInRhZyIsImNvb2tpZSIsImUiLCJyZWRpcmVjdExvY2F0aW9uIiwiYXNzaWduTG9jYXRpb24iLCJVUkwiLCJjYW5vbmljYWxVcmwiLCJ3aW5kb3ciLCJocmVmIiwiY29udGVudFR5cGUiLCJzdGFydHNXaXRoIiwicmVzcG9uc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwiYWN0aW9uRmxpZ2h0RGF0YSIsIm5vcm1hbGl6ZUZsaWdodERhdGEiLCJmIiwiYWN0aW9uUmVzdWx0IiwiYSIsInN0YXR1cyIsImVycm9yIiwidGV4dCIsIkVycm9yIiwiYWN0aW9uIiwicmVqZWN0IiwibXV0YWJsZSIsImN1cnJlbnRUcmVlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUiLCJ0aGVuIiwiZmxpZ2h0RGF0YSIsInJlZGlyZWN0SHJlZiIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJhY3Rpb25SZXZhbGlkYXRlZCIsImxlbmd0aCIsIm5vcm1hbGl6ZWRGbGlnaHREYXRhIiwidHJlZVBhdGNoIiwic2VlZERhdGEiLCJjYWNoZU5vZGVTZWVkRGF0YSIsImhlYWQiLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsInJzYyIsImNhY2hlIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJwcmVmZXRjaFJzYyIsImxvYWRpbmciLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsInJldmFsaWRhdGVFbnRpcmVDYWNoZSIsInByZWZldGNoQ2FjaGUiLCJNYXAiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwidXBkYXRlZFRyZWUiLCJ1cGRhdGVkQ2FjaGUiLCJpbmNsdWRlTmV4dFVybCIsIkJvb2xlYW4iLCJwYXRjaGVkVHJlZSIsImNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSIsInVybCIsImRhdGEiLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwcmVyZW5kZXJlZCIsInBvc3Rwb25lZCIsInN0YWxlVGltZSIsImtpbmQiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiQVVUTyIsImdldFJlZGlyZWN0RXJyb3IiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiaGFuZGxlTXV0YWJsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js ***!
  \**************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"serverPatchReducer\", ({\n    enumerable: true,\n    get: function() {\n        return serverPatchReducer;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nfunction serverPatchReducer(state, action) {\n    const { serverResponse: { flightData, canonicalUrl: canonicalUrlOverride } } = action;\n    const mutable = {};\n    mutable.preserveCustomHistoryState = false;\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === 'string') {\n        return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    let currentTree = state.tree;\n    let currentCache = state.cache;\n    for (const normalizedFlightData of flightData){\n        const { segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;\n        const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n            '',\n            ...flightSegmentPath\n        ], currentTree, treePatch, state.canonicalUrl);\n        // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n        // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n        // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n        // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n        // the entire page to reload.\n        if (newTree === null) {\n            return state;\n        }\n        if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n        }\n        const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n        if (canonicalUrlOverrideHref) {\n            mutable.canonicalUrl = canonicalUrlOverrideHref;\n        }\n        const cache = (0, _approuter.createEmptyCacheNode)();\n        (0, _applyflightdata.applyFlightData)(currentCache, cache, normalizedFlightData);\n        mutable.patchedTree = newTree;\n        mutable.cache = cache;\n        currentCache = cache;\n        currentTree = newTree;\n    }\n    return (0, _handlemutable.handleMutable)(state, mutable);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvc2VydmVyLXBhdGNoLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztzREFlZ0JBOzs7ZUFBQUE7OzsrQ0Fma0I7eURBQ1U7eURBQ0E7NkNBT1Y7NkNBQ0Y7MkNBQ0Y7dUNBRU87QUFFOUIsU0FBU0EsbUJBQ2RDLEtBQTJCLEVBQzNCQyxNQUF5QjtJQUV6QixNQUFNLEVBQ0pDLGdCQUFnQixFQUFFQyxVQUFVLEVBQUVDLGNBQWNDLG9CQUFvQixFQUFFLEVBQ25FLEdBQUdKO0lBRUosTUFBTUssVUFBbUIsQ0FBQztJQUUxQkEsUUFBUUMsMEJBQTBCLEdBQUc7SUFFckMsNERBQTREO0lBQzVELElBQUksT0FBT0osZUFBZSxVQUFVO1FBQ2xDLE9BQU9LLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTFIsT0FDQU0sU0FDQUgsWUFDQUgsTUFBTVMsT0FBTyxDQUFDQyxXQUFXO0lBRTdCO0lBRUEsSUFBSUMsY0FBY1gsTUFBTVksSUFBSTtJQUM1QixJQUFJQyxlQUFlYixNQUFNYyxLQUFLO0lBRTlCLEtBQUssTUFBTUMsd0JBQXdCWixXQUFZO1FBQzdDLE1BQU0sRUFBRWEsYUFBYUMsaUJBQWlCLEVBQUVMLE1BQU1NLFNBQVMsRUFBRSxHQUN2REg7UUFFRixNQUFNSSxVQUFVQyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQ2Q7WUFDQztlQUFPSDtTQUFrQixFQUMxQk4sYUFDQU8sV0FDQWxCLE1BQU1JLFlBQVk7UUFHcEIsa0lBQWtJO1FBQ2xJLDhHQUE4RztRQUM5RyxvSUFBb0k7UUFDcEksbUlBQW1JO1FBQ25JLDZCQUE2QjtRQUM3QixJQUFJZSxZQUFZLE1BQU07WUFDcEIsT0FBT25CO1FBQ1Q7UUFFQSxJQUFJcUIsQ0FBQUEsR0FBQUEsNkJBQUFBLDJCQUFBQSxFQUE0QlYsYUFBYVEsVUFBVTtZQUNyRCxPQUFPWCxDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0xSLE9BQ0FNLFNBQ0FOLE1BQU1JLFlBQVksRUFDbEJKLE1BQU1TLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLE1BQU1ZLDJCQUEyQmpCLHVCQUM3QmtCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JsQix3QkFDbEJtQjtRQUVKLElBQUlGLDBCQUEwQjtZQUM1QmhCLFFBQVFGLFlBQVksR0FBR2tCO1FBQ3pCO1FBRUEsTUFBTVIsUUFBbUJXLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFBQTtRQUN6QkMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQWdCYixjQUFjQyxPQUFPQztRQUVyQ1QsUUFBUXFCLFdBQVcsR0FBR1I7UUFDdEJiLFFBQVFRLEtBQUssR0FBR0E7UUFFaEJELGVBQWVDO1FBQ2ZILGNBQWNRO0lBQ2hCO0lBRUEsT0FBT1MsQ0FBQUEsR0FBQUEsZUFBQUEsYUFBQUEsRUFBYzVCLE9BQU9NO0FBQzlCIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3NlcnZlci1wYXRjaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi4vY3JlYXRlLWhyZWYtZnJvbS11cmwnXG5pbXBvcnQgeyBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgfSBmcm9tICcuLi9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZSdcbmltcG9ydCB7IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCB9IGZyb20gJy4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0J1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJQYXRjaEFjdGlvbixcbiAgUmVkdWNlclN0YXRlLFxuICBSZWFkb25seVJlZHVjZXJTdGF0ZSxcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHsgaGFuZGxlTXV0YWJsZSB9IGZyb20gJy4uL2hhbmRsZS1tdXRhYmxlJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcnZlclBhdGNoUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFNlcnZlclBhdGNoQWN0aW9uXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBjb25zdCB7XG4gICAgc2VydmVyUmVzcG9uc2U6IHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9LFxuICB9ID0gYWN0aW9uXG5cbiAgY29uc3QgbXV0YWJsZTogTXV0YWJsZSA9IHt9XG5cbiAgbXV0YWJsZS5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA9IGZhbHNlXG5cbiAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gaGFuZGxlRXh0ZXJuYWxVcmwoXG4gICAgICBzdGF0ZSxcbiAgICAgIG11dGFibGUsXG4gICAgICBmbGlnaHREYXRhLFxuICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgIClcbiAgfVxuXG4gIGxldCBjdXJyZW50VHJlZSA9IHN0YXRlLnRyZWVcbiAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgZm9yIChjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSBvZiBmbGlnaHREYXRhKSB7XG4gICAgY29uc3QgeyBzZWdtZW50UGF0aDogZmxpZ2h0U2VnbWVudFBhdGgsIHRyZWU6IHRyZWVQYXRjaCB9ID1cbiAgICAgIG5vcm1hbGl6ZWRGbGlnaHREYXRhXG5cbiAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgWycnLCAuLi5mbGlnaHRTZWdtZW50UGF0aF0sXG4gICAgICBjdXJyZW50VHJlZSxcbiAgICAgIHRyZWVQYXRjaCxcbiAgICAgIHN0YXRlLmNhbm9uaWNhbFVybFxuICAgIClcblxuICAgIC8vIGBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWVgIHJldHVybnMgYG51bGxgIHdoZW4gaXQgZGV0ZXJtaW5lZCB0aGF0IHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIGN1cnJlbnQgdHJlZS5cbiAgICAvLyBJbiBvdGhlciB3b3JkcywgdGhlIHNlcnZlciByZXNwb25kZWQgd2l0aCBhIHRyZWUgdGhhdCBkb2Vzbid0IG1hdGNoIHdoYXQgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2VydmVyIHBhdGNoIGFjdGlvbiB0b29rIGxvbmdlciB0byByZXNvbHZlIHRoYW4gYSBzdWJzZXF1ZW50IG5hdmlnYXRpb24gd2hpY2ggd291bGQgaGF2ZSBjaGFuZ2VkIHRoZSB0cmVlLlxuICAgIC8vIFByZXZpb3VzbHkgdGhpcyBjYXNlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvbiBidXQgaXQgc2hvdWxkIGJlIHNhZmUgdG8gc2ltcGx5IGRpc2NhcmQgdGhlIHNlcnZlciByZXNwb25zZSByYXRoZXIgdGhhbiBmb3JjaW5nXG4gICAgLy8gdGhlIGVudGlyZSBwYWdlIHRvIHJlbG9hZC5cbiAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuXG4gICAgaWYgKGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIG11dGFibGUsXG4gICAgICAgIHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmXG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGU6IENhY2hlTm9kZSA9IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKClcbiAgICBhcHBseUZsaWdodERhdGEoY3VycmVudENhY2hlLCBjYWNoZSwgbm9ybWFsaXplZEZsaWdodERhdGEpXG5cbiAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZVxuICAgIG11dGFibGUuY2FjaGUgPSBjYWNoZVxuXG4gICAgY3VycmVudENhY2hlID0gY2FjaGVcbiAgICBjdXJyZW50VHJlZSA9IG5ld1RyZWVcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKVxufVxuIl0sIm5hbWVzIjpbInNlcnZlclBhdGNoUmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwic2VydmVyUmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJtdXRhYmxlIiwicHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwidHJlZSIsImN1cnJlbnRDYWNoZSIsImNhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJzZWdtZW50UGF0aCIsImZsaWdodFNlZ21lbnRQYXRoIiwidHJlZVBhdGNoIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiY3JlYXRlRW1wdHlDYWNoZU5vZGUiLCJhcHBseUZsaWdodERhdGEiLCJwYXRjaGVkVHJlZSIsImhhbmRsZU11dGFibGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js ***!
  \*******************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    addRefreshMarkerToActiveParallelSegments: function() {\n        return addRefreshMarkerToActiveParallelSegments;\n    },\n    refreshInactiveParallelSegments: function() {\n        return refreshInactiveParallelSegments;\n    }\n});\nconst _applyflightdata = __webpack_require__(/*! ./apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _segment = __webpack_require__(/*! ../../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nasync function refreshInactiveParallelSegments(options) {\n    const fetchedSegments = new Set();\n    await refreshInactiveParallelSegmentsImpl({\n        ...options,\n        rootTree: options.updatedTree,\n        fetchedSegments\n    });\n}\nasync function refreshInactiveParallelSegmentsImpl(param) {\n    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;\n    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;\n    const fetchPromises = [];\n    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === 'refresh' && // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)) {\n        fetchedSegments.add(refetchPath) // Mark this URL as fetched\n        ;\n        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n        const fetchPromise = (0, _fetchserverresponse.fetchServerResponse)(new URL(refetchPath, location.origin), {\n            // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n            // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n            flightRouterState: [\n                rootTree[0],\n                rootTree[1],\n                rootTree[2],\n                'refetch'\n            ],\n            nextUrl: includeNextUrl ? state.nextUrl : null\n        }).then((param)=>{\n            let { flightData } = param;\n            if (typeof flightData !== 'string') {\n                for (const flightDataPath of flightData){\n                    // we only pass the new cache as this function is called after clearing the router cache\n                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n                    // just been created & has been written to, but hasn't been \"committed\" yet.\n                    (0, _applyflightdata.applyFlightData)(updatedCache, updatedCache, flightDataPath);\n                }\n            } else {\n            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n            // when refreshing on-screen data, so handling this has been ommitted.\n            }\n        });\n        fetchPromises.push(fetchPromise);\n    }\n    for(const key in parallelRoutes){\n        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n            state,\n            updatedTree: parallelRoutes[key],\n            updatedCache,\n            includeNextUrl,\n            fetchedSegments,\n            rootTree,\n            canonicalUrl\n        });\n        fetchPromises.push(parallelFetchPromise);\n    }\n    await Promise.all(fetchPromises);\n}\nfunction addRefreshMarkerToActiveParallelSegments(tree, path) {\n    const [segment, parallelRoutes, , refetchMarker] = tree;\n    // a page segment might also contain concatenated search params, so we do a partial match on the key\n    if (segment.includes(_segment.PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n        tree[2] = path;\n        tree[3] = 'refresh';\n    }\n    for(const key in parallelRoutes){\n        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpSGdCQSx3Q0FBd0M7ZUFBeENBOztJQXZGTUMsK0JBQStCO2VBQS9CQTs7OzZDQXZCVTtpREFDSTtxQ0FDSDtBQXFCMUIsZUFBZUEsZ0NBQ3BCQyxPQUF3QztJQUV4QyxNQUFNQyxrQkFBa0IsSUFBSUM7SUFDNUIsTUFBTUMsb0NBQW9DO1FBQ3hDLEdBQUdILE9BQU87UUFDVkksVUFBVUosUUFBUUssV0FBVztRQUM3Qko7SUFDRjtBQUNGO0FBRUEsZUFBZUUsb0NBQW9DLEtBV2xEO0lBWGtELE1BQ2pERyxLQUFLLEVBQ0xELFdBQVcsRUFDWEUsWUFBWSxFQUNaQyxjQUFjLEVBQ2RQLGVBQWUsRUFDZkcsV0FBV0MsV0FBVyxFQUN0QkksWUFBWSxFQUliLEdBWGtEO0lBWWpELE1BQU0sR0FBR0MsZ0JBQWdCQyxhQUFhQyxjQUFjLEdBQUdQO0lBQ3ZELE1BQU1RLGdCQUFnQixFQUFFO0lBRXhCLElBQ0VGLGVBQ0FBLGdCQUFnQkYsZ0JBQ2hCRyxrQkFBa0IsYUFDbEIsNEZBQTRGO0lBQzVGLHNEQUFzRDtJQUN0RCxDQUFDWCxnQkFBZ0JhLEdBQUcsQ0FBQ0gsY0FDckI7UUFDQVYsZ0JBQWdCYyxHQUFHLENBQUNKLGFBQWEsMkJBQTJCOztRQUU1RCx3SEFBd0g7UUFDeEgsa0lBQWtJO1FBQ2xJLE1BQU1LLGVBQWVDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFDbkIsSUFBSUMsSUFBSVAsYUFBYVEsU0FBU0MsTUFBTSxHQUNwQztZQUNFLGdHQUFnRztZQUNoRyw4SEFBOEg7WUFDOUhDLG1CQUFtQjtnQkFBQ2pCLFFBQVEsQ0FBQyxFQUFFO2dCQUFFQSxRQUFRLENBQUMsRUFBRTtnQkFBRUEsUUFBUSxDQUFDLEVBQUU7Z0JBQUU7YUFBVTtZQUNyRWtCLFNBQVNkLGlCQUFpQkYsTUFBTWdCLE9BQU8sR0FBRztRQUM1QyxHQUNBQyxJQUFJLENBQUM7Z0JBQUMsRUFBRUMsVUFBVSxFQUFFO1lBQ3BCLElBQUksT0FBT0EsZUFBZSxVQUFVO2dCQUNsQyxLQUFLLE1BQU1DLGtCQUFrQkQsV0FBWTtvQkFDdkMsd0ZBQXdGO29CQUN4Riw0R0FBNEc7b0JBQzVHLDRFQUE0RTtvQkFDNUVFLENBQUFBLEdBQUFBLGlCQUFBQSxlQUFBQSxFQUFnQm5CLGNBQWNBLGNBQWNrQjtnQkFDOUM7WUFDRixPQUFPO1lBQ0wsNEdBQTRHO1lBQzVHLCtHQUErRztZQUMvRyxzRUFBc0U7WUFDeEU7UUFDRjtRQUVBWixjQUFjYyxJQUFJLENBQUNYO0lBQ3JCO0lBRUEsSUFBSyxNQUFNWSxPQUFPbEIsZUFBZ0I7UUFDaEMsTUFBTW1CLHVCQUF1QjFCLG9DQUFvQztZQUMvREc7WUFDQUQsYUFBYUssY0FBYyxDQUFDa0IsSUFBSTtZQUNoQ3JCO1lBQ0FDO1lBQ0FQO1lBQ0FHO1lBQ0FLO1FBQ0Y7UUFFQUksY0FBY2MsSUFBSSxDQUFDRTtJQUNyQjtJQUVBLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ2xCO0FBQ3BCO0FBUU8sU0FBU2YseUNBQ2RrQyxJQUF1QixFQUN2QkMsSUFBWTtJQUVaLE1BQU0sQ0FBQ0MsU0FBU3hCLGtCQUFrQkUsY0FBYyxHQUFHb0I7SUFDbkQsb0dBQW9HO0lBQ3BHLElBQUlFLFFBQVFDLFFBQVEsQ0FBQ0MsU0FBQUEsZ0JBQWdCLEtBQUt4QixrQkFBa0IsV0FBVztRQUNyRW9CLElBQUksQ0FBQyxFQUFFLEdBQUdDO1FBQ1ZELElBQUksQ0FBQyxFQUFFLEdBQUc7SUFDWjtJQUVBLElBQUssTUFBTUosT0FBT2xCLGVBQWdCO1FBQ2hDWix5Q0FBeUNZLGNBQWMsQ0FBQ2tCLElBQUksRUFBRUs7SUFDaEU7QUFDRiIsInNvdXJjZXMiOlsiL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWZldGNoLWluYWN0aXZlLXBhcmFsbGVsLXNlZ21lbnRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlclN0YXRlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4vYXBwbHktZmxpZ2h0LWRhdGEnXG5pbXBvcnQgeyBmZXRjaFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBQQUdFX1NFR01FTlRfS0VZIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuXG5pbnRlcmZhY2UgUmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyB7XG4gIHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxuICB1cGRhdGVkVHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgdXBkYXRlZENhY2hlOiBDYWNoZU5vZGVcbiAgaW5jbHVkZU5leHRVcmw6IGJvb2xlYW5cbiAgY2Fub25pY2FsVXJsOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBSZWZyZXNoZXMgaW5hY3RpdmUgc2VnbWVudHMgdGhhdCBhcmUgc3RpbGwgaW4gdGhlIGN1cnJlbnQgRmxpZ2h0Um91dGVyU3RhdGUuXG4gKiBBIHNlZ21lbnQgaXMgY29uc2lkZXJlZCBcImluYWN0aXZlXCIgd2hlbiB0aGUgc2VydmVyIHJlc3BvbnNlIGluZGljYXRlcyBpdCBkaWRuJ3QgbWF0Y2ggdG8gYSBwYWdlIGNvbXBvbmVudC5cbiAqIFRoaXMgaGFwcGVucyBkdXJpbmcgYSBzb2Z0LW5hdmlnYXRpb24sIHdoZXJlIHRoZSBzZXJ2ZXIgd2lsbCB3YW50IHRvIHBhdGNoIGluIHRoZSBzZWdtZW50XG4gKiB3aXRoIHRoZSBcImRlZmF1bHRcIiBjb21wb25lbnQsIGJ1dCB3ZSBleHBsaWNpdGx5IGlnbm9yZSB0aGUgc2VydmVyIGluIHRoaXMgY2FzZVxuICogYW5kIGtlZXAgdGhlIGV4aXN0aW5nIHN0YXRlIGZvciB0aGF0IHNlZ21lbnQuIE5ldyBkYXRhIGZvciBpbmFjdGl2ZSBzZWdtZW50cyBhcmUgaW5oZXJlbnRseVxuICogbm90IHBhcnQgb2YgdGhlIHNlcnZlciByZXNwb25zZSB3aGVuIHdlIHBhdGNoIHRoZSB0cmVlLCBiZWNhdXNlIHRoZXkgd2VyZSBhc3NvY2lhdGVkIHdpdGggYSByZXNwb25zZVxuICogZnJvbSBhbiBlYXJsaWVyIG5hdmlnYXRpb24vcmVxdWVzdC4gRm9yIGVhY2ggc2VnbWVudCwgb25jZSBpdCBiZWNvbWVzIFwiYWN0aXZlXCIsIHdlIGVuY29kZSB0aGUgVVJMIHRoYXQgcHJvdmlkZWRcbiAqIHRoZSBkYXRhIGZvciBpdC4gVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgcGFyYWxsZWwgcm91dGVzIGxvb2tpbmcgZm9yIHRoZXNlIG1hcmtlcnMgc28gdGhhdCBpdCBjYW4gcmUtZmV0Y2hcbiAqIGFuZCBwYXRjaCB0aGUgbmV3IGRhdGEgaW50byB0aGUgdHJlZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMoXG4gIG9wdGlvbnM6IFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNcbikge1xuICBjb25zdCBmZXRjaGVkU2VnbWVudHMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICBhd2FpdCByZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICByb290VHJlZTogb3B0aW9ucy51cGRhdGVkVHJlZSxcbiAgICBmZXRjaGVkU2VnbWVudHMsXG4gIH0pXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgc3RhdGUsXG4gIHVwZGF0ZWRUcmVlLFxuICB1cGRhdGVkQ2FjaGUsXG4gIGluY2x1ZGVOZXh0VXJsLFxuICBmZXRjaGVkU2VnbWVudHMsXG4gIHJvb3RUcmVlID0gdXBkYXRlZFRyZWUsXG4gIGNhbm9uaWNhbFVybCxcbn06IFJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHMgJiB7XG4gIGZldGNoZWRTZWdtZW50czogU2V0PHN0cmluZz5cbiAgcm9vdFRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG59KSB7XG4gIGNvbnN0IFssIHBhcmFsbGVsUm91dGVzLCByZWZldGNoUGF0aCwgcmVmZXRjaE1hcmtlcl0gPSB1cGRhdGVkVHJlZVxuICBjb25zdCBmZXRjaFByb21pc2VzID0gW11cblxuICBpZiAoXG4gICAgcmVmZXRjaFBhdGggJiZcbiAgICByZWZldGNoUGF0aCAhPT0gY2Fub25pY2FsVXJsICYmXG4gICAgcmVmZXRjaE1hcmtlciA9PT0gJ3JlZnJlc2gnICYmXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHRyZWUgdG8gY29udGFpbiBtdWx0aXBsZSBzZWdtZW50cyB0aGF0IGNvbnRhaW4gZGF0YSBhdCB0aGUgc2FtZSBVUkxcbiAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHRoZW0gc28gd2UgY2FuIGRlZHVwZSB0aGUgcmVxdWVzdHNcbiAgICAhZmV0Y2hlZFNlZ21lbnRzLmhhcyhyZWZldGNoUGF0aClcbiAgKSB7XG4gICAgZmV0Y2hlZFNlZ21lbnRzLmFkZChyZWZldGNoUGF0aCkgLy8gTWFyayB0aGlzIFVSTCBhcyBmZXRjaGVkXG5cbiAgICAvLyBFYWdlcmx5IGtpY2sgb2ZmIHRoZSBmZXRjaCBmb3IgdGhlIHJlZmV0Y2ggcGF0aCAmIHRoZSBwYXJhbGxlbCByb3V0ZXMuIFRoaXMgc2hvdWxkIGJlIGZpbmUgdG8gZG8gYXMgdGhleSBlYWNoIG9wZXJhdGVcbiAgICAvLyBpbmRlcGVuZGVudGx5IG9uIHRoZWlyIG93biBjYWNoZSBub2RlcywgYW5kIGBhcHBseUZsaWdodERhdGFgIHdpbGwgY29weSBhbnl0aGluZyBpdCBkb2Vzbid0IGNhcmUgYWJvdXQgZnJvbSB0aGUgZXhpc3RpbmcgY2FjaGUuXG4gICAgY29uc3QgZmV0Y2hQcm9taXNlID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShcbiAgICAgIG5ldyBVUkwocmVmZXRjaFBhdGgsIGxvY2F0aW9uLm9yaWdpbiksXG4gICAgICB7XG4gICAgICAgIC8vIHJlZmV0Y2ggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdXBkYXRlZCB0cmVlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBzY29wZWQgdG8gdGhlIGN1cnJlbnQgc2VnbWVudFxuICAgICAgICAvLyBhbmQgbWlnaHQgbm90IGNvbnRhaW4gdGhlIGRhdGEgd2UgbmVlZCB0byBwYXRjaCBpbiBpbnRlcmNlcHRpb24gcm91dGUgZGF0YSAoc3VjaCBhcyBkeW5hbWljIHBhcmFtcyBmcm9tIGEgcHJldmlvdXMgc2VnbWVudClcbiAgICAgICAgZmxpZ2h0Um91dGVyU3RhdGU6IFtyb290VHJlZVswXSwgcm9vdFRyZWVbMV0sIHJvb3RUcmVlWzJdLCAncmVmZXRjaCddLFxuICAgICAgICBuZXh0VXJsOiBpbmNsdWRlTmV4dFVybCA/IHN0YXRlLm5leHRVcmwgOiBudWxsLFxuICAgICAgfVxuICAgICkudGhlbigoeyBmbGlnaHREYXRhIH0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yIChjb25zdCBmbGlnaHREYXRhUGF0aCBvZiBmbGlnaHREYXRhKSB7XG4gICAgICAgICAgLy8gd2Ugb25seSBwYXNzIHRoZSBuZXcgY2FjaGUgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgY2xlYXJpbmcgdGhlIHJvdXRlciBjYWNoZVxuICAgICAgICAgIC8vIGFuZCBmaWxsaW5nIGluIHRoZSBuZXcgcGFnZSBkYXRhIGZyb20gdGhlIHNlcnZlci4gTWVhbmluZyB0aGUgZXhpc3RpbmcgY2FjaGUgaXMgYWN0dWFsbHkgdGhlIGNhY2hlIHRoYXQnc1xuICAgICAgICAgIC8vIGp1c3QgYmVlbiBjcmVhdGVkICYgaGFzIGJlZW4gd3JpdHRlbiB0bywgYnV0IGhhc24ndCBiZWVuIFwiY29tbWl0dGVkXCIgeWV0LlxuICAgICAgICAgIGFwcGx5RmxpZ2h0RGF0YSh1cGRhdGVkQ2FjaGUsIHVwZGF0ZWRDYWNoZSwgZmxpZ2h0RGF0YVBhdGgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gZmxpZ2h0RGF0YSBpcyBhIHN0cmluZywgaXQgc3VnZ2VzdHMgdGhhdCB0aGUgc2VydmVyIHJlc3BvbnNlIHNob3VsZCBoYXZlIHRyaWdnZXJlZCBhbiBNUEEgbmF2aWdhdGlvblxuICAgICAgICAvLyBJJ20gbm90IDEwMCUgc3VyZSBvZiB0aGlzIGRlY2lzaW9uLCBidXQgaXQgc2VlbXMgdW5saWtlbHkgdGhhdCB3ZSdkIHdhbnQgdG8gaW50cm9kdWNlIGEgcmVkaXJlY3Qgc2lkZSBlZmZlY3RcbiAgICAgICAgLy8gd2hlbiByZWZyZXNoaW5nIG9uLXNjcmVlbiBkYXRhLCBzbyBoYW5kbGluZyB0aGlzIGhhcyBiZWVuIG9tbWl0dGVkLlxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmZXRjaFByb21pc2VzLnB1c2goZmV0Y2hQcm9taXNlKVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBjb25zdCBwYXJhbGxlbEZldGNoUHJvbWlzZSA9IHJlZnJlc2hJbmFjdGl2ZVBhcmFsbGVsU2VnbWVudHNJbXBsKHtcbiAgICAgIHN0YXRlLFxuICAgICAgdXBkYXRlZFRyZWU6IHBhcmFsbGVsUm91dGVzW2tleV0sXG4gICAgICB1cGRhdGVkQ2FjaGUsXG4gICAgICBpbmNsdWRlTmV4dFVybCxcbiAgICAgIGZldGNoZWRTZWdtZW50cyxcbiAgICAgIHJvb3RUcmVlLFxuICAgICAgY2Fub25pY2FsVXJsLFxuICAgIH0pXG5cbiAgICBmZXRjaFByb21pc2VzLnB1c2gocGFyYWxsZWxGZXRjaFByb21pc2UpXG4gIH1cblxuICBhd2FpdCBQcm9taXNlLmFsbChmZXRjaFByb21pc2VzKVxufVxuXG4vKipcbiAqIFdhbGtzIHRoZSBjdXJyZW50IHBhcmFsbGVsIHNlZ21lbnRzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBcImFjdGl2ZVwiLlxuICogQW4gYWN0aXZlIHBhcmFsbGVsIHJvdXRlIHdpbGwgaGF2ZSBhIGBfX1BBR0VfX2Agc2VnbWVudCBpbiB0aGUgRmxpZ2h0Um91dGVyU3RhdGUuXG4gKiBBcyBvcHBvc2VkIHRvIGEgYF9fREVGQVVMVF9fYCBzZWdtZW50LCB3aGljaCBtZWFucyB0aGVyZSB3YXMgbm8gbWF0Y2ggZm9yIHRoYXQgcGFyYWxsZWwgcm91dGUuXG4gKiBXZSBhZGQgYSBzcGVjaWFsIG1hcmtlciBoZXJlIHNvIHRoYXQgd2Uga25vdyBob3cgdG8gcmVmcmVzaCBpdHMgZGF0YSB3aGVuIHRoZSByb3V0ZXIgaXMgcmV2YWxpZGF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKFxuICB0cmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgcGF0aDogc3RyaW5nXG4pIHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsIHJlZmV0Y2hNYXJrZXJdID0gdHJlZVxuICAvLyBhIHBhZ2Ugc2VnbWVudCBtaWdodCBhbHNvIGNvbnRhaW4gY29uY2F0ZW5hdGVkIHNlYXJjaCBwYXJhbXMsIHNvIHdlIGRvIGEgcGFydGlhbCBtYXRjaCBvbiB0aGUga2V5XG4gIGlmIChzZWdtZW50LmluY2x1ZGVzKFBBR0VfU0VHTUVOVF9LRVkpICYmIHJlZmV0Y2hNYXJrZXIgIT09ICdyZWZyZXNoJykge1xuICAgIHRyZWVbMl0gPSBwYXRoXG4gICAgdHJlZVszXSA9ICdyZWZyZXNoJ1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKHBhcmFsbGVsUm91dGVzW2tleV0sIHBhdGgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwicmVmcmVzaEluYWN0aXZlUGFyYWxsZWxTZWdtZW50cyIsIm9wdGlvbnMiLCJmZXRjaGVkU2VnbWVudHMiLCJTZXQiLCJyZWZyZXNoSW5hY3RpdmVQYXJhbGxlbFNlZ21lbnRzSW1wbCIsInJvb3RUcmVlIiwidXBkYXRlZFRyZWUiLCJzdGF0ZSIsInVwZGF0ZWRDYWNoZSIsImluY2x1ZGVOZXh0VXJsIiwiY2Fub25pY2FsVXJsIiwicGFyYWxsZWxSb3V0ZXMiLCJyZWZldGNoUGF0aCIsInJlZmV0Y2hNYXJrZXIiLCJmZXRjaFByb21pc2VzIiwiaGFzIiwiYWRkIiwiZmV0Y2hQcm9taXNlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJuZXh0VXJsIiwidGhlbiIsImZsaWdodERhdGEiLCJmbGlnaHREYXRhUGF0aCIsImFwcGx5RmxpZ2h0RGF0YSIsInB1c2giLCJrZXkiLCJwYXJhbGxlbEZldGNoUHJvbWlzZSIsIlByb21pc2UiLCJhbGwiLCJ0cmVlIiwicGF0aCIsInNlZ21lbnQiLCJpbmNsdWRlcyIsIlBBR0VfU0VHTUVOVF9LRVkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ACTION_HMR_REFRESH: function() {\n        return ACTION_HMR_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    PrefetchCacheEntryStatus: function() {\n        return PrefetchCacheEntryStatus;\n    },\n    PrefetchKind: function() {\n        return PrefetchKind;\n    }\n});\nconst ACTION_REFRESH = 'refresh';\nconst ACTION_NAVIGATE = 'navigate';\nconst ACTION_RESTORE = 'restore';\nconst ACTION_SERVER_PATCH = 'server-patch';\nconst ACTION_PREFETCH = 'prefetch';\nconst ACTION_HMR_REFRESH = 'hmr-refresh';\nconst ACTION_SERVER_ACTION = 'server-action';\nvar PrefetchKind = /*#__PURE__*/ function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n    return PrefetchKind;\n}({});\nvar PrefetchCacheEntryStatus = /*#__PURE__*/ function(PrefetchCacheEntryStatus) {\n    PrefetchCacheEntryStatus[\"fresh\"] = \"fresh\";\n    PrefetchCacheEntryStatus[\"reusable\"] = \"reusable\";\n    PrefetchCacheEntryStatus[\"expired\"] = \"expired\";\n    PrefetchCacheEntryStatus[\"stale\"] = \"stale\";\n    return PrefetchCacheEntryStatus;\n}({});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBWWFBLGtCQUFrQjtlQUFsQkE7O0lBSkFDLGVBQWU7ZUFBZkE7O0lBR0FDLGVBQWU7ZUFBZkE7O0lBSkFDLGNBQWM7ZUFBZEE7O0lBRUFDLGNBQWM7ZUFBZEE7O0lBSUFDLG9CQUFvQjtlQUFwQkE7O0lBSEFDLG1CQUFtQjtlQUFuQkE7O0lBNE1EQyx3QkFBd0I7ZUFBeEJBOztJQWhFQUMsWUFBWTtlQUFaQTs7O0FBL0lMLE1BQU1MLGlCQUFpQjtBQUN2QixNQUFNRixrQkFBa0I7QUFDeEIsTUFBTUcsaUJBQWlCO0FBQ3ZCLE1BQU1FLHNCQUFzQjtBQUM1QixNQUFNSixrQkFBa0I7QUFDeEIsTUFBTUYscUJBQXFCO0FBQzNCLE1BQU1LLHVCQUF1QjtBQXlJN0IsSUFBS0csZUFBQUEsV0FBQUEsR0FBQUEsU0FBQUEsWUFBQUE7Ozs7V0FBQUE7O0FBZ0VMLElBQUtELDJCQUFBQSxXQUFBQSxHQUFBQSxTQUFBQSx3QkFBQUE7Ozs7O1dBQUFBIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBGbGlnaHRTZWdtZW50UGF0aCxcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQgfSBmcm9tICcuL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcblxuZXhwb3J0IGNvbnN0IEFDVElPTl9SRUZSRVNIID0gJ3JlZnJlc2gnXG5leHBvcnQgY29uc3QgQUNUSU9OX05BVklHQVRFID0gJ25hdmlnYXRlJ1xuZXhwb3J0IGNvbnN0IEFDVElPTl9SRVNUT1JFID0gJ3Jlc3RvcmUnXG5leHBvcnQgY29uc3QgQUNUSU9OX1NFUlZFUl9QQVRDSCA9ICdzZXJ2ZXItcGF0Y2gnXG5leHBvcnQgY29uc3QgQUNUSU9OX1BSRUZFVENIID0gJ3ByZWZldGNoJ1xuZXhwb3J0IGNvbnN0IEFDVElPTl9ITVJfUkVGUkVTSCA9ICdobXItcmVmcmVzaCdcbmV4cG9ydCBjb25zdCBBQ1RJT05fU0VSVkVSX0FDVElPTiA9ICdzZXJ2ZXItYWN0aW9uJ1xuXG5leHBvcnQgdHlwZSBSb3V0ZXJDaGFuZ2VCeVNlcnZlclJlc3BvbnNlID0gKHtcbiAgcHJldmlvdXNUcmVlLFxuICBzZXJ2ZXJSZXNwb25zZSxcbn06IHtcbiAgcHJldmlvdXNUcmVlOiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICBzZXJ2ZXJSZXNwb25zZTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxufSkgPT4gdm9pZFxuXG5leHBvcnQgdHlwZSBSb3V0ZXJOYXZpZ2F0ZSA9IChcbiAgaHJlZjogc3RyaW5nLFxuICBuYXZpZ2F0ZVR5cGU6ICdwdXNoJyB8ICdyZXBsYWNlJyxcbiAgc2hvdWxkU2Nyb2xsOiBib29sZWFuXG4pID0+IHZvaWRcblxuZXhwb3J0IGludGVyZmFjZSBNdXRhYmxlIHtcbiAgbXBhTmF2aWdhdGlvbj86IGJvb2xlYW5cbiAgcGF0Y2hlZFRyZWU/OiBGbGlnaHRSb3V0ZXJTdGF0ZVxuICBjYW5vbmljYWxVcmw/OiBzdHJpbmdcbiAgc2Nyb2xsYWJsZVNlZ21lbnRzPzogRmxpZ2h0U2VnbWVudFBhdGhbXVxuICBwZW5kaW5nUHVzaD86IGJvb2xlYW5cbiAgY2FjaGU/OiBDYWNoZU5vZGVcbiAgcHJlZmV0Y2hDYWNoZT86IEFwcFJvdXRlclN0YXRlWydwcmVmZXRjaENhY2hlJ11cbiAgaGFzaEZyYWdtZW50Pzogc3RyaW5nXG4gIHNob3VsZFNjcm9sbD86IGJvb2xlYW5cbiAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU/OiBib29sZWFuXG4gIG9ubHlIYXNoQ2hhbmdlPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlcnZlckFjdGlvbk11dGFibGUgZXh0ZW5kcyBNdXRhYmxlIHtcbiAgaW5GbGlnaHRTZXJ2ZXJBY3Rpb24/OiBQcm9taXNlPGFueT4gfCBudWxsXG59XG5cbi8qKlxuICogUmVmcmVzaCB0cmlnZ2VycyBhIHJlZnJlc2ggb2YgdGhlIGZ1bGwgcGFnZSBkYXRhLlxuICogLSBmZXRjaGVzIHRoZSBGbGlnaHQgZGF0YSBhbmQgZmlsbHMgcnNjIGF0IHRoZSByb290IG9mIHRoZSBjYWNoZS5cbiAqIC0gVGhlIHJvdXRlciBzdGF0ZSBpcyB1cGRhdGVkIGF0IHRoZSByb290LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlZnJlc2hBY3Rpb24ge1xuICB0eXBlOiB0eXBlb2YgQUNUSU9OX1JFRlJFU0hcbiAgb3JpZ2luOiBMb2NhdGlvblsnb3JpZ2luJ11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBIbXJSZWZyZXNoQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9ITVJfUkVGUkVTSFxuICBvcmlnaW46IExvY2F0aW9uWydvcmlnaW4nXVxufVxuXG5leHBvcnQgdHlwZSBTZXJ2ZXJBY3Rpb25EaXNwYXRjaGVyID0gKFxuICBhcmdzOiBPbWl0PFxuICAgIFNlcnZlckFjdGlvbkFjdGlvbixcbiAgICAndHlwZScgfCAnbXV0YWJsZScgfCAnbmF2aWdhdGUnIHwgJ2NoYW5nZUJ5U2VydmVyUmVzcG9uc2UnIHwgJ2NhY2hlJ1xuICA+XG4pID0+IHZvaWRcblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJBY3Rpb25BY3Rpb24ge1xuICB0eXBlOiB0eXBlb2YgQUNUSU9OX1NFUlZFUl9BQ1RJT05cbiAgYWN0aW9uSWQ6IHN0cmluZ1xuICBhY3Rpb25BcmdzOiBhbnlbXVxuICByZXNvbHZlOiAodmFsdWU6IGFueSkgPT4gdm9pZFxuICByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWRcbn1cblxuLyoqXG4gKiBOYXZpZ2F0ZSB0cmlnZ2VycyBhIG5hdmlnYXRpb24gdG8gdGhlIHByb3ZpZGVkIHVybC4gSXQgc3VwcG9ydHMgdHdvIHR5cGVzOiBgcHVzaGAgYW5kIGByZXBsYWNlYC5cbiAqXG4gKiBgbmF2aWdhdGVUeXBlYDpcbiAqIC0gYHB1c2hgIC0gcHVzaGVzIGEgbmV3IGhpc3RvcnkgZW50cnkgaW4gdGhlIGJyb3dzZXIgaGlzdG9yeVxuICogLSBgcmVwbGFjZWAgLSByZXBsYWNlcyB0aGUgY3VycmVudCBoaXN0b3J5IGVudHJ5IGluIHRoZSBicm93c2VyIGhpc3RvcnlcbiAqXG4gKiBOYXZpZ2F0ZSBoYXMgbXVsdGlwbGUgY2FjaGUgaGV1cmlzdGljczpcbiAqIC0gcGFnZSB3YXMgcHJlZmV0Y2hlZFxuICogIC0gQXBwbHkgcm91dGVyIHN0YXRlIHRyZWUgZnJvbSBwcmVmZXRjaFxuICogIC0gQXBwbHkgRmxpZ2h0IGRhdGEgZnJvbSBwcmVmZXRjaCB0byB0aGUgY2FjaGVcbiAqICAtIElmIEZsaWdodCBkYXRhIGlzIGEgc3RyaW5nLCBpdCdzIGEgcmVkaXJlY3QgYW5kIHRoZSBzdGF0ZSBpcyB1cGRhdGVkIHRvIHRyaWdnZXIgYSByZWRpcmVjdFxuICogIC0gQ2hlY2sgaWYgaGFyZCBuYXZpZ2F0aW9uIGlzIG5lZWRlZFxuICogICAgLSBIYXJkIG5hdmlnYXRpb24gaGFwcGVucyB3aGVuIGEgZHluYW1pYyBwYXJhbWV0ZXIgYmVsb3cgdGhlIGNvbW1vbiBsYXlvdXQgY2hhbmdlZFxuICogICAgLSBXaGVuIGhhcmQgbmF2aWdhdGlvbiBpcyBuZWVkZWQgdGhlIGNhY2hlIGlzIGludmFsaWRhdGVkIGJlbG93IHRoZSBmbGlnaHRTZWdtZW50UGF0aFxuICogICAgLSBUaGUgbWlzc2luZyBjYWNoZSBub2RlcyBvZiB0aGUgcGFnZSB3aWxsIGJlIGZldGNoZWQgaW4gbGF5b3V0LXJvdXRlciBhbmQgdHJpZ2dlciB0aGUgU0VSVkVSX1BBVENIIGFjdGlvblxuICogIC0gSWYgaGFyZCBuYXZpZ2F0aW9uIGlzIG5vdCBuZWVkZWRcbiAqICAgIC0gVGhlIGNhY2hlIGlzIHJldXNlZFxuICogICAgLSBJZiBhbnkgY2FjaGUgbm9kZXMgYXJlIG1pc3NpbmcgdGhleSdsbCBiZSBmZXRjaGVkIGluIGxheW91dC1yb3V0ZXIgYW5kIHRyaWdnZXIgdGhlIFNFUlZFUl9QQVRDSCBhY3Rpb25cbiAqIC0gcGFnZSB3YXMgbm90IHByZWZldGNoZWRcbiAqICAtIFRoZSBuYXZpZ2F0ZSB3YXMgY2FsbGVkIGZyb20gYG5leHQvcm91dGVyYCAoYHJvdXRlci5wdXNoKClgIC8gYHJvdXRlci5yZXBsYWNlKClgKSAvIGBuZXh0L2xpbmtgIHdpdGhvdXQgcHJlZmV0Y2hlZCBkYXRhIGF2YWlsYWJsZSAoZS5nLiB0aGUgcHJlZmV0Y2ggZGlkbid0IGNvbWUgYmFjayBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIGNsaWNraW5nIHRoZSBsaW5rKVxuICogICAgLSBGbGlnaHQgZGF0YSBpcyBmZXRjaGVkIGluIHRoZSByZWR1Y2VyIChzdXNwZW5kcyB0aGUgcmVkdWNlcilcbiAqICAgIC0gUm91dGVyIHN0YXRlIHRyZWUgaXMgY3JlYXRlZCBiYXNlZCBvbiBGbGlnaHQgZGF0YVxuICogICAgLSBDYWNoZSBpcyBmaWxsZWQgYmFzZWQgb24gdGhlIEZsaWdodCBkYXRhXG4gKlxuICogQWJvdmUgc3RlcHMgZXhwbGFpbiAzIGNhc2VzOlxuICogLSBgc29mdGAgLSBSZXVzZXMgdGhlIGV4aXN0aW5nIGNhY2hlIGFuZCBmZXRjaGVzIG1pc3Npbmcgbm9kZXMgaW4gbGF5b3V0LXJvdXRlci5cbiAqIC0gYGhhcmRgIC0gQ3JlYXRlcyBhIG5ldyBjYWNoZSB3aGVyZSBjYWNoZSBub2RlcyBhcmUgcmVtb3ZlZCBiZWxvdyB0aGUgY29tbW9uIGxheW91dCBhbmQgZmV0Y2hlcyBtaXNzaW5nIG5vZGVzIGluIGxheW91dC1yb3V0ZXIuXG4gKiAtIGBvcHRpbWlzdGljYCAoZXhwbGljaXQgbm8gcHJlZmV0Y2gpIC0gQ3JlYXRlcyBhIG5ldyBjYWNoZSBhbmQga2lja3Mgb2ZmIHRoZSBkYXRhIGZldGNoIGluIHRoZSByZWR1Y2VyLiBUaGUgZGF0YSBmZXRjaCBpcyBhd2FpdGVkIGluIHRoZSBsYXlvdXQtcm91dGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlQWN0aW9uIHtcbiAgdHlwZTogdHlwZW9mIEFDVElPTl9OQVZJR0FURVxuICB1cmw6IFVSTFxuICBpc0V4dGVybmFsVXJsOiBib29sZWFuXG4gIGxvY2F0aW9uU2VhcmNoOiBMb2NhdGlvblsnc2VhcmNoJ11cbiAgbmF2aWdhdGVUeXBlOiAncHVzaCcgfCAncmVwbGFjZSdcbiAgc2hvdWxkU2Nyb2xsOiBib29sZWFuXG4gIGFsbG93QWxpYXNpbmc6IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBSZXN0b3JlIGFwcGxpZXMgdGhlIHByb3ZpZGVkIHJvdXRlciBzdGF0ZS5cbiAqIC0gVXNlZCBmb3IgYHBvcHN0YXRlYCAoYmFjay9mb3J3YXJkIG5hdmlnYXRpb24pIHdoZXJlIGEga25vd24gcm91dGVyIHN0YXRlIGhhcyB0byBiZSBhcHBsaWVkLlxuICogLSBBbHNvIHVzZWQgd2hlbiBzeW5jaW5nIHRoZSByb3V0ZXIgc3RhdGUgd2l0aCBgcHVzaFN0YXRlYC9gcmVwbGFjZVN0YXRlYCBjYWxscy5cbiAqIC0gUm91dGVyIHN0YXRlIGlzIGFwcGxpZWQgYXMtaXMgZnJvbSB0aGUgaGlzdG9yeSBzdGF0ZSwgaWYgYXZhaWxhYmxlLlxuICogLSBJZiB0aGUgaGlzdG9yeSBzdGF0ZSBkb2VzIG5vdCBjb250YWluIHRoZSByb3V0ZXIgc3RhdGUsIHRoZSBleGlzdGluZyByb3V0ZXIgc3RhdGUgaXMgdXNlZC5cbiAqIC0gSWYgYW55IGNhY2hlIG5vZGUgaXMgbWlzc2luZyBpdCB3aWxsIGJlIGZldGNoZWQgaW4gbGF5b3V0LXJvdXRlciBkdXJpbmcgcmVuZGVyaW5nIGFuZCB0aGUgc2VydmVyLXBhdGNoIGNhc2UuXG4gKiAtIElmIGV4aXN0aW5nIGNhY2hlIG5vZGVzIG1hdGNoIHRoZXNlIGFyZSB1c2VkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlc3RvcmVBY3Rpb24ge1xuICB0eXBlOiB0eXBlb2YgQUNUSU9OX1JFU1RPUkVcbiAgdXJsOiBVUkxcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGUgfCB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBTZXJ2ZXItcGF0Y2ggYXBwbGllcyB0aGUgcHJvdmlkZWQgRmxpZ2h0IGRhdGEgdG8gdGhlIGNhY2hlIGFuZCByb3V0ZXIgdHJlZS5cbiAqIC0gT25seSB0cmlnZ2VyZWQgaW4gbGF5b3V0LXJvdXRlci5cbiAqIC0gQ3JlYXRlcyBhIG5ldyBjYWNoZSBhbmQgcm91dGVyIHN0YXRlIHdpdGggdGhlIEZsaWdodCBkYXRhIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyUGF0Y2hBY3Rpb24ge1xuICB0eXBlOiB0eXBlb2YgQUNUSU9OX1NFUlZFUl9QQVRDSFxuICBzZXJ2ZXJSZXNwb25zZTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdFxuICBwcmV2aW91c1RyZWU6IEZsaWdodFJvdXRlclN0YXRlXG59XG5cbi8qKlxuICogUHJlZmV0Y2hLaW5kIGRlZmluZXMgdGhlIHR5cGUgb2YgcHJlZmV0Y2hpbmcgdGhhdCBzaG91bGQgYmUgZG9uZS5cbiAqIC0gYGF1dG9gIC0gaWYgdGhlIHBhZ2UgaXMgZHluYW1pYywgcHJlZmV0Y2ggdGhlIHBhZ2UgZGF0YSBwYXJ0aWFsbHksIGlmIHN0YXRpYyBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgZnVsbGAgLSBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIGZ1bGx5LlxuICogLSBgdGVtcG9yYXJ5YCAtIGEgdGVtcG9yYXJ5IHByZWZldGNoIGVudHJ5IGlzIGFkZGVkIHRvIHRoZSBjYWNoZSwgdGhpcyBpcyB1c2VkIHdoZW4gcHJlZmV0Y2g9e2ZhbHNlfSBpcyB1c2VkIGluIG5leHQvbGluayBvciB3aGVuIHlvdSBwdXNoIGEgcm91dGUgcHJvZ3JhbW1hdGljYWxseS5cbiAqL1xuXG5leHBvcnQgZW51bSBQcmVmZXRjaEtpbmQge1xuICBBVVRPID0gJ2F1dG8nLFxuICBGVUxMID0gJ2Z1bGwnLFxuICBURU1QT1JBUlkgPSAndGVtcG9yYXJ5Jyxcbn1cblxuLyoqXG4gKiBQcmVmZXRjaCBhZGRzIHRoZSBwcm92aWRlZCBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBDcmVhdGVzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBiYXNlZCBvbiB0aGUgcGF0Y2ggaW4gRmxpZ2h0RGF0YVxuICogLSBBZGRzIHRoZSBGbGlnaHREYXRhIHRvIHRoZSBwcmVmZXRjaCBjYWNoZVxuICogLSBJbiBBQ1RJT05fTkFWSUdBVEUgdGhlIHByZWZldGNoIGNhY2hlIGlzIGNoZWNrZWQgYW5kIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBhbmQgRmxpZ2h0RGF0YSBhcmUgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVmZXRjaEFjdGlvbiB7XG4gIHR5cGU6IHR5cGVvZiBBQ1RJT05fUFJFRkVUQ0hcbiAgdXJsOiBVUkxcbiAga2luZDogUHJlZmV0Y2hLaW5kXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaFJlZiB7XG4gIC8qKlxuICAgKiBJZiB0aGUgYXBwLXJvdXRlciBzaG91bGQgcHVzaCBhIG5ldyBoaXN0b3J5IGVudHJ5IGluIGFwcC1yb3V0ZXIncyB1c2VFZmZlY3QoKVxuICAgKi9cbiAgcGVuZGluZ1B1c2g6IGJvb2xlYW5cbiAgLyoqXG4gICAqIE11bHRpLXBhZ2UgbmF2aWdhdGlvbiB0aHJvdWdoIGxvY2F0aW9uLmhyZWYuXG4gICAqL1xuICBtcGFOYXZpZ2F0aW9uOiBib29sZWFuXG4gIC8qKlxuICAgKiBTa2lwIGFwcGx5aW5nIHRoZSByb3V0ZXIgc3RhdGUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeSBzdGF0ZS5cbiAgICovXG4gIHByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZvY3VzQW5kU2Nyb2xsUmVmID0ge1xuICAvKipcbiAgICogSWYgZm9jdXMgYW5kIHNjcm9sbCBzaG91bGQgYmUgc2V0IGluIHRoZSBsYXlvdXQtcm91dGVyJ3MgdXNlRWZmZWN0KClcbiAgICovXG4gIGFwcGx5OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgaGFzaCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCB0by5cbiAgICovXG4gIGhhc2hGcmFnbWVudDogc3RyaW5nIHwgbnVsbFxuICAvKipcbiAgICogVGhlIHBhdGhzIG9mIHRoZSBzZWdtZW50cyB0aGF0IHNob3VsZCBiZSBmb2N1c2VkLlxuICAgKi9cbiAgc2VnbWVudFBhdGhzOiBGbGlnaHRTZWdtZW50UGF0aFtdXG4gIC8qKlxuICAgKiBJZiBvbmx5IHRoZSBVUkxzIGhhc2ggZnJhZ21lbnQgY2hhbmdlZFxuICAgKi9cbiAgb25seUhhc2hDaGFuZ2U6IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgUHJlZmV0Y2hDYWNoZUVudHJ5ID0ge1xuICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogRmxpZ2h0Um91dGVyU3RhdGVcbiAgZGF0YTogUHJvbWlzZTxGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0PlxuICBraW5kOiBQcmVmZXRjaEtpbmRcbiAgcHJlZmV0Y2hUaW1lOiBudW1iZXJcbiAgc3RhbGVUaW1lOiBudW1iZXJcbiAgbGFzdFVzZWRUaW1lOiBudW1iZXIgfCBudWxsXG4gIGtleTogc3RyaW5nXG4gIHN0YXR1czogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzXG4gIHVybDogVVJMXG59XG5cbmV4cG9ydCBlbnVtIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cyB7XG4gIGZyZXNoID0gJ2ZyZXNoJyxcbiAgcmV1c2FibGUgPSAncmV1c2FibGUnLFxuICBleHBpcmVkID0gJ2V4cGlyZWQnLFxuICBzdGFsZSA9ICdzdGFsZScsXG59XG5cbi8qKlxuICogSGFuZGxlcyBrZWVwaW5nIHRoZSBzdGF0ZSBvZiBhcHAtcm91dGVyLlxuICovXG5leHBvcnQgdHlwZSBBcHBSb3V0ZXJTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIFRoZSByb3V0ZXIgc3RhdGUsIHRoaXMgaXMgd3JpdHRlbiBpbnRvIHRoZSBoaXN0b3J5IHN0YXRlIGluIGFwcC1yb3V0ZXIgdXNpbmcgcmVwbGFjZVN0YXRlL3B1c2hTdGF0ZS5cbiAgICogLSBIYXMgdG8gYmUgc2VyaWFsaXphYmxlIGFzIGl0IGlzIHdyaXR0ZW4gaW50byB0aGUgaGlzdG9yeSBzdGF0ZS5cbiAgICogLSBIb2xkcyB3aGljaCBzZWdtZW50cyBhbmQgcGFyYWxsZWwgcm91dGVzIGFyZSBzaG93biBvbiB0aGUgc2NyZWVuLlxuICAgKi9cbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgLyoqXG4gICAqIFRoZSBjYWNoZSBob2xkcyBSZWFjdCBub2RlcyBmb3IgZXZlcnkgc2VnbWVudCB0aGF0IGlzIHNob3duIG9uIHNjcmVlbiBhcyB3ZWxsIGFzIHByZXZpb3VzbHkgc2hvd24gc2VnbWVudHMuXG4gICAqIEl0IGFsc28gaG9sZHMgaW4tcHJvZ3Jlc3MgZGF0YSByZXF1ZXN0cy5cbiAgICogUHJlZmV0Y2hlZCBkYXRhIGlzIHN0b3JlZCBzZXBhcmF0ZWx5IGluIGBwcmVmZXRjaENhY2hlYCwgdGhhdCBpcyBhcHBsaWVkIGR1cmluZyBBQ1RJT05fTkFWSUdBVEUuXG4gICAqL1xuICBjYWNoZTogQ2FjaGVOb2RlXG4gIC8qKlxuICAgKiBDYWNoZSB0aGF0IGhvbGRzIHByZWZldGNoZWQgRmxpZ2h0IHJlc3BvbnNlcyBrZXllZCBieSB1cmwuXG4gICAqL1xuICBwcmVmZXRjaENhY2hlOiBNYXA8c3RyaW5nLCBQcmVmZXRjaENhY2hlRW50cnk+XG4gIC8qKlxuICAgKiBEZWNpZGVzIGlmIHRoZSB1cGRhdGUgc2hvdWxkIGNyZWF0ZSBhIG5ldyBoaXN0b3J5IGVudHJ5IGFuZCBpZiB0aGUgbmF2aWdhdGlvbiBoYXMgdG8gdHJpZ2dlciBhIGJyb3dzZXIgbmF2aWdhdGlvbi5cbiAgICovXG4gIHB1c2hSZWY6IFB1c2hSZWZcbiAgLyoqXG4gICAqIERlY2lkZXMgaWYgdGhlIHVwZGF0ZSBzaG91bGQgYXBwbHkgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgKi9cbiAgZm9jdXNBbmRTY3JvbGxSZWY6IEZvY3VzQW5kU2Nyb2xsUmVmXG4gIC8qKlxuICAgKiBUaGUgY2Fub25pY2FsIHVybCB0aGF0IGlzIHB1c2hlZC9yZXBsYWNlZC5cbiAgICogLSBUaGlzIGlzIHRoZSB1cmwgeW91IHNlZSBpbiB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGNhbm9uaWNhbFVybDogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgdW5kZXJseWluZyBcInVybFwiIHJlcHJlc2VudGluZyB0aGUgVUkgc3RhdGUsIHdoaWNoIGlzIHVzZWQgZm9yIGludGVyY2VwdGluZyByb3V0ZXMuXG4gICAqL1xuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsXG59XG5cbmV4cG9ydCB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlID0gUmVhZG9ubHk8QXBwUm91dGVyU3RhdGU+XG5leHBvcnQgdHlwZSBSZWR1Y2VyU3RhdGUgPSBQcm9taXNlPEFwcFJvdXRlclN0YXRlPiB8IEFwcFJvdXRlclN0YXRlXG5leHBvcnQgdHlwZSBSZWR1Y2VyQWN0aW9ucyA9IFJlYWRvbmx5PFxuICB8IFJlZnJlc2hBY3Rpb25cbiAgfCBOYXZpZ2F0ZUFjdGlvblxuICB8IFJlc3RvcmVBY3Rpb25cbiAgfCBTZXJ2ZXJQYXRjaEFjdGlvblxuICB8IFByZWZldGNoQWN0aW9uXG4gIHwgSG1yUmVmcmVzaEFjdGlvblxuICB8IFNlcnZlckFjdGlvbkFjdGlvblxuPlxuIl0sIm5hbWVzIjpbIkFDVElPTl9ITVJfUkVGUkVTSCIsIkFDVElPTl9OQVZJR0FURSIsIkFDVElPTl9QUkVGRVRDSCIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fU0VSVkVSX0FDVElPTiIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMiLCJQcmVmZXRjaEtpbmQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"reducer\", ({\n    enumerable: true,\n    get: function() {\n        return reducer;\n    }\n}));\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _navigatereducer = __webpack_require__(/*! ./reducers/navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _serverpatchreducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\");\nconst _restorereducer = __webpack_require__(/*! ./reducers/restore-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\");\nconst _refreshreducer = __webpack_require__(/*! ./reducers/refresh-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _hmrrefreshreducer = __webpack_require__(/*! ./reducers/hmr-refresh-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\");\nconst _serveractionreducer = __webpack_require__(/*! ./reducers/server-action-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js\");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerreducertypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigatereducer.navigateReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverpatchreducer.serverPatchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_RESTORE:\n            {\n                return (0, _restorereducer.restoreReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_REFRESH:\n            {\n                return (0, _refreshreducer.refreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_HMR_REFRESH:\n            {\n                return (0, _hmrrefreshreducer.hmrRefreshReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchreducer.prefetchReducer)(state, action);\n            }\n        case _routerreducertypes.ACTION_SERVER_ACTION:\n            {\n                return (0, _serveractionreducer.serverActionReducer)(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw Object.defineProperty(new Error('Unknown action'), \"__NEXT_ERROR_CODE\", {\n                value: \"E295\",\n                enumerable: false,\n                configurable: true\n            });\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  false ? 0 : clientReducer;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0FpRWFBOzs7ZUFBQUE7OztnREF6RE47NkNBTXlCO2dEQUNHOzRDQUNKOzRDQUNBOzZDQUNDOytDQUNFO2lEQUNFO0FBRXBDOztDQUVDLEdBQ0QsU0FBU0MsY0FDUEMsS0FBMkIsRUFDM0JDLE1BQXNCO0lBRXRCLE9BQVFBLE9BQU9DLElBQUk7UUFDakIsS0FBS0Msb0JBQUFBLGVBQWU7WUFBRTtnQkFDcEIsT0FBT0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQWdCSixPQUFPQztZQUNoQztRQUNBLEtBQUtJLG9CQUFBQSxtQkFBbUI7WUFBRTtnQkFDeEIsT0FBT0MsQ0FBQUEsR0FBQUEsb0JBQUFBLGtCQUFBQSxFQUFtQk4sT0FBT0M7WUFDbkM7UUFDQSxLQUFLTSxvQkFBQUEsY0FBYztZQUFFO2dCQUNuQixPQUFPQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBQUEsRUFBZVIsT0FBT0M7WUFDL0I7UUFDQSxLQUFLUSxvQkFBQUEsY0FBYztZQUFFO2dCQUNuQixPQUFPQyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBQUEsRUFBZVYsT0FBT0M7WUFDL0I7UUFDQSxLQUFLVSxvQkFBQUEsa0JBQWtCO1lBQUU7Z0JBQ3ZCLE9BQU9DLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JaLE9BQU9DO1lBQ2xDO1FBQ0EsS0FBS1ksb0JBQUFBLGVBQWU7WUFBRTtnQkFDcEIsT0FBT0MsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQWdCZCxPQUFPQztZQUNoQztRQUNBLEtBQUtjLG9CQUFBQSxvQkFBb0I7WUFBRTtnQkFDekIsT0FBT0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFBQSxFQUFvQmhCLE9BQU9DO1lBQ3BDO1FBQ0EsK0RBQStEO1FBQy9EO1lBQ0UsTUFBTSxxQkFBMkIsQ0FBM0IsSUFBSWdCLE1BQU0sbUJBQVY7dUJBQUE7NEJBQUE7OEJBQUE7WUFBMEI7SUFDcEM7QUFDRjtBQUVBLFNBQVNDLGNBQ1BsQixLQUEyQixFQUMzQm1CLE9BQXVCO0lBRXZCLE9BQU9uQjtBQUNUO0FBR08sTUFBTUYsVUFDWCxNQUE2QixHQUFHb0IsQ0FBYUEsR0FBR25CIiwic291cmNlcyI6WyIvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFDVElPTl9OQVZJR0FURSxcbiAgQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgQUNUSU9OX1JFU1RPUkUsXG4gIEFDVElPTl9SRUZSRVNILFxuICBBQ1RJT05fUFJFRkVUQ0gsXG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgQUNUSU9OX1NFUlZFUl9BQ1RJT04sXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgdHlwZSB7XG4gIFJlZHVjZXJBY3Rpb25zLFxuICBSZWR1Y2VyU3RhdGUsXG4gIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgbmF2aWdhdGVSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyJ1xuaW1wb3J0IHsgc2VydmVyUGF0Y2hSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlcidcbmltcG9ydCB7IHJlc3RvcmVSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXInXG5pbXBvcnQgeyByZWZyZXNoUmVkdWNlciB9IGZyb20gJy4vcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgcHJlZmV0Y2hSZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyJ1xuaW1wb3J0IHsgaG1yUmVmcmVzaFJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXJzL2htci1yZWZyZXNoLXJlZHVjZXInXG5pbXBvcnQgeyBzZXJ2ZXJBY3Rpb25SZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9zZXJ2ZXItYWN0aW9uLXJlZHVjZXInXG5cbi8qKlxuICogUmVkdWNlciB0aGF0IGhhbmRsZXMgdGhlIGFwcC1yb3V0ZXIgc3RhdGUgdXBkYXRlcy5cbiAqL1xuZnVuY3Rpb24gY2xpZW50UmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBhY3Rpb246IFJlZHVjZXJBY3Rpb25zXG4pOiBSZWR1Y2VyU3RhdGUge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBBQ1RJT05fTkFWSUdBVEU6IHtcbiAgICAgIHJldHVybiBuYXZpZ2F0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fU0VSVkVSX1BBVENIOiB7XG4gICAgICByZXR1cm4gc2VydmVyUGF0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pXG4gICAgfVxuICAgIGNhc2UgQUNUSU9OX1JFU1RPUkU6IHtcbiAgICAgIHJldHVybiByZXN0b3JlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9SRUZSRVNIOiB7XG4gICAgICByZXR1cm4gcmVmcmVzaFJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICB9XG4gICAgY2FzZSBBQ1RJT05fSE1SX1JFRlJFU0g6IHtcbiAgICAgIHJldHVybiBobXJSZWZyZXNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9QUkVGRVRDSDoge1xuICAgICAgcmV0dXJuIHByZWZldGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICBjYXNlIEFDVElPTl9TRVJWRVJfQUNUSU9OOiB7XG4gICAgICByZXR1cm4gc2VydmVyQWN0aW9uUmVkdWNlcihzdGF0ZSwgYWN0aW9uKVxuICAgIH1cbiAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGJlIGhpdCBhcyBkaXNwYXRjaCBpcyBzdHJvbmdseSB0eXBlZC5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFjdGlvbicpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2VydmVyUmVkdWNlcihcbiAgc3RhdGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlLFxuICBfYWN0aW9uOiBSZWR1Y2VyQWN0aW9uc1xuKTogUmVkdWNlclN0YXRlIHtcbiAgcmV0dXJuIHN0YXRlXG59XG5cbi8vIHdlIGRvbid0IHJ1biB0aGUgY2xpZW50IHJlZHVjZXIgb24gdGhlIHNlcnZlciwgc28gd2UgdXNlIGEgbm9vcCBmdW5jdGlvbiBmb3IgYmV0dGVyIHRyZWUgc2hha2luZ1xuZXhwb3J0IGNvbnN0IHJlZHVjZXIgPVxuICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHNlcnZlclJlZHVjZXIgOiBjbGllbnRSZWR1Y2VyXG4iXSwibmFtZXMiOlsicmVkdWNlciIsImNsaWVudFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJBQ1RJT05fTkFWSUdBVEUiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwic2VydmVyUGF0Y2hSZWR1Y2VyIiwiQUNUSU9OX1JFU1RPUkUiLCJyZXN0b3JlUmVkdWNlciIsIkFDVElPTl9SRUZSRVNIIiwicmVmcmVzaFJlZHVjZXIiLCJBQ1RJT05fSE1SX1JFRlJFU0giLCJobXJSZWZyZXNoUmVkdWNlciIsIkFDVElPTl9QUkVGRVRDSCIsInByZWZldGNoUmVkdWNlciIsIkFDVElPTl9TRVJWRVJfQUNUSU9OIiwic2VydmVyQWN0aW9uUmVkdWNlciIsIkVycm9yIiwic2VydmVyUmVkdWNlciIsIl9hY3Rpb24iLCJ3aW5kb3ciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js ***!
  \***************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"setCacheBustingSearchParam\", ({\n    enumerable: true,\n    get: function() {\n        return setCacheBustingSearchParam;\n    }\n}));\nconst _hash = __webpack_require__(/*! ../../../shared/lib/hash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hash.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst setCacheBustingSearchParam = (url, headers)=>{\n    const uniqueCacheKey = (0, _hash.hexHash)([\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',\n        headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER],\n        headers[_approuterheaders.NEXT_URL]\n    ].join(','));\n    /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */ const existingSearch = url.search;\n    const rawQuery = existingSearch.startsWith('?') ? existingSearch.slice(1) : existingSearch;\n    const pairs = rawQuery.split('&').filter(Boolean);\n    pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + \"=\" + uniqueCacheKey);\n    url.search = pairs.length ? \"?\" + pairs.join('&') : '';\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=set-cache-busting-search-param.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2V0LWNhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OERBMkJhQTs7O2VBQUFBOzs7a0NBMUJXOzhDQU9qQjtBQW1CQSxNQUFNQSw2QkFBNkIsQ0FDeENDLEtBQ0FDO0lBRUEsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxNQUFBQSxPQUFBQSxFQUNyQjtRQUNFRixPQUFPLENBQUNHLGtCQUFBQSwyQkFBMkIsQ0FBQyxJQUFJO1FBQ3hDSCxPQUFPLENBQUNJLGtCQUFBQSxtQ0FBbUMsQ0FBQyxJQUFJO1FBQ2hESixPQUFPLENBQUNLLGtCQUFBQSw2QkFBNkIsQ0FBQztRQUN0Q0wsT0FBTyxDQUFDTSxrQkFBQUEsUUFBUSxDQUFDO0tBQ2xCLENBQUNDLElBQUksQ0FBQztJQUdUOzs7Ozs7Ozs7O0dBVUMsR0FDRCxNQUFNQyxpQkFBaUJULElBQUlVLE1BQU07SUFDakMsTUFBTUMsV0FBV0YsZUFBZUcsVUFBVSxDQUFDLE9BQ3ZDSCxlQUFlSSxLQUFLLENBQUMsS0FDckJKO0lBQ0osTUFBTUssUUFBUUgsU0FBU0ksS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0M7SUFDekNILE1BQU1JLElBQUksQ0FBSUMsa0JBQUFBLG9CQUFvQixHQUFDLE1BQUdqQjtJQUN0Q0YsSUFBSVUsTUFBTSxHQUFHSSxNQUFNTSxNQUFNLEdBQUksTUFBR04sTUFBTU4sSUFBSSxDQUFDLE9BQVM7QUFDdEQiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2V0LWNhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IHsgaGV4SGFzaCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvaGFzaCdcbmltcG9ydCB7XG4gIE5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVIsXG4gIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSLFxuICBORVhUX1VSTCxcbiAgTkVYVF9SU0NfVU5JT05fUVVFUlksXG59IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB0eXBlIHsgUmVxdWVzdEhlYWRlcnMgfSBmcm9tICcuL2ZldGNoLXNlcnZlci1yZXNwb25zZSdcblxuLyoqXG4gKiBNdXRhdGVzIHRoZSBwcm92aWRlZCBVUkwgYnkgYWRkaW5nIGEgY2FjaGUtYnVzdGluZyBzZWFyY2ggcGFyYW1ldGVyIGZvciBDRE5zIHRoYXQgZG9uJ3RcbiAqIHN1cHBvcnQgY3VzdG9tIGhlYWRlcnMuIFRoaXMgaGVscHMgYXZvaWQgY2FjaGluZyBjb25mbGljdHMgYnkgbWFraW5nIGVhY2ggcmVxdWVzdCB1bmlxdWUuXG4gKlxuICogUmF0aGVyIHRoYW4gcmVseWluZyBvbiB0aGUgVmFyeSBoZWFkZXIgd2hpY2ggc29tZSBDRE5zIGlnbm9yZSwgd2UgYXBwZW5kIGEgc2VhcmNoIHBhcmFtXG4gKiB0byBjcmVhdGUgYSB1bmlxdWUgVVJMIHRoYXQgZm9yY2VzIGEgZnJlc2ggcmVxdWVzdC5cbiAqXG4gKiBFeGFtcGxlOlxuICogVVJMIGJlZm9yZTogaHR0cHM6Ly9leGFtcGxlLmNvbS9wYXRoP3F1ZXJ5PTFcbiAqIFVSTCBhZnRlcjogaHR0cHM6Ly9leGFtcGxlLmNvbS9wYXRoP3F1ZXJ5PTEmX3JzYz1hYmMxMjNcbiAqXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIG11dGF0ZXMgdGhlIGlucHV0IFVSTCBkaXJlY3RseSBhbmQgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nLlxuICpcbiAqIFRPRE86IFNpbmNlIHdlIG5lZWQgdG8gdXNlIGEgc2VhcmNoIHBhcmFtIGFueXdheSwgd2UgY291bGQgc2ltcGxpZnkgYnkgcmVtb3ZpbmcgdGhlIGN1c3RvbVxuICogaGVhZGVycyBhcHByb2FjaCBlbnRpcmVseSBhbmQganVzdCB1c2Ugc2VhcmNoIHBhcmFtcy5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldENhY2hlQnVzdGluZ1NlYXJjaFBhcmFtID0gKFxuICB1cmw6IFVSTCxcbiAgaGVhZGVyczogUmVxdWVzdEhlYWRlcnNcbik6IHZvaWQgPT4ge1xuICBjb25zdCB1bmlxdWVDYWNoZUtleSA9IGhleEhhc2goXG4gICAgW1xuICAgICAgaGVhZGVyc1tORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdIHx8ICcwJyxcbiAgICAgIGhlYWRlcnNbTkVYVF9ST1VURVJfU0VHTUVOVF9QUkVGRVRDSF9IRUFERVJdIHx8ICcwJyxcbiAgICAgIGhlYWRlcnNbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdLFxuICAgICAgaGVhZGVyc1tORVhUX1VSTF0sXG4gICAgXS5qb2luKCcsJylcbiAgKVxuXG4gIC8qKlxuICAgKiBOb3RlIHRoYXQgd2UgaW50ZW50aW9uYWxseSBkbyBub3QgdXNlIGB1cmwuc2VhcmNoUGFyYW1zLnNldGAgaGVyZTpcbiAgICpcbiAgICogY29uc3QgdXJsID0gbmV3IFVSTCgnaHR0cHM6Ly9leGFtcGxlLmNvbS9zZWFyY2g/cT1jdXN0b20lMjBzcGFjaW5nJyk7XG4gICAqIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfcnNjJywgJ2FiYzEyMycpO1xuICAgKiBjb25zb2xlLmxvZyh1cmwudG9TdHJpbmcoKSk7IC8vIE91dHB1dHM6IGh0dHBzOi8vZXhhbXBsZS5jb20vc2VhcmNoP3E9Y3VzdG9tK3NwYWNpbmcmX3JzYz1hYmMxMjNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gPC0tLSB0aGlzIGlzIGNhdXNpbmcgY29uZnVzaW9uXG4gICAqIFRoaXMgaXMgaW4gZmFjdCBpbnRlbmRlZCBiYXNlZCBvbiBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS11cmxzZWFyY2hwYXJhbXMsIGJ1dFxuICAgKiB3ZSB3YW50IHRvIHByZXNlcnZlIHRoZSAlMjAgYXMgJTIwIGlmIHRoYXQncyB3aGF0IHRoZSB1c2VyIHBhc3NlZCBpbiwgaGVuY2UgdGhlIGN1c3RvbVxuICAgKiBsb2dpYyBiZWxvdy5cbiAgICovXG4gIGNvbnN0IGV4aXN0aW5nU2VhcmNoID0gdXJsLnNlYXJjaFxuICBjb25zdCByYXdRdWVyeSA9IGV4aXN0aW5nU2VhcmNoLnN0YXJ0c1dpdGgoJz8nKVxuICAgID8gZXhpc3RpbmdTZWFyY2guc2xpY2UoMSlcbiAgICA6IGV4aXN0aW5nU2VhcmNoXG4gIGNvbnN0IHBhaXJzID0gcmF3UXVlcnkuc3BsaXQoJyYnKS5maWx0ZXIoQm9vbGVhbilcbiAgcGFpcnMucHVzaChgJHtORVhUX1JTQ19VTklPTl9RVUVSWX09JHt1bmlxdWVDYWNoZUtleX1gKVxuICB1cmwuc2VhcmNoID0gcGFpcnMubGVuZ3RoID8gYD8ke3BhaXJzLmpvaW4oJyYnKX1gIDogJydcbn1cbiJdLCJuYW1lcyI6WyJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSIsInVybCIsImhlYWRlcnMiLCJ1bmlxdWVDYWNoZUtleSIsImhleEhhc2giLCJORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIiLCJORVhUX1JPVVRFUl9TRUdNRU5UX1BSRUZFVENIX0hFQURFUiIsIk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVfSEVBREVSIiwiTkVYVF9VUkwiLCJqb2luIiwiZXhpc3RpbmdTZWFyY2giLCJzZWFyY2giLCJyYXdRdWVyeSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInBhaXJzIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwicHVzaCIsIk5FWFRfUlNDX1VOSU9OX1FVRVJZIiwibGVuZ3RoIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"shouldHardNavigate\", ({\n    enumerable: true,\n    get: function() {\n        return shouldHardNavigate;\n    }\n}));\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _matchsegments = __webpack_require__(/*! ../match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchsegments.matchSegment)(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate((0, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2hvdWxkLWhhcmQtbmF2aWdhdGUuanMiLCJtYXBwaW5ncyI6Ijs7OztzREFTZ0JBOzs7ZUFBQUE7OzsrQ0FKeUI7MkNBQ1o7QUFHdEIsU0FBU0EsbUJBQ2RDLGlCQUFpQyxFQUNqQ0MsaUJBQW9DO0lBRXBDLE1BQU0sQ0FBQ0MsU0FBU0MsZUFBZSxHQUFHRjtJQUNsQywyQ0FBMkM7SUFDM0MsTUFBTSxDQUFDRyxnQkFBZ0JDLGlCQUFpQixHQUFHTDtJQUszQyx5REFBeUQ7SUFDekQsSUFBSSxDQUFDTSxDQUFBQSxHQUFBQSxlQUFBQSxZQUFBQSxFQUFhRixnQkFBZ0JGLFVBQVU7UUFDMUMsa0dBQWtHO1FBQ2xHLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ0osaUJBQWlCO1lBQ2pDLE9BQU87UUFDVDtRQUVBLHNFQUFzRTtRQUN0RSxPQUFPO0lBQ1Q7SUFDQSxNQUFNSyxjQUFjVCxrQkFBa0JVLE1BQU0sSUFBSTtJQUVoRCxJQUFJRCxhQUFhO1FBQ2YsT0FBTztJQUNUO0lBRUEsT0FBT1YsbUJBQ0xZLENBQUFBLEdBQUFBLG1CQUFBQSx3QkFBQUEsRUFBeUJYLG9CQUN6QkcsY0FBYyxDQUFDRSxpQkFBaUI7QUFFcEMiLCJzb3VyY2VzIjpbIi9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvc2hvdWxkLWhhcmQtbmF2aWdhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUge1xuICBGbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgRmxpZ2h0RGF0YVBhdGgsXG4gIFNlZ21lbnQsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgZ2V0TmV4dEZsaWdodFNlZ21lbnRQYXRoIH0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IG1hdGNoU2VnbWVudCB9IGZyb20gJy4uL21hdGNoLXNlZ21lbnRzJ1xuXG4vLyBUT0RPLUFQUDogZmxpZ2h0U2VnbWVudFBhdGggd2lsbCBiZSBlbXB0eSBpbiBjYXNlIG9mIHN0YXRpYyByZXNwb25zZSwgbmVlZHMgdG8gYmUgaGFuZGxlZC5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRIYXJkTmF2aWdhdGUoXG4gIGZsaWdodFNlZ21lbnRQYXRoOiBGbGlnaHREYXRhUGF0aCxcbiAgZmxpZ2h0Um91dGVyU3RhdGU6IEZsaWdodFJvdXRlclN0YXRlXG4pOiBib29sZWFuIHtcbiAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzXSA9IGZsaWdodFJvdXRlclN0YXRlXG4gIC8vIFRPRE8tQVBQOiBDaGVjayBpZiBgYXNgIGNhbiBiZSByZXBsYWNlZC5cbiAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoIGFzIFtcbiAgICBTZWdtZW50LFxuICAgIHN0cmluZyxcbiAgXVxuXG4gIC8vIENoZWNrIGlmIGN1cnJlbnQgc2VnbWVudCBtYXRjaGVzIHRoZSBleGlzdGluZyBzZWdtZW50LlxuICBpZiAoIW1hdGNoU2VnbWVudChjdXJyZW50U2VnbWVudCwgc2VnbWVudCkpIHtcbiAgICAvLyBJZiBkeW5hbWljIHBhcmFtZXRlciBpbiB0cmVlIGRvZXNuJ3QgbWF0Y2ggdXAgd2l0aCBzZWdtZW50IHBhdGggYSBoYXJkIG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTZWdtZW50KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZXhpc3Rpbmcgc2VnbWVudCBkaWQgbm90IG1hdGNoIHNvZnQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMlxuXG4gIGlmIChsYXN0U2VnbWVudCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHNob3VsZEhhcmROYXZpZ2F0ZShcbiAgICBnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgoZmxpZ2h0U2VnbWVudFBhdGgpLFxuICAgIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJzaG91bGRIYXJkTmF2aWdhdGUiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZsaWdodFJvdXRlclN0YXRlIiwic2VnbWVudCIsInBhcmFsbGVsUm91dGVzIiwiY3VycmVudFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwibWF0Y2hTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwibGFzdFNlZ21lbnQiLCJsZW5ndGgiLCJnZXROZXh0RmxpZ2h0U2VnbWVudFBhdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n"));

/***/ })

}]);