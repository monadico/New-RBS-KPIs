"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blueToYellow: () => (/* binding */ blueToYellow),\n/* harmony export */   buildCalendarMatrix: () => (/* binding */ buildCalendarMatrix),\n/* harmony export */   cn: () => (/* binding */ cn),\n/* harmony export */   daysOfWeek: () => (/* binding */ daysOfWeek),\n/* harmony export */   filterDataByDateRange: () => (/* binding */ filterDataByDateRange),\n/* harmony export */   formatAddress: () => (/* binding */ formatAddress),\n/* harmony export */   formatCurrency: () => (/* binding */ formatCurrency),\n/* harmony export */   formatDecimal: () => (/* binding */ formatDecimal),\n/* harmony export */   formatNumber: () => (/* binding */ formatNumber),\n/* harmony export */   getCardCountData: () => (/* binding */ getCardCountData),\n/* harmony export */   getFilteredCardCountData: () => (/* binding */ getFilteredCardCountData),\n/* harmony export */   getFilteredMetrics: () => (/* binding */ getFilteredMetrics),\n/* harmony export */   getFilteredTimeframeData: () => (/* binding */ getFilteredTimeframeData),\n/* harmony export */   getHeatmapColor: () => (/* binding */ getHeatmapColor),\n/* harmony export */   getTimeframeData: () => (/* binding */ getTimeframeData),\n/* harmony export */   jerryColorScale: () => (/* binding */ jerryColorScale)\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ \"(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n// Data formatting utilities (matching frontend2 logic)\nconst formatNumber = (num)=>{\n    if (num >= 1000000) {\n        return \"\".concat((num / 1000000).toFixed(1), \"M\");\n    } else if (num >= 1000) {\n        return \"\".concat((num / 1000).toFixed(1), \"K\");\n    }\n    return num.toLocaleString();\n};\nconst formatCurrency = (num)=>{\n    return \"$\".concat(num.toLocaleString());\n};\nconst formatDecimal = (num)=>{\n    return num.toFixed(1);\n};\nconst formatAddress = function(address) {\n    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;\n    return \"\".concat(address.substring(0, length), \"...\").concat(address.substring(address.length - length));\n};\n// Data processing utilities\nconst getTimeframeData = (data, selectedTimeframe)=>{\n    // Try new optimized structure first\n    if (data.timeframes && data.timeframes[selectedTimeframe]) {\n        return data.timeframes[selectedTimeframe].activity_over_time || data.activity_over_time;\n    }\n    // Fallback to legacy structure\n    switch(selectedTimeframe){\n        case 'daily':\n            var _data_daily_analytics;\n            return ((_data_daily_analytics = data.daily_analytics) === null || _data_daily_analytics === void 0 ? void 0 : _data_daily_analytics.activity_over_time) || data.activity_over_time;\n        case 'monthly':\n            var _data_monthly_analytics;\n            return ((_data_monthly_analytics = data.monthly_analytics) === null || _data_monthly_analytics === void 0 ? void 0 : _data_monthly_analytics.activity_over_time) || data.activity_over_time;\n        case 'weekly':\n        default:\n            var _data_weekly_analytics;\n            return ((_data_weekly_analytics = data.weekly_analytics) === null || _data_weekly_analytics === void 0 ? void 0 : _data_weekly_analytics.activity_over_time) || data.activity_over_time;\n    }\n};\nconst getCardCountData = (data, selectedTimeframe)=>{\n    // Try new optimized structure first\n    if (data.timeframes && data.timeframes[selectedTimeframe]) {\n        return data.timeframes[selectedTimeframe].slips_by_card_count || [];\n    }\n    // Fallback to legacy structure\n    switch(selectedTimeframe){\n        case 'daily':\n            return data.daily_slips_by_card_count || [];\n        case 'monthly':\n            return data.monthly_slips_by_card_count || [];\n        case 'weekly':\n        default:\n            return data.weekly_slips_by_card_count_new || data.weekly_slips_by_card_count || [];\n    }\n};\n// Filter data based on custom date range\nconst filterDataByDateRange = (data, startDate, endDate)=>{\n    if (!data || !Array.isArray(data)) return [];\n    // Convert dates to YYYY-MM-DD format for string comparison\n    const startDateStr = startDate.toISOString().split('T')[0];\n    const endDateStr = endDate.toISOString().split('T')[0];\n    return data.filter((item)=>{\n        if (!item.start_date) return false;\n        // Compare dates as strings (YYYY-MM-DD format)\n        const itemDateStr = item.start_date;\n        // Check if the date falls within the range (inclusive)\n        return itemDateStr >= startDateStr && itemDateStr <= endDateStr;\n    });\n};\n// Get filtered timeframe data based on selection and custom date range\nconst getFilteredTimeframeData = (data, selectedTimeframe, customStartDate, customEndDate, customRangeConfirmed)=>{\n    // Get the base timeframe data\n    let timeframeData = getTimeframeData(data, selectedTimeframe === \"custom\" ? customRangeConfirmed ? \"daily\" : \"weekly\" : selectedTimeframe);\n    // If custom timeframe is selected, confirmed, and we have date range, filter the data\n    if (selectedTimeframe === \"custom\" && customRangeConfirmed && customStartDate && customEndDate) {\n        timeframeData = filterDataByDateRange(timeframeData, customStartDate, customEndDate);\n    }\n    return timeframeData;\n};\n// Get filtered card count data based on selection and custom date range\nconst getFilteredCardCountData = (data, selectedTimeframe, customStartDate, customEndDate)=>{\n    // Get the base card count data\n    let cardCountData = getCardCountData(data, selectedTimeframe === \"custom\" ? \"daily\" : selectedTimeframe);\n    // If custom timeframe is selected and we have date range, filter the data\n    if (selectedTimeframe === \"custom\" && customStartDate && customEndDate) {\n        cardCountData = filterDataByDateRange(cardCountData, customStartDate, customEndDate);\n    }\n    return cardCountData;\n};\n// Calculate filtered totals for metrics when custom date range is selected\nconst getFilteredMetrics = (data, selectedTimeframe, customStartDate, customEndDate, customRangeConfirmed)=>{\n    if (selectedTimeframe !== \"custom\" || !customStartDate || !customEndDate || !customRangeConfirmed) {\n        var _data_total_metrics, _data_total_metrics1, _data_total_metrics2, _data_total_metrics3, _data_average_metrics, _data_average_metrics1;\n        // Return original metrics for non-custom timeframes or unconfirmed custom\n        return {\n            total_submissions: ((_data_total_metrics = data.total_metrics) === null || _data_total_metrics === void 0 ? void 0 : _data_total_metrics.total_submissions) || 0,\n            total_active_addresses: ((_data_total_metrics1 = data.total_metrics) === null || _data_total_metrics1 === void 0 ? void 0 : _data_total_metrics1.total_active_addresses) || 0,\n            total_mon_volume: ((_data_total_metrics2 = data.total_metrics) === null || _data_total_metrics2 === void 0 ? void 0 : _data_total_metrics2.total_mon_volume) || 0,\n            total_jerry_volume: ((_data_total_metrics3 = data.total_metrics) === null || _data_total_metrics3 === void 0 ? void 0 : _data_total_metrics3.total_jerry_volume) || 0,\n            avg_submissions_per_day: ((_data_average_metrics = data.average_metrics) === null || _data_average_metrics === void 0 ? void 0 : _data_average_metrics.avg_submissions_per_day) || 0,\n            avg_cards_per_slip: ((_data_average_metrics1 = data.average_metrics) === null || _data_average_metrics1 === void 0 ? void 0 : _data_average_metrics1.avg_cards_per_slip) || 0\n        };\n    }\n    // Get filtered data for custom timeframe\n    const filteredData = getFilteredTimeframeData(data, selectedTimeframe, customStartDate, customEndDate, customRangeConfirmed);\n    if (!filteredData || filteredData.length === 0) {\n        return {\n            total_submissions: 0,\n            total_active_addresses: 0,\n            total_mon_volume: 0,\n            total_jerry_volume: 0,\n            avg_submissions_per_day: 0,\n            avg_cards_per_slip: 0\n        };\n    }\n    // Calculate totals from filtered data\n    const totals = filteredData.reduce((acc, period)=>{\n        acc.total_submissions += period.submissions || 0;\n        acc.total_mon_volume += period.mon_volume || 0;\n        acc.total_jerry_volume += period.jerry_volume || 0;\n        return acc;\n    }, {\n        total_submissions: 0,\n        total_mon_volume: 0,\n        total_jerry_volume: 0\n    });\n    // Calculate unique active addresses from filtered data\n    const uniqueAddresses = new Set();\n    filteredData.forEach((period)=>{\n        if (period.active_addresses) {\n            // This is a simplified approach - in reality, we'd need to track individual addresses\n            // For now, we'll use the max active addresses from the filtered period\n            uniqueAddresses.add(period.active_addresses);\n        }\n    });\n    const total_active_addresses = Math.max(...Array.from(uniqueAddresses), 0);\n    // Calculate averages\n    const avg_submissions_per_day = filteredData.length > 0 ? totals.total_submissions / filteredData.length : 0;\n    // Calculate average cards per slip from filtered data\n    const totalCards = filteredData.reduce((sum, period)=>sum + (period.total_cards || 0), 0);\n    const avg_cards_per_slip = totals.total_submissions > 0 ? totalCards / totals.total_submissions : 0;\n    return {\n        total_submissions: totals.total_submissions,\n        total_active_addresses,\n        total_mon_volume: totals.total_mon_volume,\n        total_jerry_volume: totals.total_jerry_volume,\n        avg_submissions_per_day,\n        avg_cards_per_slip\n    };\n};\n// Heatmap utilities\nconst daysOfWeek = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\"\n];\nconst buildCalendarMatrix = (dailyData, valueKey)=>{\n    // Implementation for calendar heatmap matrix\n    // This would be implemented based on the frontend2 logic\n    return [];\n};\n// Color scale utilities\nconst blueToYellow = (t)=>{\n    const c1 = [\n        99,\n        102,\n        241\n    ] // blue\n    ;\n    const c2 = [\n        245,\n        158,\n        11\n    ] // yellow\n    ;\n    const rgb = c1.map((c, i)=>Math.round(c + (c2[i] - c) * t));\n    return \"rgb(\".concat(rgb[0], \",\").concat(rgb[1], \",\").concat(rgb[2], \")\");\n};\nconst jerryColorScale = (t)=>{\n    if (t === 0) return '#f3f4f6';\n    if (t < 0.1) return '#dbeafe';\n    if (t < 0.3) return '#93c5fd';\n    if (t < 0.6) return '#3b82f6';\n    if (t < 0.8) return '#1d4ed8';\n    return '#1e40af';\n};\nconst getHeatmapColor = function(value, maxValue) {\n    let colorType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"blue-yellow\";\n    if (maxValue === 0) return '#f3f4f6';\n    const ratio = value / maxValue;\n    if (colorType === \"green-red\") {\n        // Green to red scale\n        if (ratio === 0) return '#f3f4f6';\n        if (ratio < 0.1) return '#dcfce7';\n        if (ratio < 0.3) return '#86efac';\n        if (ratio < 0.6) return '#22c55e';\n        if (ratio < 0.8) return '#15803d';\n        return '#166534';\n    }\n    // Default blue-yellow scale\n    return jerryColorScale(ratio);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dC9saWIvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBDbGFzc1ZhbHVlLCBjbHN4IH0gZnJvbSBcImNsc3hcIlxuaW1wb3J0IHsgdHdNZXJnZSB9IGZyb20gXCJ0YWlsd2luZC1tZXJnZVwiXG5cbmV4cG9ydCBmdW5jdGlvbiBjbiguLi5pbnB1dHM6IENsYXNzVmFsdWVbXSkge1xuICByZXR1cm4gdHdNZXJnZShjbHN4KGlucHV0cykpXG59XG5cbi8vIERhdGEgZm9ybWF0dGluZyB1dGlsaXRpZXMgKG1hdGNoaW5nIGZyb250ZW5kMiBsb2dpYylcbmV4cG9ydCBjb25zdCBmb3JtYXROdW1iZXIgPSAobnVtOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBpZiAobnVtID49IDEwMDAwMDApIHtcbiAgICByZXR1cm4gYCR7KG51bSAvIDEwMDAwMDApLnRvRml4ZWQoMSl9TWBcbiAgfSBlbHNlIGlmIChudW0gPj0gMTAwMCkge1xuICAgIHJldHVybiBgJHsobnVtIC8gMTAwMCkudG9GaXhlZCgxKX1LYFxuICB9XG4gIHJldHVybiBudW0udG9Mb2NhbGVTdHJpbmcoKVxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0Q3VycmVuY3kgPSAobnVtOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gYCQke251bS50b0xvY2FsZVN0cmluZygpfWBcbn1cblxuZXhwb3J0IGNvbnN0IGZvcm1hdERlY2ltYWwgPSAobnVtOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gbnVtLnRvRml4ZWQoMSlcbn1cblxuZXhwb3J0IGNvbnN0IGZvcm1hdEFkZHJlc3MgPSAoYWRkcmVzczogc3RyaW5nLCBsZW5ndGggPSA2KTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIGAke2FkZHJlc3Muc3Vic3RyaW5nKDAsIGxlbmd0aCl9Li4uJHthZGRyZXNzLnN1YnN0cmluZyhhZGRyZXNzLmxlbmd0aCAtIGxlbmd0aCl9YFxufVxuXG4vLyBEYXRhIHByb2Nlc3NpbmcgdXRpbGl0aWVzXG5leHBvcnQgY29uc3QgZ2V0VGltZWZyYW1lRGF0YSA9IChkYXRhOiBhbnksIHNlbGVjdGVkVGltZWZyYW1lOiBzdHJpbmcpID0+IHtcbiAgLy8gVHJ5IG5ldyBvcHRpbWl6ZWQgc3RydWN0dXJlIGZpcnN0XG4gIGlmIChkYXRhLnRpbWVmcmFtZXMgJiYgZGF0YS50aW1lZnJhbWVzW3NlbGVjdGVkVGltZWZyYW1lXSkge1xuICAgIHJldHVybiBkYXRhLnRpbWVmcmFtZXNbc2VsZWN0ZWRUaW1lZnJhbWVdLmFjdGl2aXR5X292ZXJfdGltZSB8fCBkYXRhLmFjdGl2aXR5X292ZXJfdGltZVxuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBsZWdhY3kgc3RydWN0dXJlXG4gIHN3aXRjaCAoc2VsZWN0ZWRUaW1lZnJhbWUpIHtcbiAgICBjYXNlICdkYWlseSc6XG4gICAgICByZXR1cm4gZGF0YS5kYWlseV9hbmFseXRpY3M/LmFjdGl2aXR5X292ZXJfdGltZSB8fCBkYXRhLmFjdGl2aXR5X292ZXJfdGltZVxuICAgIGNhc2UgJ21vbnRobHknOlxuICAgICAgcmV0dXJuIGRhdGEubW9udGhseV9hbmFseXRpY3M/LmFjdGl2aXR5X292ZXJfdGltZSB8fCBkYXRhLmFjdGl2aXR5X292ZXJfdGltZVxuICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRhLndlZWtseV9hbmFseXRpY3M/LmFjdGl2aXR5X292ZXJfdGltZSB8fCBkYXRhLmFjdGl2aXR5X292ZXJfdGltZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDYXJkQ291bnREYXRhID0gKGRhdGE6IGFueSwgc2VsZWN0ZWRUaW1lZnJhbWU6IHN0cmluZykgPT4ge1xuICAvLyBUcnkgbmV3IG9wdGltaXplZCBzdHJ1Y3R1cmUgZmlyc3RcbiAgaWYgKGRhdGEudGltZWZyYW1lcyAmJiBkYXRhLnRpbWVmcmFtZXNbc2VsZWN0ZWRUaW1lZnJhbWVdKSB7XG4gICAgcmV0dXJuIGRhdGEudGltZWZyYW1lc1tzZWxlY3RlZFRpbWVmcmFtZV0uc2xpcHNfYnlfY2FyZF9jb3VudCB8fCBbXVxuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBsZWdhY3kgc3RydWN0dXJlXG4gIHN3aXRjaCAoc2VsZWN0ZWRUaW1lZnJhbWUpIHtcbiAgICBjYXNlICdkYWlseSc6XG4gICAgICByZXR1cm4gZGF0YS5kYWlseV9zbGlwc19ieV9jYXJkX2NvdW50IHx8IFtdXG4gICAgY2FzZSAnbW9udGhseSc6XG4gICAgICByZXR1cm4gZGF0YS5tb250aGx5X3NsaXBzX2J5X2NhcmRfY291bnQgfHwgW11cbiAgICBjYXNlICd3ZWVrbHknOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZGF0YS53ZWVrbHlfc2xpcHNfYnlfY2FyZF9jb3VudF9uZXcgfHwgZGF0YS53ZWVrbHlfc2xpcHNfYnlfY2FyZF9jb3VudCB8fCBbXVxuICB9XG59XG5cbi8vIEZpbHRlciBkYXRhIGJhc2VkIG9uIGN1c3RvbSBkYXRlIHJhbmdlXG5leHBvcnQgY29uc3QgZmlsdGVyRGF0YUJ5RGF0ZVJhbmdlID0gKGRhdGE6IGFueVtdLCBzdGFydERhdGU6IERhdGUsIGVuZERhdGU6IERhdGUpID0+IHtcbiAgaWYgKCFkYXRhIHx8ICFBcnJheS5pc0FycmF5KGRhdGEpKSByZXR1cm4gW11cbiAgXG4gIC8vIENvbnZlcnQgZGF0ZXMgdG8gWVlZWS1NTS1ERCBmb3JtYXQgZm9yIHN0cmluZyBjb21wYXJpc29uXG4gIGNvbnN0IHN0YXJ0RGF0ZVN0ciA9IHN0YXJ0RGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgY29uc3QgZW5kRGF0ZVN0ciA9IGVuZERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gIFxuICByZXR1cm4gZGF0YS5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICBpZiAoIWl0ZW0uc3RhcnRfZGF0ZSkgcmV0dXJuIGZhbHNlXG4gICAgXG4gICAgLy8gQ29tcGFyZSBkYXRlcyBhcyBzdHJpbmdzIChZWVlZLU1NLUREIGZvcm1hdClcbiAgICBjb25zdCBpdGVtRGF0ZVN0ciA9IGl0ZW0uc3RhcnRfZGF0ZVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSBkYXRlIGZhbGxzIHdpdGhpbiB0aGUgcmFuZ2UgKGluY2x1c2l2ZSlcbiAgICByZXR1cm4gaXRlbURhdGVTdHIgPj0gc3RhcnREYXRlU3RyICYmIGl0ZW1EYXRlU3RyIDw9IGVuZERhdGVTdHJcbiAgfSlcbn1cblxuLy8gR2V0IGZpbHRlcmVkIHRpbWVmcmFtZSBkYXRhIGJhc2VkIG9uIHNlbGVjdGlvbiBhbmQgY3VzdG9tIGRhdGUgcmFuZ2VcbmV4cG9ydCBjb25zdCBnZXRGaWx0ZXJlZFRpbWVmcmFtZURhdGEgPSAoXG4gIGRhdGE6IGFueSwgXG4gIHNlbGVjdGVkVGltZWZyYW1lOiBzdHJpbmcsIFxuICBjdXN0b21TdGFydERhdGU/OiBEYXRlLCBcbiAgY3VzdG9tRW5kRGF0ZT86IERhdGUsXG4gIGN1c3RvbVJhbmdlQ29uZmlybWVkPzogYm9vbGVhblxuKSA9PiB7XG4gIC8vIEdldCB0aGUgYmFzZSB0aW1lZnJhbWUgZGF0YVxuICBsZXQgdGltZWZyYW1lRGF0YSA9IGdldFRpbWVmcmFtZURhdGEoZGF0YSwgc2VsZWN0ZWRUaW1lZnJhbWUgPT09IFwiY3VzdG9tXCIgPyAoY3VzdG9tUmFuZ2VDb25maXJtZWQgPyBcImRhaWx5XCIgOiBcIndlZWtseVwiKSA6IHNlbGVjdGVkVGltZWZyYW1lKVxuICBcbiAgLy8gSWYgY3VzdG9tIHRpbWVmcmFtZSBpcyBzZWxlY3RlZCwgY29uZmlybWVkLCBhbmQgd2UgaGF2ZSBkYXRlIHJhbmdlLCBmaWx0ZXIgdGhlIGRhdGFcbiAgaWYgKHNlbGVjdGVkVGltZWZyYW1lID09PSBcImN1c3RvbVwiICYmIGN1c3RvbVJhbmdlQ29uZmlybWVkICYmIGN1c3RvbVN0YXJ0RGF0ZSAmJiBjdXN0b21FbmREYXRlKSB7XG4gICAgdGltZWZyYW1lRGF0YSA9IGZpbHRlckRhdGFCeURhdGVSYW5nZSh0aW1lZnJhbWVEYXRhLCBjdXN0b21TdGFydERhdGUsIGN1c3RvbUVuZERhdGUpXG4gIH1cbiAgXG4gIHJldHVybiB0aW1lZnJhbWVEYXRhXG59XG5cbi8vIEdldCBmaWx0ZXJlZCBjYXJkIGNvdW50IGRhdGEgYmFzZWQgb24gc2VsZWN0aW9uIGFuZCBjdXN0b20gZGF0ZSByYW5nZVxuZXhwb3J0IGNvbnN0IGdldEZpbHRlcmVkQ2FyZENvdW50RGF0YSA9IChcbiAgZGF0YTogYW55LCBcbiAgc2VsZWN0ZWRUaW1lZnJhbWU6IHN0cmluZywgXG4gIGN1c3RvbVN0YXJ0RGF0ZT86IERhdGUsIFxuICBjdXN0b21FbmREYXRlPzogRGF0ZVxuKSA9PiB7XG4gIC8vIEdldCB0aGUgYmFzZSBjYXJkIGNvdW50IGRhdGFcbiAgbGV0IGNhcmRDb3VudERhdGEgPSBnZXRDYXJkQ291bnREYXRhKGRhdGEsIHNlbGVjdGVkVGltZWZyYW1lID09PSBcImN1c3RvbVwiID8gXCJkYWlseVwiIDogc2VsZWN0ZWRUaW1lZnJhbWUpXG4gIFxuICAvLyBJZiBjdXN0b20gdGltZWZyYW1lIGlzIHNlbGVjdGVkIGFuZCB3ZSBoYXZlIGRhdGUgcmFuZ2UsIGZpbHRlciB0aGUgZGF0YVxuICBpZiAoc2VsZWN0ZWRUaW1lZnJhbWUgPT09IFwiY3VzdG9tXCIgJiYgY3VzdG9tU3RhcnREYXRlICYmIGN1c3RvbUVuZERhdGUpIHtcbiAgICBjYXJkQ291bnREYXRhID0gZmlsdGVyRGF0YUJ5RGF0ZVJhbmdlKGNhcmRDb3VudERhdGEsIGN1c3RvbVN0YXJ0RGF0ZSwgY3VzdG9tRW5kRGF0ZSlcbiAgfVxuICBcbiAgcmV0dXJuIGNhcmRDb3VudERhdGFcbn1cblxuLy8gQ2FsY3VsYXRlIGZpbHRlcmVkIHRvdGFscyBmb3IgbWV0cmljcyB3aGVuIGN1c3RvbSBkYXRlIHJhbmdlIGlzIHNlbGVjdGVkXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVyZWRNZXRyaWNzID0gKFxuICBkYXRhOiBhbnksXG4gIHNlbGVjdGVkVGltZWZyYW1lOiBzdHJpbmcsXG4gIGN1c3RvbVN0YXJ0RGF0ZT86IERhdGUsXG4gIGN1c3RvbUVuZERhdGU/OiBEYXRlLFxuICBjdXN0b21SYW5nZUNvbmZpcm1lZD86IGJvb2xlYW5cbikgPT4ge1xuICBpZiAoc2VsZWN0ZWRUaW1lZnJhbWUgIT09IFwiY3VzdG9tXCIgfHwgIWN1c3RvbVN0YXJ0RGF0ZSB8fCAhY3VzdG9tRW5kRGF0ZSB8fCAhY3VzdG9tUmFuZ2VDb25maXJtZWQpIHtcbiAgICAvLyBSZXR1cm4gb3JpZ2luYWwgbWV0cmljcyBmb3Igbm9uLWN1c3RvbSB0aW1lZnJhbWVzIG9yIHVuY29uZmlybWVkIGN1c3RvbVxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbF9zdWJtaXNzaW9uczogZGF0YS50b3RhbF9tZXRyaWNzPy50b3RhbF9zdWJtaXNzaW9ucyB8fCAwLFxuICAgICAgdG90YWxfYWN0aXZlX2FkZHJlc3NlczogZGF0YS50b3RhbF9tZXRyaWNzPy50b3RhbF9hY3RpdmVfYWRkcmVzc2VzIHx8IDAsXG4gICAgICB0b3RhbF9tb25fdm9sdW1lOiBkYXRhLnRvdGFsX21ldHJpY3M/LnRvdGFsX21vbl92b2x1bWUgfHwgMCxcbiAgICAgIHRvdGFsX2plcnJ5X3ZvbHVtZTogZGF0YS50b3RhbF9tZXRyaWNzPy50b3RhbF9qZXJyeV92b2x1bWUgfHwgMCxcbiAgICAgIGF2Z19zdWJtaXNzaW9uc19wZXJfZGF5OiBkYXRhLmF2ZXJhZ2VfbWV0cmljcz8uYXZnX3N1Ym1pc3Npb25zX3Blcl9kYXkgfHwgMCxcbiAgICAgIGF2Z19jYXJkc19wZXJfc2xpcDogZGF0YS5hdmVyYWdlX21ldHJpY3M/LmF2Z19jYXJkc19wZXJfc2xpcCB8fCAwXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGZpbHRlcmVkIGRhdGEgZm9yIGN1c3RvbSB0aW1lZnJhbWVcbiAgY29uc3QgZmlsdGVyZWREYXRhID0gZ2V0RmlsdGVyZWRUaW1lZnJhbWVEYXRhKGRhdGEsIHNlbGVjdGVkVGltZWZyYW1lLCBjdXN0b21TdGFydERhdGUsIGN1c3RvbUVuZERhdGUsIGN1c3RvbVJhbmdlQ29uZmlybWVkKVxuICBcbiAgaWYgKCFmaWx0ZXJlZERhdGEgfHwgZmlsdGVyZWREYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbF9zdWJtaXNzaW9uczogMCxcbiAgICAgIHRvdGFsX2FjdGl2ZV9hZGRyZXNzZXM6IDAsXG4gICAgICB0b3RhbF9tb25fdm9sdW1lOiAwLFxuICAgICAgdG90YWxfamVycnlfdm9sdW1lOiAwLFxuICAgICAgYXZnX3N1Ym1pc3Npb25zX3Blcl9kYXk6IDAsXG4gICAgICBhdmdfY2FyZHNfcGVyX3NsaXA6IDBcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdG90YWxzIGZyb20gZmlsdGVyZWQgZGF0YVxuICBjb25zdCB0b3RhbHMgPSBmaWx0ZXJlZERhdGEucmVkdWNlKChhY2M6IGFueSwgcGVyaW9kOiBhbnkpID0+IHtcbiAgICBhY2MudG90YWxfc3VibWlzc2lvbnMgKz0gcGVyaW9kLnN1Ym1pc3Npb25zIHx8IDBcbiAgICBhY2MudG90YWxfbW9uX3ZvbHVtZSArPSBwZXJpb2QubW9uX3ZvbHVtZSB8fCAwXG4gICAgYWNjLnRvdGFsX2plcnJ5X3ZvbHVtZSArPSBwZXJpb2QuamVycnlfdm9sdW1lIHx8IDBcbiAgICByZXR1cm4gYWNjXG4gIH0sIHtcbiAgICB0b3RhbF9zdWJtaXNzaW9uczogMCxcbiAgICB0b3RhbF9tb25fdm9sdW1lOiAwLFxuICAgIHRvdGFsX2plcnJ5X3ZvbHVtZTogMFxuICB9KVxuXG4gIC8vIENhbGN1bGF0ZSB1bmlxdWUgYWN0aXZlIGFkZHJlc3NlcyBmcm9tIGZpbHRlcmVkIGRhdGFcbiAgY29uc3QgdW5pcXVlQWRkcmVzc2VzID0gbmV3IFNldDxudW1iZXI+KClcbiAgZmlsdGVyZWREYXRhLmZvckVhY2goKHBlcmlvZDogYW55KSA9PiB7XG4gICAgaWYgKHBlcmlvZC5hY3RpdmVfYWRkcmVzc2VzKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBhcHByb2FjaCAtIGluIHJlYWxpdHksIHdlJ2QgbmVlZCB0byB0cmFjayBpbmRpdmlkdWFsIGFkZHJlc3Nlc1xuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdXNlIHRoZSBtYXggYWN0aXZlIGFkZHJlc3NlcyBmcm9tIHRoZSBmaWx0ZXJlZCBwZXJpb2RcbiAgICAgIHVuaXF1ZUFkZHJlc3Nlcy5hZGQocGVyaW9kLmFjdGl2ZV9hZGRyZXNzZXMpXG4gICAgfVxuICB9KVxuICBjb25zdCB0b3RhbF9hY3RpdmVfYWRkcmVzc2VzID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbSh1bmlxdWVBZGRyZXNzZXMpIGFzIG51bWJlcltdLCAwKVxuXG4gIC8vIENhbGN1bGF0ZSBhdmVyYWdlc1xuICBjb25zdCBhdmdfc3VibWlzc2lvbnNfcGVyX2RheSA9IGZpbHRlcmVkRGF0YS5sZW5ndGggPiAwID8gdG90YWxzLnRvdGFsX3N1Ym1pc3Npb25zIC8gZmlsdGVyZWREYXRhLmxlbmd0aCA6IDBcbiAgXG4gIC8vIENhbGN1bGF0ZSBhdmVyYWdlIGNhcmRzIHBlciBzbGlwIGZyb20gZmlsdGVyZWQgZGF0YVxuICBjb25zdCB0b3RhbENhcmRzID0gZmlsdGVyZWREYXRhLnJlZHVjZSgoc3VtOiBudW1iZXIsIHBlcmlvZDogYW55KSA9PiBzdW0gKyAocGVyaW9kLnRvdGFsX2NhcmRzIHx8IDApLCAwKVxuICBjb25zdCBhdmdfY2FyZHNfcGVyX3NsaXAgPSB0b3RhbHMudG90YWxfc3VibWlzc2lvbnMgPiAwID8gdG90YWxDYXJkcyAvIHRvdGFscy50b3RhbF9zdWJtaXNzaW9ucyA6IDBcblxuICByZXR1cm4ge1xuICAgIHRvdGFsX3N1Ym1pc3Npb25zOiB0b3RhbHMudG90YWxfc3VibWlzc2lvbnMsXG4gICAgdG90YWxfYWN0aXZlX2FkZHJlc3NlcyxcbiAgICB0b3RhbF9tb25fdm9sdW1lOiB0b3RhbHMudG90YWxfbW9uX3ZvbHVtZSxcbiAgICB0b3RhbF9qZXJyeV92b2x1bWU6IHRvdGFscy50b3RhbF9qZXJyeV92b2x1bWUsXG4gICAgYXZnX3N1Ym1pc3Npb25zX3Blcl9kYXksXG4gICAgYXZnX2NhcmRzX3Blcl9zbGlwXG4gIH1cbn1cblxuLy8gSGVhdG1hcCB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBkYXlzT2ZXZWVrID0gW1wiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiwgXCJTdW5kYXlcIl1cblxuZXhwb3J0IGNvbnN0IGJ1aWxkQ2FsZW5kYXJNYXRyaXggPSAoXG4gIGRhaWx5RGF0YTogYW55W10sXG4gIHZhbHVlS2V5OiBrZXlvZiBhbnlcbik6IGFueVtdW10gPT4ge1xuICAvLyBJbXBsZW1lbnRhdGlvbiBmb3IgY2FsZW5kYXIgaGVhdG1hcCBtYXRyaXhcbiAgLy8gVGhpcyB3b3VsZCBiZSBpbXBsZW1lbnRlZCBiYXNlZCBvbiB0aGUgZnJvbnRlbmQyIGxvZ2ljXG4gIHJldHVybiBbXVxufVxuXG4vLyBDb2xvciBzY2FsZSB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBibHVlVG9ZZWxsb3cgPSAodDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IGMxID0gWzk5LCAxMDIsIDI0MV0gLy8gYmx1ZVxuICBjb25zdCBjMiA9IFsyNDUsIDE1OCwgMTFdIC8vIHllbGxvd1xuICBjb25zdCByZ2IgPSBjMS5tYXAoKGMsIGkpID0+IE1hdGgucm91bmQoYyArIChjMltpXSAtIGMpICogdCkpXG4gIHJldHVybiBgcmdiKCR7cmdiWzBdfSwke3JnYlsxXX0sJHtyZ2JbMl19KWBcbn1cblxuZXhwb3J0IGNvbnN0IGplcnJ5Q29sb3JTY2FsZSA9ICh0OiBudW1iZXIpID0+IHtcbiAgaWYgKHQgPT09IDApIHJldHVybiAnI2YzZjRmNidcbiAgaWYgKHQgPCAwLjEpIHJldHVybiAnI2RiZWFmZSdcbiAgaWYgKHQgPCAwLjMpIHJldHVybiAnIzkzYzVmZCdcbiAgaWYgKHQgPCAwLjYpIHJldHVybiAnIzNiODJmNidcbiAgaWYgKHQgPCAwLjgpIHJldHVybiAnIzFkNGVkOCdcbiAgcmV0dXJuICcjMWU0MGFmJ1xufVxuXG5leHBvcnQgY29uc3QgZ2V0SGVhdG1hcENvbG9yID0gKHZhbHVlOiBudW1iZXIsIG1heFZhbHVlOiBudW1iZXIsIGNvbG9yVHlwZTogXCJibHVlLXllbGxvd1wiIHwgXCJncmVlbi1yZWRcIiA9IFwiYmx1ZS15ZWxsb3dcIik6IHN0cmluZyA9PiB7XG4gIGlmIChtYXhWYWx1ZSA9PT0gMCkgcmV0dXJuICcjZjNmNGY2J1xuICBjb25zdCByYXRpbyA9IHZhbHVlIC8gbWF4VmFsdWVcbiAgXG4gIGlmIChjb2xvclR5cGUgPT09IFwiZ3JlZW4tcmVkXCIpIHtcbiAgICAvLyBHcmVlbiB0byByZWQgc2NhbGVcbiAgICBpZiAocmF0aW8gPT09IDApIHJldHVybiAnI2YzZjRmNidcbiAgICBpZiAocmF0aW8gPCAwLjEpIHJldHVybiAnI2RjZmNlNydcbiAgICBpZiAocmF0aW8gPCAwLjMpIHJldHVybiAnIzg2ZWZhYydcbiAgICBpZiAocmF0aW8gPCAwLjYpIHJldHVybiAnIzIyYzU1ZSdcbiAgICBpZiAocmF0aW8gPCAwLjgpIHJldHVybiAnIzE1ODAzZCdcbiAgICByZXR1cm4gJyMxNjY1MzQnXG4gIH1cbiAgXG4gIC8vIERlZmF1bHQgYmx1ZS15ZWxsb3cgc2NhbGVcbiAgcmV0dXJuIGplcnJ5Q29sb3JTY2FsZShyYXRpbylcbn1cbiJdLCJuYW1lcyI6WyJjbHN4IiwidHdNZXJnZSIsImNuIiwiaW5wdXRzIiwiZm9ybWF0TnVtYmVyIiwibnVtIiwidG9GaXhlZCIsInRvTG9jYWxlU3RyaW5nIiwiZm9ybWF0Q3VycmVuY3kiLCJmb3JtYXREZWNpbWFsIiwiZm9ybWF0QWRkcmVzcyIsImFkZHJlc3MiLCJsZW5ndGgiLCJzdWJzdHJpbmciLCJnZXRUaW1lZnJhbWVEYXRhIiwiZGF0YSIsInNlbGVjdGVkVGltZWZyYW1lIiwidGltZWZyYW1lcyIsImFjdGl2aXR5X292ZXJfdGltZSIsImRhaWx5X2FuYWx5dGljcyIsIm1vbnRobHlfYW5hbHl0aWNzIiwid2Vla2x5X2FuYWx5dGljcyIsImdldENhcmRDb3VudERhdGEiLCJzbGlwc19ieV9jYXJkX2NvdW50IiwiZGFpbHlfc2xpcHNfYnlfY2FyZF9jb3VudCIsIm1vbnRobHlfc2xpcHNfYnlfY2FyZF9jb3VudCIsIndlZWtseV9zbGlwc19ieV9jYXJkX2NvdW50X25ldyIsIndlZWtseV9zbGlwc19ieV9jYXJkX2NvdW50IiwiZmlsdGVyRGF0YUJ5RGF0ZVJhbmdlIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsIkFycmF5IiwiaXNBcnJheSIsInN0YXJ0RGF0ZVN0ciIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJlbmREYXRlU3RyIiwiZmlsdGVyIiwiaXRlbSIsInN0YXJ0X2RhdGUiLCJpdGVtRGF0ZVN0ciIsImdldEZpbHRlcmVkVGltZWZyYW1lRGF0YSIsImN1c3RvbVN0YXJ0RGF0ZSIsImN1c3RvbUVuZERhdGUiLCJjdXN0b21SYW5nZUNvbmZpcm1lZCIsInRpbWVmcmFtZURhdGEiLCJnZXRGaWx0ZXJlZENhcmRDb3VudERhdGEiLCJjYXJkQ291bnREYXRhIiwiZ2V0RmlsdGVyZWRNZXRyaWNzIiwidG90YWxfc3VibWlzc2lvbnMiLCJ0b3RhbF9tZXRyaWNzIiwidG90YWxfYWN0aXZlX2FkZHJlc3NlcyIsInRvdGFsX21vbl92b2x1bWUiLCJ0b3RhbF9qZXJyeV92b2x1bWUiLCJhdmdfc3VibWlzc2lvbnNfcGVyX2RheSIsImF2ZXJhZ2VfbWV0cmljcyIsImF2Z19jYXJkc19wZXJfc2xpcCIsImZpbHRlcmVkRGF0YSIsInRvdGFscyIsInJlZHVjZSIsImFjYyIsInBlcmlvZCIsInN1Ym1pc3Npb25zIiwibW9uX3ZvbHVtZSIsImplcnJ5X3ZvbHVtZSIsInVuaXF1ZUFkZHJlc3NlcyIsIlNldCIsImZvckVhY2giLCJhY3RpdmVfYWRkcmVzc2VzIiwiYWRkIiwiTWF0aCIsIm1heCIsImZyb20iLCJ0b3RhbENhcmRzIiwic3VtIiwidG90YWxfY2FyZHMiLCJkYXlzT2ZXZWVrIiwiYnVpbGRDYWxlbmRhck1hdHJpeCIsImRhaWx5RGF0YSIsInZhbHVlS2V5IiwiYmx1ZVRvWWVsbG93IiwidCIsImMxIiwiYzIiLCJyZ2IiLCJtYXAiLCJjIiwiaSIsInJvdW5kIiwiamVycnlDb2xvclNjYWxlIiwiZ2V0SGVhdG1hcENvbG9yIiwidmFsdWUiLCJtYXhWYWx1ZSIsImNvbG9yVHlwZSIsInJhdGlvIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils.ts\n"));

/***/ })

});