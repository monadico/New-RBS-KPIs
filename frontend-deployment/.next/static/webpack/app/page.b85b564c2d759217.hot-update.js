"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/utils.ts":
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blueToYellow: () => (/* binding */ blueToYellow),\n/* harmony export */   buildCalendarMatrix: () => (/* binding */ buildCalendarMatrix),\n/* harmony export */   cn: () => (/* binding */ cn),\n/* harmony export */   daysOfWeek: () => (/* binding */ daysOfWeek),\n/* harmony export */   filterDataByDateRange: () => (/* binding */ filterDataByDateRange),\n/* harmony export */   formatAddress: () => (/* binding */ formatAddress),\n/* harmony export */   formatCurrency: () => (/* binding */ formatCurrency),\n/* harmony export */   formatDecimal: () => (/* binding */ formatDecimal),\n/* harmony export */   formatNumber: () => (/* binding */ formatNumber),\n/* harmony export */   getCardCountData: () => (/* binding */ getCardCountData),\n/* harmony export */   getFilteredCardCountData: () => (/* binding */ getFilteredCardCountData),\n/* harmony export */   getFilteredMetrics: () => (/* binding */ getFilteredMetrics),\n/* harmony export */   getFilteredTimeframeData: () => (/* binding */ getFilteredTimeframeData),\n/* harmony export */   getHeatmapColor: () => (/* binding */ getHeatmapColor),\n/* harmony export */   getTimeframeData: () => (/* binding */ getTimeframeData),\n/* harmony export */   jerryColorScale: () => (/* binding */ jerryColorScale)\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(app-pages-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ \"(app-pages-browser)/./node_modules/tailwind-merge/dist/bundle-mjs.mjs\");\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n// Data formatting utilities (matching frontend2 logic)\nconst formatNumber = (num)=>{\n    if (num >= 1000000) {\n        return \"\".concat((num / 1000000).toFixed(1), \"M\");\n    } else if (num >= 1000) {\n        return \"\".concat((num / 1000).toFixed(1), \"K\");\n    }\n    return num.toLocaleString();\n};\nconst formatCurrency = (num)=>{\n    return \"$\".concat(num.toLocaleString());\n};\nconst formatDecimal = (num)=>{\n    return num.toFixed(1);\n};\nconst formatAddress = function(address) {\n    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;\n    return \"\".concat(address.substring(0, length), \"...\").concat(address.substring(address.length - length));\n};\n// Data processing utilities\nconst getTimeframeData = (data, selectedTimeframe)=>{\n    // Try new optimized structure first\n    if (data.timeframes && data.timeframes[selectedTimeframe]) {\n        return data.timeframes[selectedTimeframe].activity_over_time || data.activity_over_time;\n    }\n    // Fallback to legacy structure\n    switch(selectedTimeframe){\n        case 'daily':\n            var _data_daily_analytics;\n            return ((_data_daily_analytics = data.daily_analytics) === null || _data_daily_analytics === void 0 ? void 0 : _data_daily_analytics.activity_over_time) || data.activity_over_time;\n        case 'monthly':\n            var _data_monthly_analytics;\n            return ((_data_monthly_analytics = data.monthly_analytics) === null || _data_monthly_analytics === void 0 ? void 0 : _data_monthly_analytics.activity_over_time) || data.activity_over_time;\n        case 'weekly':\n        default:\n            var _data_weekly_analytics;\n            return ((_data_weekly_analytics = data.weekly_analytics) === null || _data_weekly_analytics === void 0 ? void 0 : _data_weekly_analytics.activity_over_time) || data.activity_over_time;\n    }\n};\nconst getCardCountData = (data, selectedTimeframe)=>{\n    // Try new optimized structure first\n    if (data.timeframes && data.timeframes[selectedTimeframe]) {\n        return data.timeframes[selectedTimeframe].slips_by_card_count || [];\n    }\n    // Fallback to legacy structure\n    switch(selectedTimeframe){\n        case 'daily':\n            return data.daily_slips_by_card_count || [];\n        case 'monthly':\n            return data.monthly_slips_by_card_count || [];\n        case 'weekly':\n        default:\n            return data.weekly_slips_by_card_count_new || data.weekly_slips_by_card_count || [];\n    }\n};\n// Filter data based on custom date range\nconst filterDataByDateRange = (data, startDate, endDate)=>{\n    if (!data || !Array.isArray(data)) return [];\n    // Convert dates to YYYY-MM-DD format for string comparison\n    const startDateStr = startDate.toISOString().split('T')[0];\n    const endDateStr = endDate.toISOString().split('T')[0];\n    return data.filter((item)=>{\n        if (!item.start_date) return false;\n        // Compare dates as strings (YYYY-MM-DD format)\n        const itemDateStr = item.start_date;\n        // Check if the date falls within the range (inclusive)\n        return itemDateStr >= startDateStr && itemDateStr <= endDateStr;\n    });\n};\n// Get filtered timeframe data based on selection and custom date range\nconst getFilteredTimeframeData = (data, selectedTimeframe, customStartDate, customEndDate, customRangeConfirmed)=>{\n    // Get the base timeframe data\n    let timeframeData = getTimeframeData(data, selectedTimeframe === \"custom\" ? customRangeConfirmed ? \"daily\" : \"weekly\" : selectedTimeframe);\n    // If custom timeframe is selected, confirmed, and we have date range, filter the data\n    if (selectedTimeframe === \"custom\" && customRangeConfirmed && customStartDate && customEndDate) {\n        timeframeData = filterDataByDateRange(timeframeData, customStartDate, customEndDate);\n    }\n    return timeframeData;\n};\n// Get filtered card count data based on selection and custom date range\nconst getFilteredCardCountData = (data, selectedTimeframe, customStartDate, customEndDate)=>{\n    // Get the base card count data\n    let cardCountData = getCardCountData(data, selectedTimeframe === \"custom\" ? \"daily\" : selectedTimeframe);\n    // If custom timeframe is selected and we have date range, filter the data\n    if (selectedTimeframe === \"custom\" && customStartDate && customEndDate) {\n        cardCountData = filterDataByDateRange(cardCountData, customStartDate, customEndDate);\n    }\n    return cardCountData;\n};\n// Calculate filtered totals for metrics when custom date range is selected\nconst getFilteredMetrics = (data, selectedTimeframe, customStartDate, customEndDate)=>{\n    var _data_average_metrics;\n    if (selectedTimeframe !== \"custom\" || !customStartDate || !customEndDate) {\n        var _data_total_metrics, _data_total_metrics1, _data_total_metrics2, _data_total_metrics3, _data_average_metrics1, _data_average_metrics2;\n        // Return original metrics for non-custom timeframes\n        return {\n            total_submissions: ((_data_total_metrics = data.total_metrics) === null || _data_total_metrics === void 0 ? void 0 : _data_total_metrics.total_submissions) || 0,\n            total_active_addresses: ((_data_total_metrics1 = data.total_metrics) === null || _data_total_metrics1 === void 0 ? void 0 : _data_total_metrics1.total_active_addresses) || 0,\n            total_mon_volume: ((_data_total_metrics2 = data.total_metrics) === null || _data_total_metrics2 === void 0 ? void 0 : _data_total_metrics2.total_mon_volume) || 0,\n            total_jerry_volume: ((_data_total_metrics3 = data.total_metrics) === null || _data_total_metrics3 === void 0 ? void 0 : _data_total_metrics3.total_jerry_volume) || 0,\n            avg_submissions_per_day: ((_data_average_metrics1 = data.average_metrics) === null || _data_average_metrics1 === void 0 ? void 0 : _data_average_metrics1.avg_submissions_per_day) || 0,\n            avg_cards_per_slip: ((_data_average_metrics2 = data.average_metrics) === null || _data_average_metrics2 === void 0 ? void 0 : _data_average_metrics2.avg_cards_per_slip) || 0\n        };\n    }\n    // Get filtered data for custom timeframe\n    const filteredData = getFilteredTimeframeData(data, selectedTimeframe, customStartDate, customEndDate);\n    if (!filteredData || filteredData.length === 0) {\n        return {\n            total_submissions: 0,\n            total_active_addresses: 0,\n            total_mon_volume: 0,\n            total_jerry_volume: 0,\n            avg_submissions_per_day: 0,\n            avg_cards_per_slip: 0\n        };\n    }\n    // Calculate totals from filtered data\n    const totals = filteredData.reduce((acc, period)=>{\n        acc.total_submissions += period.submissions || 0;\n        acc.total_mon_volume += period.mon_volume || 0;\n        acc.total_jerry_volume += period.jerry_volume || 0;\n        return acc;\n    }, {\n        total_submissions: 0,\n        total_mon_volume: 0,\n        total_jerry_volume: 0\n    });\n    // Calculate unique active addresses from filtered data\n    const uniqueAddresses = new Set();\n    filteredData.forEach((period)=>{\n        if (period.active_addresses) {\n            // This is a simplified approach - in reality, we'd need to track individual addresses\n            // For now, we'll use the max active addresses from the filtered period\n            uniqueAddresses.add(period.active_addresses);\n        }\n    });\n    const total_active_addresses = Math.max(...Array.from(uniqueAddresses), 0);\n    // Calculate averages\n    const avg_submissions_per_day = filteredData.length > 0 ? totals.total_submissions / filteredData.length : 0;\n    const avg_cards_per_slip = ((_data_average_metrics = data.average_metrics) === null || _data_average_metrics === void 0 ? void 0 : _data_average_metrics.avg_cards_per_slip) || 0 // Keep original for now\n    ;\n    return {\n        total_submissions: totals.total_submissions,\n        total_active_addresses,\n        total_mon_volume: totals.total_mon_volume,\n        total_jerry_volume: totals.total_jerry_volume,\n        avg_submissions_per_day,\n        avg_cards_per_slip\n    };\n};\n// Heatmap utilities\nconst daysOfWeek = [\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\",\n    \"Sunday\"\n];\nconst buildCalendarMatrix = (dailyData, valueKey)=>{\n    // Implementation for calendar heatmap matrix\n    // This would be implemented based on the frontend2 logic\n    return [];\n};\n// Color scale utilities\nconst blueToYellow = (t)=>{\n    const c1 = [\n        99,\n        102,\n        241\n    ] // blue\n    ;\n    const c2 = [\n        245,\n        158,\n        11\n    ] // yellow\n    ;\n    const rgb = c1.map((c, i)=>Math.round(c + (c2[i] - c) * t));\n    return \"rgb(\".concat(rgb[0], \",\").concat(rgb[1], \",\").concat(rgb[2], \")\");\n};\nconst jerryColorScale = (t)=>{\n    if (t === 0) return '#f3f4f6';\n    if (t < 0.1) return '#dbeafe';\n    if (t < 0.3) return '#93c5fd';\n    if (t < 0.6) return '#3b82f6';\n    if (t < 0.8) return '#1d4ed8';\n    return '#1e40af';\n};\nconst getHeatmapColor = function(value, maxValue) {\n    let colorType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"blue-yellow\";\n    if (maxValue === 0) return '#f3f4f6';\n    const ratio = value / maxValue;\n    if (colorType === \"green-red\") {\n        // Green to red scale\n        if (ratio === 0) return '#f3f4f6';\n        if (ratio < 0.1) return '#dcfce7';\n        if (ratio < 0.3) return '#86efac';\n        if (ratio < 0.6) return '#22c55e';\n        if (ratio < 0.8) return '#15803d';\n        return '#166534';\n    }\n    // Default blue-yellow scale\n    return jerryColorScale(ratio);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsU0FBUzs7SUFDbkMsTUFBTUMsTUFBTUYsR0FBR0csR0FBRyxDQUFDLENBQUNDLEdBQUdDLElBQU1kLEtBQUtlLEtBQUssQ0FBQ0YsSUFBSSxDQUFDSCxFQUFFLENBQUNJLEVBQUUsR0FBR0QsQ0FBQUEsSUFBS0w7SUFDMUQsT0FBTyxPQUFpQkcsT0FBVkEsR0FBRyxDQUFDLEVBQUUsRUFBQyxLQUFhQSxPQUFWQSxHQUFHLENBQUMsRUFBRSxFQUFDLEtBQVUsT0FBUEEsR0FBRyxDQUFDLEVBQUUsRUFBQztBQUMzQyxFQUFDO0FBRU0sTUFBTUssa0JBQWtCLENBQUNSO0lBQzlCLElBQUlBLE1BQU0sR0FBRyxPQUFPO0lBQ3BCLElBQUlBLElBQUksS0FBSyxPQUFPO0lBQ3BCLElBQUlBLElBQUksS0FBSyxPQUFPO0lBQ3BCLElBQUlBLElBQUksS0FBSyxPQUFPO0lBQ3BCLElBQUlBLElBQUksS0FBSyxPQUFPO0lBQ3BCLE9BQU87QUFDVCxFQUFDO0FBRU0sTUFBTVMsa0JBQWtCLFNBQUNDLE9BQWVDO1FBQWtCQyw2RUFBeUM7SUFDeEcsSUFBSUQsYUFBYSxHQUFHLE9BQU87SUFDM0IsTUFBTUUsUUFBUUgsUUFBUUM7SUFFdEIsSUFBSUMsY0FBYyxhQUFhO1FBQzdCLHFCQUFxQjtRQUNyQixJQUFJQyxVQUFVLEdBQUcsT0FBTztRQUN4QixJQUFJQSxRQUFRLEtBQUssT0FBTztRQUN4QixJQUFJQSxRQUFRLEtBQUssT0FBTztRQUN4QixJQUFJQSxRQUFRLEtBQUssT0FBTztRQUN4QixJQUFJQSxRQUFRLEtBQUssT0FBTztRQUN4QixPQUFPO0lBQ1Q7SUFFQSw0QkFBNEI7SUFDNUIsT0FBT0wsZ0JBQWdCSztBQUN6QixFQUFDIiwic291cmNlcyI6WyIvcm9vdC9oeXBlcnN5bmMtY2xpZW50LXB5dGhvbi9mcm9udGVuZC1kZXBsb3ltZW50L2xpYi91dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0eXBlIENsYXNzVmFsdWUsIGNsc3ggfSBmcm9tIFwiY2xzeFwiXG5pbXBvcnQgeyB0d01lcmdlIH0gZnJvbSBcInRhaWx3aW5kLW1lcmdlXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGNuKC4uLmlucHV0czogQ2xhc3NWYWx1ZVtdKSB7XG4gIHJldHVybiB0d01lcmdlKGNsc3goaW5wdXRzKSlcbn1cblxuLy8gRGF0YSBmb3JtYXR0aW5nIHV0aWxpdGllcyAobWF0Y2hpbmcgZnJvbnRlbmQyIGxvZ2ljKVxuZXhwb3J0IGNvbnN0IGZvcm1hdE51bWJlciA9IChudW06IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGlmIChudW0gPj0gMTAwMDAwMCkge1xuICAgIHJldHVybiBgJHsobnVtIC8gMTAwMDAwMCkudG9GaXhlZCgxKX1NYFxuICB9IGVsc2UgaWYgKG51bSA+PSAxMDAwKSB7XG4gICAgcmV0dXJuIGAkeyhudW0gLyAxMDAwKS50b0ZpeGVkKDEpfUtgXG4gIH1cbiAgcmV0dXJuIG51bS50b0xvY2FsZVN0cmluZygpXG59XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRDdXJyZW5jeSA9IChudW06IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIHJldHVybiBgJCR7bnVtLnRvTG9jYWxlU3RyaW5nKCl9YFxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0RGVjaW1hbCA9IChudW06IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIHJldHVybiBudW0udG9GaXhlZCgxKVxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0QWRkcmVzcyA9IChhZGRyZXNzOiBzdHJpbmcsIGxlbmd0aCA9IDYpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gYCR7YWRkcmVzcy5zdWJzdHJpbmcoMCwgbGVuZ3RoKX0uLi4ke2FkZHJlc3Muc3Vic3RyaW5nKGFkZHJlc3MubGVuZ3RoIC0gbGVuZ3RoKX1gXG59XG5cbi8vIERhdGEgcHJvY2Vzc2luZyB1dGlsaXRpZXNcbmV4cG9ydCBjb25zdCBnZXRUaW1lZnJhbWVEYXRhID0gKGRhdGE6IGFueSwgc2VsZWN0ZWRUaW1lZnJhbWU6IHN0cmluZykgPT4ge1xuICAvLyBUcnkgbmV3IG9wdGltaXplZCBzdHJ1Y3R1cmUgZmlyc3RcbiAgaWYgKGRhdGEudGltZWZyYW1lcyAmJiBkYXRhLnRpbWVmcmFtZXNbc2VsZWN0ZWRUaW1lZnJhbWVdKSB7XG4gICAgcmV0dXJuIGRhdGEudGltZWZyYW1lc1tzZWxlY3RlZFRpbWVmcmFtZV0uYWN0aXZpdHlfb3Zlcl90aW1lIHx8IGRhdGEuYWN0aXZpdHlfb3Zlcl90aW1lXG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGxlZ2FjeSBzdHJ1Y3R1cmVcbiAgc3dpdGNoIChzZWxlY3RlZFRpbWVmcmFtZSkge1xuICAgIGNhc2UgJ2RhaWx5JzpcbiAgICAgIHJldHVybiBkYXRhLmRhaWx5X2FuYWx5dGljcz8uYWN0aXZpdHlfb3Zlcl90aW1lIHx8IGRhdGEuYWN0aXZpdHlfb3Zlcl90aW1lXG4gICAgY2FzZSAnbW9udGhseSc6XG4gICAgICByZXR1cm4gZGF0YS5tb250aGx5X2FuYWx5dGljcz8uYWN0aXZpdHlfb3Zlcl90aW1lIHx8IGRhdGEuYWN0aXZpdHlfb3Zlcl90aW1lXG4gICAgY2FzZSAnd2Vla2x5JzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGEud2Vla2x5X2FuYWx5dGljcz8uYWN0aXZpdHlfb3Zlcl90aW1lIHx8IGRhdGEuYWN0aXZpdHlfb3Zlcl90aW1lXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldENhcmRDb3VudERhdGEgPSAoZGF0YTogYW55LCBzZWxlY3RlZFRpbWVmcmFtZTogc3RyaW5nKSA9PiB7XG4gIC8vIFRyeSBuZXcgb3B0aW1pemVkIHN0cnVjdHVyZSBmaXJzdFxuICBpZiAoZGF0YS50aW1lZnJhbWVzICYmIGRhdGEudGltZWZyYW1lc1tzZWxlY3RlZFRpbWVmcmFtZV0pIHtcbiAgICByZXR1cm4gZGF0YS50aW1lZnJhbWVzW3NlbGVjdGVkVGltZWZyYW1lXS5zbGlwc19ieV9jYXJkX2NvdW50IHx8IFtdXG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGxlZ2FjeSBzdHJ1Y3R1cmVcbiAgc3dpdGNoIChzZWxlY3RlZFRpbWVmcmFtZSkge1xuICAgIGNhc2UgJ2RhaWx5JzpcbiAgICAgIHJldHVybiBkYXRhLmRhaWx5X3NsaXBzX2J5X2NhcmRfY291bnQgfHwgW11cbiAgICBjYXNlICdtb250aGx5JzpcbiAgICAgIHJldHVybiBkYXRhLm1vbnRobHlfc2xpcHNfYnlfY2FyZF9jb3VudCB8fCBbXVxuICAgIGNhc2UgJ3dlZWtseSc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRhLndlZWtseV9zbGlwc19ieV9jYXJkX2NvdW50X25ldyB8fCBkYXRhLndlZWtseV9zbGlwc19ieV9jYXJkX2NvdW50IHx8IFtdXG4gIH1cbn1cblxuLy8gRmlsdGVyIGRhdGEgYmFzZWQgb24gY3VzdG9tIGRhdGUgcmFuZ2VcbmV4cG9ydCBjb25zdCBmaWx0ZXJEYXRhQnlEYXRlUmFuZ2UgPSAoZGF0YTogYW55W10sIHN0YXJ0RGF0ZTogRGF0ZSwgZW5kRGF0ZTogRGF0ZSkgPT4ge1xuICBpZiAoIWRhdGEgfHwgIUFycmF5LmlzQXJyYXkoZGF0YSkpIHJldHVybiBbXVxuICBcbiAgLy8gQ29udmVydCBkYXRlcyB0byBZWVlZLU1NLUREIGZvcm1hdCBmb3Igc3RyaW5nIGNvbXBhcmlzb25cbiAgY29uc3Qgc3RhcnREYXRlU3RyID0gc3RhcnREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxuICBjb25zdCBlbmREYXRlU3RyID0gZW5kRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgXG4gIHJldHVybiBkYXRhLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgIGlmICghaXRlbS5zdGFydF9kYXRlKSByZXR1cm4gZmFsc2VcbiAgICBcbiAgICAvLyBDb21wYXJlIGRhdGVzIGFzIHN0cmluZ3MgKFlZWVktTU0tREQgZm9ybWF0KVxuICAgIGNvbnN0IGl0ZW1EYXRlU3RyID0gaXRlbS5zdGFydF9kYXRlXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGRhdGUgZmFsbHMgd2l0aGluIHRoZSByYW5nZSAoaW5jbHVzaXZlKVxuICAgIHJldHVybiBpdGVtRGF0ZVN0ciA+PSBzdGFydERhdGVTdHIgJiYgaXRlbURhdGVTdHIgPD0gZW5kRGF0ZVN0clxuICB9KVxufVxuXG4vLyBHZXQgZmlsdGVyZWQgdGltZWZyYW1lIGRhdGEgYmFzZWQgb24gc2VsZWN0aW9uIGFuZCBjdXN0b20gZGF0ZSByYW5nZVxuZXhwb3J0IGNvbnN0IGdldEZpbHRlcmVkVGltZWZyYW1lRGF0YSA9IChcbiAgZGF0YTogYW55LCBcbiAgc2VsZWN0ZWRUaW1lZnJhbWU6IHN0cmluZywgXG4gIGN1c3RvbVN0YXJ0RGF0ZT86IERhdGUsIFxuICBjdXN0b21FbmREYXRlPzogRGF0ZSxcbiAgY3VzdG9tUmFuZ2VDb25maXJtZWQ/OiBib29sZWFuXG4pID0+IHtcbiAgLy8gR2V0IHRoZSBiYXNlIHRpbWVmcmFtZSBkYXRhXG4gIGxldCB0aW1lZnJhbWVEYXRhID0gZ2V0VGltZWZyYW1lRGF0YShkYXRhLCBzZWxlY3RlZFRpbWVmcmFtZSA9PT0gXCJjdXN0b21cIiA/IChjdXN0b21SYW5nZUNvbmZpcm1lZCA/IFwiZGFpbHlcIiA6IFwid2Vla2x5XCIpIDogc2VsZWN0ZWRUaW1lZnJhbWUpXG4gIFxuICAvLyBJZiBjdXN0b20gdGltZWZyYW1lIGlzIHNlbGVjdGVkLCBjb25maXJtZWQsIGFuZCB3ZSBoYXZlIGRhdGUgcmFuZ2UsIGZpbHRlciB0aGUgZGF0YVxuICBpZiAoc2VsZWN0ZWRUaW1lZnJhbWUgPT09IFwiY3VzdG9tXCIgJiYgY3VzdG9tUmFuZ2VDb25maXJtZWQgJiYgY3VzdG9tU3RhcnREYXRlICYmIGN1c3RvbUVuZERhdGUpIHtcbiAgICB0aW1lZnJhbWVEYXRhID0gZmlsdGVyRGF0YUJ5RGF0ZVJhbmdlKHRpbWVmcmFtZURhdGEsIGN1c3RvbVN0YXJ0RGF0ZSwgY3VzdG9tRW5kRGF0ZSlcbiAgfVxuICBcbiAgcmV0dXJuIHRpbWVmcmFtZURhdGFcbn1cblxuLy8gR2V0IGZpbHRlcmVkIGNhcmQgY291bnQgZGF0YSBiYXNlZCBvbiBzZWxlY3Rpb24gYW5kIGN1c3RvbSBkYXRlIHJhbmdlXG5leHBvcnQgY29uc3QgZ2V0RmlsdGVyZWRDYXJkQ291bnREYXRhID0gKFxuICBkYXRhOiBhbnksIFxuICBzZWxlY3RlZFRpbWVmcmFtZTogc3RyaW5nLCBcbiAgY3VzdG9tU3RhcnREYXRlPzogRGF0ZSwgXG4gIGN1c3RvbUVuZERhdGU/OiBEYXRlXG4pID0+IHtcbiAgLy8gR2V0IHRoZSBiYXNlIGNhcmQgY291bnQgZGF0YVxuICBsZXQgY2FyZENvdW50RGF0YSA9IGdldENhcmRDb3VudERhdGEoZGF0YSwgc2VsZWN0ZWRUaW1lZnJhbWUgPT09IFwiY3VzdG9tXCIgPyBcImRhaWx5XCIgOiBzZWxlY3RlZFRpbWVmcmFtZSlcbiAgXG4gIC8vIElmIGN1c3RvbSB0aW1lZnJhbWUgaXMgc2VsZWN0ZWQgYW5kIHdlIGhhdmUgZGF0ZSByYW5nZSwgZmlsdGVyIHRoZSBkYXRhXG4gIGlmIChzZWxlY3RlZFRpbWVmcmFtZSA9PT0gXCJjdXN0b21cIiAmJiBjdXN0b21TdGFydERhdGUgJiYgY3VzdG9tRW5kRGF0ZSkge1xuICAgIGNhcmRDb3VudERhdGEgPSBmaWx0ZXJEYXRhQnlEYXRlUmFuZ2UoY2FyZENvdW50RGF0YSwgY3VzdG9tU3RhcnREYXRlLCBjdXN0b21FbmREYXRlKVxuICB9XG4gIFxuICByZXR1cm4gY2FyZENvdW50RGF0YVxufVxuXG4vLyBDYWxjdWxhdGUgZmlsdGVyZWQgdG90YWxzIGZvciBtZXRyaWNzIHdoZW4gY3VzdG9tIGRhdGUgcmFuZ2UgaXMgc2VsZWN0ZWRcbmV4cG9ydCBjb25zdCBnZXRGaWx0ZXJlZE1ldHJpY3MgPSAoXG4gIGRhdGE6IGFueSxcbiAgc2VsZWN0ZWRUaW1lZnJhbWU6IHN0cmluZyxcbiAgY3VzdG9tU3RhcnREYXRlPzogRGF0ZSxcbiAgY3VzdG9tRW5kRGF0ZT86IERhdGVcbikgPT4ge1xuICBpZiAoc2VsZWN0ZWRUaW1lZnJhbWUgIT09IFwiY3VzdG9tXCIgfHwgIWN1c3RvbVN0YXJ0RGF0ZSB8fCAhY3VzdG9tRW5kRGF0ZSkge1xuICAgIC8vIFJldHVybiBvcmlnaW5hbCBtZXRyaWNzIGZvciBub24tY3VzdG9tIHRpbWVmcmFtZXNcbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxfc3VibWlzc2lvbnM6IGRhdGEudG90YWxfbWV0cmljcz8udG90YWxfc3VibWlzc2lvbnMgfHwgMCxcbiAgICAgIHRvdGFsX2FjdGl2ZV9hZGRyZXNzZXM6IGRhdGEudG90YWxfbWV0cmljcz8udG90YWxfYWN0aXZlX2FkZHJlc3NlcyB8fCAwLFxuICAgICAgdG90YWxfbW9uX3ZvbHVtZTogZGF0YS50b3RhbF9tZXRyaWNzPy50b3RhbF9tb25fdm9sdW1lIHx8IDAsXG4gICAgICB0b3RhbF9qZXJyeV92b2x1bWU6IGRhdGEudG90YWxfbWV0cmljcz8udG90YWxfamVycnlfdm9sdW1lIHx8IDAsXG4gICAgICBhdmdfc3VibWlzc2lvbnNfcGVyX2RheTogZGF0YS5hdmVyYWdlX21ldHJpY3M/LmF2Z19zdWJtaXNzaW9uc19wZXJfZGF5IHx8IDAsXG4gICAgICBhdmdfY2FyZHNfcGVyX3NsaXA6IGRhdGEuYXZlcmFnZV9tZXRyaWNzPy5hdmdfY2FyZHNfcGVyX3NsaXAgfHwgMFxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBmaWx0ZXJlZCBkYXRhIGZvciBjdXN0b20gdGltZWZyYW1lXG4gIGNvbnN0IGZpbHRlcmVkRGF0YSA9IGdldEZpbHRlcmVkVGltZWZyYW1lRGF0YShkYXRhLCBzZWxlY3RlZFRpbWVmcmFtZSwgY3VzdG9tU3RhcnREYXRlLCBjdXN0b21FbmREYXRlKVxuICBcbiAgaWYgKCFmaWx0ZXJlZERhdGEgfHwgZmlsdGVyZWREYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbF9zdWJtaXNzaW9uczogMCxcbiAgICAgIHRvdGFsX2FjdGl2ZV9hZGRyZXNzZXM6IDAsXG4gICAgICB0b3RhbF9tb25fdm9sdW1lOiAwLFxuICAgICAgdG90YWxfamVycnlfdm9sdW1lOiAwLFxuICAgICAgYXZnX3N1Ym1pc3Npb25zX3Blcl9kYXk6IDAsXG4gICAgICBhdmdfY2FyZHNfcGVyX3NsaXA6IDBcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgdG90YWxzIGZyb20gZmlsdGVyZWQgZGF0YVxuICBjb25zdCB0b3RhbHMgPSBmaWx0ZXJlZERhdGEucmVkdWNlKChhY2M6IGFueSwgcGVyaW9kOiBhbnkpID0+IHtcbiAgICBhY2MudG90YWxfc3VibWlzc2lvbnMgKz0gcGVyaW9kLnN1Ym1pc3Npb25zIHx8IDBcbiAgICBhY2MudG90YWxfbW9uX3ZvbHVtZSArPSBwZXJpb2QubW9uX3ZvbHVtZSB8fCAwXG4gICAgYWNjLnRvdGFsX2plcnJ5X3ZvbHVtZSArPSBwZXJpb2QuamVycnlfdm9sdW1lIHx8IDBcbiAgICByZXR1cm4gYWNjXG4gIH0sIHtcbiAgICB0b3RhbF9zdWJtaXNzaW9uczogMCxcbiAgICB0b3RhbF9tb25fdm9sdW1lOiAwLFxuICAgIHRvdGFsX2plcnJ5X3ZvbHVtZTogMFxuICB9KVxuXG4gIC8vIENhbGN1bGF0ZSB1bmlxdWUgYWN0aXZlIGFkZHJlc3NlcyBmcm9tIGZpbHRlcmVkIGRhdGFcbiAgY29uc3QgdW5pcXVlQWRkcmVzc2VzID0gbmV3IFNldDxudW1iZXI+KClcbiAgZmlsdGVyZWREYXRhLmZvckVhY2goKHBlcmlvZDogYW55KSA9PiB7XG4gICAgaWYgKHBlcmlvZC5hY3RpdmVfYWRkcmVzc2VzKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBhcHByb2FjaCAtIGluIHJlYWxpdHksIHdlJ2QgbmVlZCB0byB0cmFjayBpbmRpdmlkdWFsIGFkZHJlc3Nlc1xuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdXNlIHRoZSBtYXggYWN0aXZlIGFkZHJlc3NlcyBmcm9tIHRoZSBmaWx0ZXJlZCBwZXJpb2RcbiAgICAgIHVuaXF1ZUFkZHJlc3Nlcy5hZGQocGVyaW9kLmFjdGl2ZV9hZGRyZXNzZXMpXG4gICAgfVxuICB9KVxuICBjb25zdCB0b3RhbF9hY3RpdmVfYWRkcmVzc2VzID0gTWF0aC5tYXgoLi4uQXJyYXkuZnJvbSh1bmlxdWVBZGRyZXNzZXMpIGFzIG51bWJlcltdLCAwKVxuXG4gIC8vIENhbGN1bGF0ZSBhdmVyYWdlc1xuICBjb25zdCBhdmdfc3VibWlzc2lvbnNfcGVyX2RheSA9IGZpbHRlcmVkRGF0YS5sZW5ndGggPiAwID8gdG90YWxzLnRvdGFsX3N1Ym1pc3Npb25zIC8gZmlsdGVyZWREYXRhLmxlbmd0aCA6IDBcbiAgY29uc3QgYXZnX2NhcmRzX3Blcl9zbGlwID0gZGF0YS5hdmVyYWdlX21ldHJpY3M/LmF2Z19jYXJkc19wZXJfc2xpcCB8fCAwIC8vIEtlZXAgb3JpZ2luYWwgZm9yIG5vd1xuXG4gIHJldHVybiB7XG4gICAgdG90YWxfc3VibWlzc2lvbnM6IHRvdGFscy50b3RhbF9zdWJtaXNzaW9ucyxcbiAgICB0b3RhbF9hY3RpdmVfYWRkcmVzc2VzLFxuICAgIHRvdGFsX21vbl92b2x1bWU6IHRvdGFscy50b3RhbF9tb25fdm9sdW1lLFxuICAgIHRvdGFsX2plcnJ5X3ZvbHVtZTogdG90YWxzLnRvdGFsX2plcnJ5X3ZvbHVtZSxcbiAgICBhdmdfc3VibWlzc2lvbnNfcGVyX2RheSxcbiAgICBhdmdfY2FyZHNfcGVyX3NsaXBcbiAgfVxufVxuXG4vLyBIZWF0bWFwIHV0aWxpdGllc1xuZXhwb3J0IGNvbnN0IGRheXNPZldlZWsgPSBbXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiLCBcIlN1bmRheVwiXVxuXG5leHBvcnQgY29uc3QgYnVpbGRDYWxlbmRhck1hdHJpeCA9IChcbiAgZGFpbHlEYXRhOiBhbnlbXSxcbiAgdmFsdWVLZXk6IGtleW9mIGFueVxuKTogYW55W11bXSA9PiB7XG4gIC8vIEltcGxlbWVudGF0aW9uIGZvciBjYWxlbmRhciBoZWF0bWFwIG1hdHJpeFxuICAvLyBUaGlzIHdvdWxkIGJlIGltcGxlbWVudGVkIGJhc2VkIG9uIHRoZSBmcm9udGVuZDIgbG9naWNcbiAgcmV0dXJuIFtdXG59XG5cbi8vIENvbG9yIHNjYWxlIHV0aWxpdGllc1xuZXhwb3J0IGNvbnN0IGJsdWVUb1llbGxvdyA9ICh0OiBudW1iZXIpID0+IHtcbiAgY29uc3QgYzEgPSBbOTksIDEwMiwgMjQxXSAvLyBibHVlXG4gIGNvbnN0IGMyID0gWzI0NSwgMTU4LCAxMV0gLy8geWVsbG93XG4gIGNvbnN0IHJnYiA9IGMxLm1hcCgoYywgaSkgPT4gTWF0aC5yb3VuZChjICsgKGMyW2ldIC0gYykgKiB0KSlcbiAgcmV0dXJuIGByZ2IoJHtyZ2JbMF19LCR7cmdiWzFdfSwke3JnYlsyXX0pYFxufVxuXG5leHBvcnQgY29uc3QgamVycnlDb2xvclNjYWxlID0gKHQ6IG51bWJlcikgPT4ge1xuICBpZiAodCA9PT0gMCkgcmV0dXJuICcjZjNmNGY2J1xuICBpZiAodCA8IDAuMSkgcmV0dXJuICcjZGJlYWZlJ1xuICBpZiAodCA8IDAuMykgcmV0dXJuICcjOTNjNWZkJ1xuICBpZiAodCA8IDAuNikgcmV0dXJuICcjM2I4MmY2J1xuICBpZiAodCA8IDAuOCkgcmV0dXJuICcjMWQ0ZWQ4J1xuICByZXR1cm4gJyMxZTQwYWYnXG59XG5cbmV4cG9ydCBjb25zdCBnZXRIZWF0bWFwQ29sb3IgPSAodmFsdWU6IG51bWJlciwgbWF4VmFsdWU6IG51bWJlciwgY29sb3JUeXBlOiBcImJsdWUteWVsbG93XCIgfCBcImdyZWVuLXJlZFwiID0gXCJibHVlLXllbGxvd1wiKTogc3RyaW5nID0+IHtcbiAgaWYgKG1heFZhbHVlID09PSAwKSByZXR1cm4gJyNmM2Y0ZjYnXG4gIGNvbnN0IHJhdGlvID0gdmFsdWUgLyBtYXhWYWx1ZVxuICBcbiAgaWYgKGNvbG9yVHlwZSA9PT0gXCJncmVlbi1yZWRcIikge1xuICAgIC8vIEdyZWVuIHRvIHJlZCBzY2FsZVxuICAgIGlmIChyYXRpbyA9PT0gMCkgcmV0dXJuICcjZjNmNGY2J1xuICAgIGlmIChyYXRpbyA8IDAuMSkgcmV0dXJuICcjZGNmY2U3J1xuICAgIGlmIChyYXRpbyA8IDAuMykgcmV0dXJuICcjODZlZmFjJ1xuICAgIGlmIChyYXRpbyA8IDAuNikgcmV0dXJuICcjMjJjNTVlJ1xuICAgIGlmIChyYXRpbyA8IDAuOCkgcmV0dXJuICcjMTU4MDNkJ1xuICAgIHJldHVybiAnIzE2NjUzNCdcbiAgfVxuICBcbiAgLy8gRGVmYXVsdCBibHVlLXllbGxvdyBzY2FsZVxuICByZXR1cm4gamVycnlDb2xvclNjYWxlKHJhdGlvKVxufVxuIl0sIm5hbWVzIjpbImNsc3giLCJ0d01lcmdlIiwiY24iLCJpbnB1dHMiLCJmb3JtYXROdW1iZXIiLCJudW0iLCJ0b0ZpeGVkIiwidG9Mb2NhbGVTdHJpbmciLCJmb3JtYXRDdXJyZW5jeSIsImZvcm1hdERlY2ltYWwiLCJmb3JtYXRBZGRyZXNzIiwiYWRkcmVzcyIsImxlbmd0aCIsInN1YnN0cmluZyIsImdldFRpbWVmcmFtZURhdGEiLCJkYXRhIiwic2VsZWN0ZWRUaW1lZnJhbWUiLCJ0aW1lZnJhbWVzIiwiYWN0aXZpdHlfb3Zlcl90aW1lIiwiZGFpbHlfYW5hbHl0aWNzIiwibW9udGhseV9hbmFseXRpY3MiLCJ3ZWVrbHlfYW5hbHl0aWNzIiwiZ2V0Q2FyZENvdW50RGF0YSIsInNsaXBzX2J5X2NhcmRfY291bnQiLCJkYWlseV9zbGlwc19ieV9jYXJkX2NvdW50IiwibW9udGhseV9zbGlwc19ieV9jYXJkX2NvdW50Iiwid2Vla2x5X3NsaXBzX2J5X2NhcmRfY291bnRfbmV3Iiwid2Vla2x5X3NsaXBzX2J5X2NhcmRfY291bnQiLCJmaWx0ZXJEYXRhQnlEYXRlUmFuZ2UiLCJzdGFydERhdGUiLCJlbmREYXRlIiwiQXJyYXkiLCJpc0FycmF5Iiwic3RhcnREYXRlU3RyIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImVuZERhdGVTdHIiLCJmaWx0ZXIiLCJpdGVtIiwic3RhcnRfZGF0ZSIsIml0ZW1EYXRlU3RyIiwiZ2V0RmlsdGVyZWRUaW1lZnJhbWVEYXRhIiwiY3VzdG9tU3RhcnREYXRlIiwiY3VzdG9tRW5kRGF0ZSIsImN1c3RvbVJhbmdlQ29uZmlybWVkIiwidGltZWZyYW1lRGF0YSIsImdldEZpbHRlcmVkQ2FyZENvdW50RGF0YSIsImNhcmRDb3VudERhdGEiLCJnZXRGaWx0ZXJlZE1ldHJpY3MiLCJ0b3RhbF9zdWJtaXNzaW9ucyIsInRvdGFsX21ldHJpY3MiLCJ0b3RhbF9hY3RpdmVfYWRkcmVzc2VzIiwidG90YWxfbW9uX3ZvbHVtZSIsInRvdGFsX2plcnJ5X3ZvbHVtZSIsImF2Z19zdWJtaXNzaW9uc19wZXJfZGF5IiwiYXZlcmFnZV9tZXRyaWNzIiwiYXZnX2NhcmRzX3Blcl9zbGlwIiwiZmlsdGVyZWREYXRhIiwidG90YWxzIiwicmVkdWNlIiwiYWNjIiwicGVyaW9kIiwic3VibWlzc2lvbnMiLCJtb25fdm9sdW1lIiwiamVycnlfdm9sdW1lIiwidW5pcXVlQWRkcmVzc2VzIiwiU2V0IiwiZm9yRWFjaCIsImFjdGl2ZV9hZGRyZXNzZXMiLCJhZGQiLCJNYXRoIiwibWF4IiwiZnJvbSIsImRheXNPZldlZWsiLCJidWlsZENhbGVuZGFyTWF0cml4IiwiZGFpbHlEYXRhIiwidmFsdWVLZXkiLCJibHVlVG9ZZWxsb3ciLCJ0IiwiYzEiLCJjMiIsInJnYiIsIm1hcCIsImMiLCJpIiwicm91bmQiLCJqZXJyeUNvbG9yU2NhbGUiLCJnZXRIZWF0bWFwQ29sb3IiLCJ2YWx1ZSIsIm1heFZhbHVlIiwiY29sb3JUeXBlIiwicmF0aW8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/utils.ts\n"));

/***/ })

});